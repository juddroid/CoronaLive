{"ast":null,"code":"import { isNumber } from \"../helpers/utils\";\nconst SNAP_VALUES = [1, 2, 5, 10];\nconst DEFAULT_PIXELS_PER_STEP = 88;\n\nfunction adjustLimitForOverflow({\n  min,\n  max\n}, stepSize, overflowed) {\n  return {\n    min: overflowed.min ? min - stepSize : min,\n    max: overflowed.max ? max + stepSize : max\n  };\n}\n\nfunction isSeriesOverflowed(scaleData, {\n  min,\n  max\n}, scaleOption) {\n  var _a, _b;\n\n  const scaleDataLimit = scaleData.limit;\n  const hasMinOption = isNumber((_a = scaleOption) === null || _a === void 0 ? void 0 : _a.min);\n  const hasMaxOption = isNumber((_b = scaleOption) === null || _b === void 0 ? void 0 : _b.max);\n  const isOverflowedMin = !hasMinOption && scaleDataLimit.min === min && scaleDataLimit.min !== 0;\n  const isOverflowedMax = !hasMaxOption && scaleDataLimit.max === max && scaleDataLimit.max !== 0;\n\n  if (!isOverflowedMin && !isOverflowedMax) {\n    return null;\n  }\n\n  return {\n    min: isOverflowedMin,\n    max: isOverflowedMax\n  };\n}\n\nfunction getDigits(num) {\n  const logNumberDividedLN10 = num === 0 ? 1 : Math.log(Math.abs(num)) / Math.LN10;\n  return Math.pow(10, Math.floor(logNumberDividedLN10));\n}\n\nfunction getSnappedNumber(num) {\n  let snapNumber = 0;\n\n  for (let i = 0, t = SNAP_VALUES.length; i < t; i += 1) {\n    snapNumber = SNAP_VALUES[i];\n    const guideValue = (snapNumber + (SNAP_VALUES[i + 1] || snapNumber)) / 2;\n\n    if (num <= guideValue) {\n      break;\n    }\n  }\n\n  return snapNumber;\n}\n\nfunction getNormalizedStep(stepSize) {\n  const placeNumber = getDigits(stepSize);\n  const simplifiedStepValue = stepSize / placeNumber;\n  return getSnappedNumber(simplifiedStepValue) * placeNumber;\n}\n/**\n * Get normalized limit values\n * max = 155 and step = 10 ---> max = 160\n */\n\n\nfunction getNormalizedLimit(limit, stepSize) {\n  let {\n    min,\n    max\n  } = limit;\n  const minNumber = Math.min(getDigits(max), getDigits(stepSize));\n  const placeNumber = minNumber > 1 ? 1 : 1 / minNumber;\n  const fixedStep = stepSize * placeNumber; // ceil max value step digits\n\n  max = Math.ceil(max * placeNumber / fixedStep) * fixedStep / placeNumber;\n\n  if (min > stepSize) {\n    // floor min value to multiples of step\n    min = Math.floor(min * placeNumber / fixedStep) * fixedStep / placeNumber;\n  } else if (min < 0) {\n    min = -(Math.ceil(Math.abs(min) * placeNumber / fixedStep) * fixedStep) / placeNumber;\n  } else {\n    min = 0;\n  }\n\n  return {\n    min,\n    max\n  };\n}\n\nexport function getNormalizedStepCount(limitSize, stepSize) {\n  const multiplier = 1 / Math.min(getDigits(limitSize), getDigits(stepSize));\n  return Math.ceil(limitSize * multiplier / (stepSize * multiplier));\n}\n\nfunction hasStepSize(stepSize) {\n  return isNumber(stepSize);\n}\n\nfunction getNormalizedScale(scaleData, scale) {\n  const stepSize = hasStepSize(scale.stepSize) ? scaleData.stepSize : getNormalizedStep(scaleData.stepSize);\n  const edge = getNormalizedLimit(scaleData.limit, stepSize);\n  const limitSize = Math.abs(edge.max - edge.min);\n  const stepCount = getNormalizedStepCount(limitSize, stepSize);\n  return {\n    limit: {\n      min: edge.min,\n      max: edge.max\n    },\n    stepSize,\n    stepCount\n  };\n}\n\nfunction getRoughScale(scale, offsetSize, minStepSize = 1) {\n  const {\n    min,\n    max\n  } = scale;\n  const limitSize = Math.abs(max - min);\n  const valuePerPixel = limitSize / offsetSize;\n  let stepCount = Math.ceil(offsetSize / DEFAULT_PIXELS_PER_STEP);\n  const pixelsPerStep = offsetSize / stepCount;\n  let stepSize = valuePerPixel * pixelsPerStep;\n\n  if (hasStepSize(scale.stepSize)) {\n    stepSize = scale.stepSize;\n    stepCount = limitSize / stepSize;\n  } else if (isNumber(minStepSize) && stepSize < minStepSize) {\n    stepSize = minStepSize;\n    stepCount = limitSize / stepSize;\n  }\n\n  return {\n    limit: {\n      min,\n      max\n    },\n    stepSize,\n    stepCount\n  };\n}\n\nexport function makeScaleOption(dataRange, scaleOptions) {\n  var _a, _b, _c, _d, _e, _f;\n\n  return {\n    max: (_b = (_a = scaleOptions) === null || _a === void 0 ? void 0 : _a.max, _b !== null && _b !== void 0 ? _b : dataRange.max),\n    min: (_d = (_c = scaleOptions) === null || _c === void 0 ? void 0 : _c.min, _d !== null && _d !== void 0 ? _d : dataRange.min),\n    stepSize: (_f = (_e = scaleOptions) === null || _e === void 0 ? void 0 : _e.stepSize, _f !== null && _f !== void 0 ? _f : 'auto')\n  };\n}\nexport function calculateCoordinateScale(options) {\n  const {\n    dataRange,\n    scaleOption,\n    offsetSize,\n    minStepSize,\n    useSpectrumLegend\n  } = options;\n  const scale = makeScaleOption(dataRange, scaleOption);\n  const roughScale = getRoughScale(scale, offsetSize, minStepSize);\n  const normalizedScale = getNormalizedScale(roughScale, scale);\n  const overflowed = useSpectrumLegend ? null : isSeriesOverflowed(normalizedScale, scale, scaleOption);\n\n  if (overflowed) {\n    const {\n      stepSize,\n      limit\n    } = normalizedScale;\n    normalizedScale.limit = adjustLimitForOverflow(limit, stepSize, overflowed);\n  }\n\n  return normalizedScale;\n}\nexport function getStackScaleData(type) {\n  if (type === 'minusPercentStack') {\n    return {\n      limit: {\n        min: -100,\n        max: 0\n      },\n      stepSize: 25,\n      stepCount: 5\n    };\n  }\n\n  if (type === 'dualPercentStack') {\n    return {\n      limit: {\n        min: -100,\n        max: 100\n      },\n      stepSize: 25,\n      stepCount: 9\n    };\n  }\n\n  if (type === 'divergingPercentStack') {\n    return {\n      limit: {\n        min: -100,\n        max: 100\n      },\n      stepSize: 25,\n      stepCount: 9\n    };\n  }\n\n  return {\n    limit: {\n      min: 0,\n      max: 100\n    },\n    stepSize: 25,\n    stepCount: 5\n  };\n}\nexport function calculateScaleForCoordinateLineType(scale, options, categories) {\n  var _a, _b;\n\n  if (!categories) {\n    return scale;\n  }\n\n  const dateType = !!((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.date);\n  const values = categories.map(value => dateType ? Number(new Date(value)) : Number(value));\n  const {\n    limit,\n    stepSize\n  } = scale;\n  const min = Math.min(...values);\n  const max = Math.max(...values);\n  const newLimit = Object.assign({}, limit);\n\n  if (max - min) {\n    if (limit.min < min && limit.min + stepSize <= min) {\n      newLimit.min += stepSize;\n    }\n\n    if (limit.max > max && limit.max - stepSize >= max) {\n      newLimit.max -= stepSize;\n    }\n  }\n\n  const limitSize = Math.abs(newLimit.max - newLimit.min);\n  const newStepCount = getNormalizedStepCount(limitSize, stepSize);\n  return {\n    limit: newLimit,\n    stepCount: newStepCount,\n    stepSize\n  };\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/scale/coordinateScaleCalculator.js"],"names":["isNumber","SNAP_VALUES","DEFAULT_PIXELS_PER_STEP","adjustLimitForOverflow","min","max","stepSize","overflowed","isSeriesOverflowed","scaleData","scaleOption","_a","_b","scaleDataLimit","limit","hasMinOption","hasMaxOption","isOverflowedMin","isOverflowedMax","getDigits","num","logNumberDividedLN10","Math","log","abs","LN10","pow","floor","getSnappedNumber","snapNumber","i","t","length","guideValue","getNormalizedStep","placeNumber","simplifiedStepValue","getNormalizedLimit","minNumber","fixedStep","ceil","getNormalizedStepCount","limitSize","multiplier","hasStepSize","getNormalizedScale","scale","edge","stepCount","getRoughScale","offsetSize","minStepSize","valuePerPixel","pixelsPerStep","makeScaleOption","dataRange","scaleOptions","_c","_d","_e","_f","calculateCoordinateScale","options","useSpectrumLegend","roughScale","normalizedScale","getStackScaleData","type","calculateScaleForCoordinateLineType","categories","dateType","xAxis","date","values","map","value","Number","Date","newLimit","Object","assign","newStepCount"],"mappings":"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","sourcesContent":["import { isNumber } from \"../helpers/utils\";\nconst SNAP_VALUES = [1, 2, 5, 10];\nconst DEFAULT_PIXELS_PER_STEP = 88;\nfunction adjustLimitForOverflow({ min, max }, stepSize, overflowed) {\n    return {\n        min: overflowed.min ? min - stepSize : min,\n        max: overflowed.max ? max + stepSize : max,\n    };\n}\nfunction isSeriesOverflowed(scaleData, { min, max }, scaleOption) {\n    var _a, _b;\n    const scaleDataLimit = scaleData.limit;\n    const hasMinOption = isNumber((_a = scaleOption) === null || _a === void 0 ? void 0 : _a.min);\n    const hasMaxOption = isNumber((_b = scaleOption) === null || _b === void 0 ? void 0 : _b.max);\n    const isOverflowedMin = !hasMinOption && scaleDataLimit.min === min && scaleDataLimit.min !== 0;\n    const isOverflowedMax = !hasMaxOption && scaleDataLimit.max === max && scaleDataLimit.max !== 0;\n    if (!isOverflowedMin && !isOverflowedMax) {\n        return null;\n    }\n    return {\n        min: isOverflowedMin,\n        max: isOverflowedMax,\n    };\n}\nfunction getDigits(num) {\n    const logNumberDividedLN10 = num === 0 ? 1 : Math.log(Math.abs(num)) / Math.LN10;\n    return Math.pow(10, Math.floor(logNumberDividedLN10));\n}\nfunction getSnappedNumber(num) {\n    let snapNumber = 0;\n    for (let i = 0, t = SNAP_VALUES.length; i < t; i += 1) {\n        snapNumber = SNAP_VALUES[i];\n        const guideValue = (snapNumber + (SNAP_VALUES[i + 1] || snapNumber)) / 2;\n        if (num <= guideValue) {\n            break;\n        }\n    }\n    return snapNumber;\n}\nfunction getNormalizedStep(stepSize) {\n    const placeNumber = getDigits(stepSize);\n    const simplifiedStepValue = stepSize / placeNumber;\n    return getSnappedNumber(simplifiedStepValue) * placeNumber;\n}\n/**\n * Get normalized limit values\n * max = 155 and step = 10 ---> max = 160\n */\nfunction getNormalizedLimit(limit, stepSize) {\n    let { min, max } = limit;\n    const minNumber = Math.min(getDigits(max), getDigits(stepSize));\n    const placeNumber = minNumber > 1 ? 1 : 1 / minNumber;\n    const fixedStep = stepSize * placeNumber;\n    // ceil max value step digits\n    max = (Math.ceil((max * placeNumber) / fixedStep) * fixedStep) / placeNumber;\n    if (min > stepSize) {\n        // floor min value to multiples of step\n        min = (Math.floor((min * placeNumber) / fixedStep) * fixedStep) / placeNumber;\n    }\n    else if (min < 0) {\n        min = -(Math.ceil((Math.abs(min) * placeNumber) / fixedStep) * fixedStep) / placeNumber;\n    }\n    else {\n        min = 0;\n    }\n    return { min, max };\n}\nexport function getNormalizedStepCount(limitSize, stepSize) {\n    const multiplier = 1 / Math.min(getDigits(limitSize), getDigits(stepSize));\n    return Math.ceil((limitSize * multiplier) / (stepSize * multiplier));\n}\nfunction hasStepSize(stepSize) {\n    return isNumber(stepSize);\n}\nfunction getNormalizedScale(scaleData, scale) {\n    const stepSize = hasStepSize(scale.stepSize)\n        ? scaleData.stepSize\n        : getNormalizedStep(scaleData.stepSize);\n    const edge = getNormalizedLimit(scaleData.limit, stepSize);\n    const limitSize = Math.abs(edge.max - edge.min);\n    const stepCount = getNormalizedStepCount(limitSize, stepSize);\n    return {\n        limit: {\n            min: edge.min,\n            max: edge.max,\n        },\n        stepSize,\n        stepCount,\n    };\n}\nfunction getRoughScale(scale, offsetSize, minStepSize = 1) {\n    const { min, max } = scale;\n    const limitSize = Math.abs(max - min);\n    const valuePerPixel = limitSize / offsetSize;\n    let stepCount = Math.ceil(offsetSize / DEFAULT_PIXELS_PER_STEP);\n    const pixelsPerStep = offsetSize / stepCount;\n    let stepSize = valuePerPixel * pixelsPerStep;\n    if (hasStepSize(scale.stepSize)) {\n        stepSize = scale.stepSize;\n        stepCount = limitSize / stepSize;\n    }\n    else if (isNumber(minStepSize) && stepSize < minStepSize) {\n        stepSize = minStepSize;\n        stepCount = limitSize / stepSize;\n    }\n    return { limit: { min, max }, stepSize, stepCount };\n}\nexport function makeScaleOption(dataRange, scaleOptions) {\n    var _a, _b, _c, _d, _e, _f;\n    return {\n        max: (_b = (_a = scaleOptions) === null || _a === void 0 ? void 0 : _a.max, (_b !== null && _b !== void 0 ? _b : dataRange.max)),\n        min: (_d = (_c = scaleOptions) === null || _c === void 0 ? void 0 : _c.min, (_d !== null && _d !== void 0 ? _d : dataRange.min)),\n        stepSize: (_f = (_e = scaleOptions) === null || _e === void 0 ? void 0 : _e.stepSize, (_f !== null && _f !== void 0 ? _f : 'auto')),\n    };\n}\nexport function calculateCoordinateScale(options) {\n    const { dataRange, scaleOption, offsetSize, minStepSize, useSpectrumLegend } = options;\n    const scale = makeScaleOption(dataRange, scaleOption);\n    const roughScale = getRoughScale(scale, offsetSize, minStepSize);\n    const normalizedScale = getNormalizedScale(roughScale, scale);\n    const overflowed = useSpectrumLegend\n        ? null\n        : isSeriesOverflowed(normalizedScale, scale, scaleOption);\n    if (overflowed) {\n        const { stepSize, limit } = normalizedScale;\n        normalizedScale.limit = adjustLimitForOverflow(limit, stepSize, overflowed);\n    }\n    return normalizedScale;\n}\nexport function getStackScaleData(type) {\n    if (type === 'minusPercentStack') {\n        return { limit: { min: -100, max: 0 }, stepSize: 25, stepCount: 5 };\n    }\n    if (type === 'dualPercentStack') {\n        return { limit: { min: -100, max: 100 }, stepSize: 25, stepCount: 9 };\n    }\n    if (type === 'divergingPercentStack') {\n        return { limit: { min: -100, max: 100 }, stepSize: 25, stepCount: 9 };\n    }\n    return { limit: { min: 0, max: 100 }, stepSize: 25, stepCount: 5 };\n}\nexport function calculateScaleForCoordinateLineType(scale, options, categories) {\n    var _a, _b;\n    if (!categories) {\n        return scale;\n    }\n    const dateType = !!((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.date);\n    const values = categories.map((value) => (dateType ? Number(new Date(value)) : Number(value)));\n    const { limit, stepSize } = scale;\n    const min = Math.min(...values);\n    const max = Math.max(...values);\n    const newLimit = Object.assign({}, limit);\n    if (max - min) {\n        if (limit.min < min && limit.min + stepSize <= min) {\n            newLimit.min += stepSize;\n        }\n        if (limit.max > max && limit.max - stepSize >= max) {\n            newLimit.max -= stepSize;\n        }\n    }\n    const limitSize = Math.abs(newLimit.max - newLimit.min);\n    const newStepCount = getNormalizedStepCount(limitSize, stepSize);\n    return {\n        limit: newLimit,\n        stepCount: newStepCount,\n        stepSize,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}