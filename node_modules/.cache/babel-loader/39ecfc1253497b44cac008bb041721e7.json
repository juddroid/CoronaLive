{"ast":null,"code":"import { getAxisName, getSizeKey, isLabelAxisOnYAxis, getYAxisOption, getValueAxisNames, isSeriesUsingRadialAxes } from \"../helpers/axes\";\nimport { calculateCoordinateScale, calculateScaleForCoordinateLineType, getStackScaleData } from \"../scale/coordinateScaleCalculator\";\nimport { calculateDatetimeScale } from \"../scale/datetimeScaleCalculator\";\nimport { isCoordinateSeries } from \"../helpers/coordinate\";\nimport { hasPercentStackSeries } from \"./stackSeriesData\";\nimport { isExist } from \"../helpers/utils\";\nconst MIN_OFFSET_SIZE = 1;\n\nfunction getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName) {\n  var _a;\n\n  const {\n    dataRange,\n    layout,\n    series,\n    options\n  } = state;\n  const categories = state.categories;\n  const rawCategories = state.rawCategories;\n  const {\n    labelSizeKey\n  } = getSizeKey(labelAxisOnYAxis);\n  const dateTypeLabel = isExist((_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.date);\n  const labelOptions = {\n    dataRange: dataRange[labelAxisName],\n    offsetSize: Math.max(layout.plot[labelSizeKey], MIN_OFFSET_SIZE),\n    scaleOption: scaleOptions[labelAxisName],\n    rawCategoriesSize: rawCategories.length\n  };\n  let result;\n\n  if (dataRange[labelAxisName]) {\n    result = dateTypeLabel ? calculateDatetimeScale(labelOptions) : calculateCoordinateScale(labelOptions);\n  }\n\n  if (series.line) {\n    result = calculateScaleForCoordinateLineType(result, options, categories);\n  }\n\n  return result;\n}\n\nfunction getValueScaleData(state, labelAxisOnYAxis, scaleOptions, valueAxisName, isCoordinateTypeChart) {\n  const {\n    dataRange,\n    layout,\n    series,\n    stackSeries\n  } = state;\n  const {\n    valueSizeKey\n  } = getSizeKey(labelAxisOnYAxis);\n  let result;\n\n  if (hasPercentStackSeries(stackSeries)) {\n    Object.keys(series).forEach(seriesName => {\n      result = getStackScaleData(stackSeries[seriesName].scaleType);\n    });\n  } else if (isCoordinateTypeChart) {\n    const valueOptions = {\n      dataRange: dataRange[valueAxisName],\n      offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),\n      scaleOption: scaleOptions[valueAxisName]\n    };\n    result = calculateCoordinateScale(valueOptions);\n  } else {\n    result = calculateCoordinateScale({\n      dataRange: dataRange[valueAxisName],\n      offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),\n      scaleOption: scaleOptions[valueAxisName]\n    });\n  }\n\n  return result;\n}\n\nconst scale = {\n  name: 'scale',\n  state: () => ({\n    scale: {}\n  }),\n  action: {\n    setScale({\n      state,\n      initStoreState\n    }) {\n      var _a, _b, _c, _d, _e, _f;\n\n      const {\n        series,\n        options\n      } = state;\n      const labelAxisOnYAxis = isLabelAxisOnYAxis(series, options);\n      const {\n        labelAxisName,\n        valueAxisName\n      } = getAxisName(labelAxisOnYAxis, series);\n      const {\n        yAxis,\n        secondaryYAxis\n      } = getYAxisOption(options);\n      const scaleOptions = isSeriesUsingRadialAxes(series) ? {\n        [valueAxisName]: (_b = (_a = options) === null || _a === void 0 ? void 0 : _a[valueAxisName]) === null || _b === void 0 ? void 0 : _b.scale\n      } : {\n        xAxis: (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.xAxis) === null || _d === void 0 ? void 0 : _d.scale,\n        yAxis: (_e = yAxis) === null || _e === void 0 ? void 0 : _e.scale\n      };\n      const scaleData = {};\n\n      if (secondaryYAxis) {\n        scaleOptions.secondaryYAxis = (_f = secondaryYAxis) === null || _f === void 0 ? void 0 : _f.scale;\n      }\n\n      const isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);\n      getValueAxisNames(options, valueAxisName).forEach(axisName => {\n        scaleData[axisName] = getValueScaleData(state, labelAxisOnYAxis, scaleOptions, axisName, isCoordinateTypeChart);\n      });\n\n      if (isCoordinateTypeChart) {\n        scaleData[labelAxisName] = getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName);\n      }\n\n      state.scale = scaleData;\n    }\n\n  },\n  observe: {\n    updateScale() {\n      this.dispatch('setScale');\n    }\n\n  }\n};\nexport default scale;","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/store/scale.js"],"names":["getAxisName","getSizeKey","isLabelAxisOnYAxis","getYAxisOption","getValueAxisNames","isSeriesUsingRadialAxes","calculateCoordinateScale","calculateScaleForCoordinateLineType","getStackScaleData","calculateDatetimeScale","isCoordinateSeries","hasPercentStackSeries","isExist","MIN_OFFSET_SIZE","getLabelScaleData","state","labelAxisOnYAxis","scaleOptions","labelAxisName","_a","dataRange","layout","series","options","categories","rawCategories","labelSizeKey","dateTypeLabel","xAxis","date","labelOptions","offsetSize","Math","max","plot","scaleOption","rawCategoriesSize","length","result","line","getValueScaleData","valueAxisName","isCoordinateTypeChart","stackSeries","valueSizeKey","Object","keys","forEach","seriesName","scaleType","valueOptions","scale","name","action","setScale","initStoreState","_b","_c","_d","_e","_f","yAxis","secondaryYAxis","scaleData","axisName","observe","updateScale","dispatch"],"mappings":"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","sourcesContent":["import { getAxisName, getSizeKey, isLabelAxisOnYAxis, getYAxisOption, getValueAxisNames, isSeriesUsingRadialAxes, } from \"../helpers/axes\";\nimport { calculateCoordinateScale, calculateScaleForCoordinateLineType, getStackScaleData, } from \"../scale/coordinateScaleCalculator\";\nimport { calculateDatetimeScale } from \"../scale/datetimeScaleCalculator\";\nimport { isCoordinateSeries } from \"../helpers/coordinate\";\nimport { hasPercentStackSeries } from \"./stackSeriesData\";\nimport { isExist } from \"../helpers/utils\";\nconst MIN_OFFSET_SIZE = 1;\nfunction getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName) {\n    var _a;\n    const { dataRange, layout, series, options } = state;\n    const categories = state.categories;\n    const rawCategories = state.rawCategories;\n    const { labelSizeKey } = getSizeKey(labelAxisOnYAxis);\n    const dateTypeLabel = isExist((_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.date);\n    const labelOptions = {\n        dataRange: dataRange[labelAxisName],\n        offsetSize: Math.max(layout.plot[labelSizeKey], MIN_OFFSET_SIZE),\n        scaleOption: scaleOptions[labelAxisName],\n        rawCategoriesSize: rawCategories.length,\n    };\n    let result;\n    if (dataRange[labelAxisName]) {\n        result = dateTypeLabel\n            ? calculateDatetimeScale(labelOptions)\n            : calculateCoordinateScale(labelOptions);\n    }\n    if (series.line) {\n        result = calculateScaleForCoordinateLineType(result, options, categories);\n    }\n    return result;\n}\nfunction getValueScaleData(state, labelAxisOnYAxis, scaleOptions, valueAxisName, isCoordinateTypeChart) {\n    const { dataRange, layout, series, stackSeries } = state;\n    const { valueSizeKey } = getSizeKey(labelAxisOnYAxis);\n    let result;\n    if (hasPercentStackSeries(stackSeries)) {\n        Object.keys(series).forEach((seriesName) => {\n            result = getStackScaleData(stackSeries[seriesName].scaleType);\n        });\n    }\n    else if (isCoordinateTypeChart) {\n        const valueOptions = {\n            dataRange: dataRange[valueAxisName],\n            offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),\n            scaleOption: scaleOptions[valueAxisName],\n        };\n        result = calculateCoordinateScale(valueOptions);\n    }\n    else {\n        result = calculateCoordinateScale({\n            dataRange: dataRange[valueAxisName],\n            offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),\n            scaleOption: scaleOptions[valueAxisName],\n        });\n    }\n    return result;\n}\nconst scale = {\n    name: 'scale',\n    state: () => ({\n        scale: {},\n    }),\n    action: {\n        setScale({ state, initStoreState }) {\n            var _a, _b, _c, _d, _e, _f;\n            const { series, options } = state;\n            const labelAxisOnYAxis = isLabelAxisOnYAxis(series, options);\n            const { labelAxisName, valueAxisName } = getAxisName(labelAxisOnYAxis, series);\n            const { yAxis, secondaryYAxis } = getYAxisOption(options);\n            const scaleOptions = isSeriesUsingRadialAxes(series)\n                ? { [valueAxisName]: (_b = (_a = options) === null || _a === void 0 ? void 0 : _a[valueAxisName]) === null || _b === void 0 ? void 0 : _b.scale }\n                : {\n                    xAxis: (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.xAxis) === null || _d === void 0 ? void 0 : _d.scale,\n                    yAxis: (_e = yAxis) === null || _e === void 0 ? void 0 : _e.scale,\n                };\n            const scaleData = {};\n            if (secondaryYAxis) {\n                scaleOptions.secondaryYAxis = (_f = secondaryYAxis) === null || _f === void 0 ? void 0 : _f.scale;\n            }\n            const isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);\n            getValueAxisNames(options, valueAxisName).forEach((axisName) => {\n                scaleData[axisName] = getValueScaleData(state, labelAxisOnYAxis, scaleOptions, axisName, isCoordinateTypeChart);\n            });\n            if (isCoordinateTypeChart) {\n                scaleData[labelAxisName] = getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName);\n            }\n            state.scale = scaleData;\n        },\n    },\n    observe: {\n        updateScale() {\n            this.dispatch('setScale');\n        },\n    },\n};\nexport default scale;\n"]},"metadata":{},"sourceType":"module"}