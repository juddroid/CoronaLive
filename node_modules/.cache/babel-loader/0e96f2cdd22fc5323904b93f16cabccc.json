{"ast":null,"code":"import { getFirstValidValue, isNull, includes } from \"../helpers/utils\";\nimport { extend } from \"./store\";\nimport { getAxisName, isLabelAxisOnYAxis, getValueAxisNames, getYAxisOption, hasSecondaryYAxis } from \"../helpers/axes\";\nimport { getCoordinateYValue, isCoordinateSeries } from \"../helpers/coordinate\";\nimport { isRangeValue } from \"../helpers/range\";\nexport function getLimitSafely(baseValues) {\n  const limit = {\n    min: Math.min(...baseValues),\n    max: Math.max(...baseValues)\n  };\n\n  if (baseValues.length === 1) {\n    const [firstValue] = baseValues;\n\n    if (firstValue > 0) {\n      limit.min = 0;\n    } else if (firstValue === 0) {\n      limit.max = 10;\n    } else {\n      limit.max = 0;\n    }\n  } else if (limit.min === 0 && limit.max === 0) {\n    limit.max = 10;\n  } else if (limit.min === limit.max) {\n    limit.min -= limit.min / 10;\n    limit.max += limit.max / 10;\n  }\n\n  return limit;\n}\n\nfunction initDataRange(accDataRangeValue, curDataRangeValue, axisName) {\n  var _a, _b, _c, _d;\n\n  const defaultDataRange = {\n    min: Number.MAX_SAFE_INTEGER,\n    max: Number.MIN_SAFE_INTEGER\n  };\n  return {\n    min: Math.min(curDataRangeValue[axisName].min, (_b = (_a = accDataRangeValue[axisName]) === null || _a === void 0 ? void 0 : _a.min, _b !== null && _b !== void 0 ? _b : defaultDataRange.min)),\n    max: Math.max(curDataRangeValue[axisName].max, (_d = (_c = accDataRangeValue[axisName]) === null || _c === void 0 ? void 0 : _c.max, _d !== null && _d !== void 0 ? _d : defaultDataRange.max))\n  };\n}\n\nfunction getTotalDataRange(seriesDataRange) {\n  return Object.values(seriesDataRange).reduce((acc, cur) => {\n    if (cur.xAxis) {\n      acc.xAxis = initDataRange(acc, cur, 'xAxis');\n    }\n\n    if (cur.yAxis) {\n      acc.yAxis = initDataRange(acc, cur, 'yAxis');\n    }\n\n    if (cur.secondaryYAxis) {\n      acc.secondaryYAxis = initDataRange(acc, cur, 'secondaryYAxis');\n    }\n\n    if (cur.circularAxis) {\n      acc.circularAxis = initDataRange(acc, cur, 'circularAxis');\n    }\n\n    if (cur.verticalAxis) {\n      acc.verticalAxis = initDataRange(acc, cur, 'verticalAxis');\n    }\n\n    return acc;\n  }, {});\n}\n\nfunction setSeriesDataRange(options, seriesName, values, valueAxisName, seriesDataRange) {\n  var _a;\n\n  const {\n    secondaryYAxis\n  } = getYAxisOption(options);\n  const axisNames = hasSecondaryYAxis(options) && ((_a = secondaryYAxis) === null || _a === void 0 ? void 0 : _a.chartType) ? [secondaryYAxis.chartType === seriesName ? 'secondaryYAxis' : 'yAxis'] : getValueAxisNames(options, valueAxisName);\n  axisNames.forEach(axisName => {\n    seriesDataRange[seriesName][axisName] = getLimitSafely([...new Set(values)]);\n  });\n  return seriesDataRange;\n}\n\nfunction getBoxPlotValues(series, seriesName) {\n  return series[seriesName].data.flatMap(({\n    data,\n    outliers = []\n  }) => [...(data !== null && data !== void 0 ? data : []).flatMap(datum => datum), ...(outliers !== null && outliers !== void 0 ? outliers : []).flatMap(datum => datum)]);\n}\n\nfunction getBulletValues(series, seriesName) {\n  return series[seriesName].data.flatMap(({\n    data,\n    markers,\n    ranges\n  }) => [data, ...(markers !== null && markers !== void 0 ? markers : []).flatMap(datum => datum), ...(ranges !== null && ranges !== void 0 ? ranges : []).flatMap(range => range)]);\n}\n\nfunction getCoordinateDataValues(values, categories, hasDateValue) {\n  const yAxisValues = values.filter(value => !isNull(value)).map(value => getCoordinateYValue(value));\n  const xAxisValues = categories.map(value => hasDateValue ? Number(new Date(value)) : Number(value));\n  return {\n    xAxisValues,\n    yAxisValues\n  };\n}\n\nconst dataRange = {\n  name: 'dataRange',\n  state: () => ({\n    dataRange: {}\n  }),\n  action: {\n    setDataRange({\n      state,\n      initStoreState\n    }) {\n      const {\n        series,\n        disabledSeries,\n        stackSeries,\n        categories,\n        options\n      } = state;\n      const seriesDataRange = {};\n      const labelAxisOnYAxis = isLabelAxisOnYAxis(series, options);\n      const {\n        labelAxisName,\n        valueAxisName\n      } = getAxisName(labelAxisOnYAxis, series);\n      Object.keys(series).forEach(seriesName => {\n        var _a, _b;\n\n        seriesDataRange[seriesName] = {};\n        let values = series[seriesName].data.flatMap(({\n          data,\n          name\n        }) => disabledSeries.includes(name) ? [] : data);\n        const firstExistValue = getFirstValidValue(values);\n\n        if (isCoordinateSeries(initStoreState.series)) {\n          const hasDateValue = !!((_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.date);\n          const {\n            yAxisValues,\n            xAxisValues\n          } = getCoordinateDataValues(values, categories, hasDateValue);\n          values = yAxisValues;\n          seriesDataRange[seriesName][labelAxisName] = getLimitSafely([...xAxisValues]);\n        } else if (!series[seriesName].data.length) {\n          values = [];\n        } else if (isRangeValue(firstExistValue)) {\n          values = values.reduce((arr, value) => {\n            if (isNull(value)) {\n              return arr;\n            }\n\n            return Array.isArray(value) ? [...arr, ...value] : [...value];\n          }, []);\n        } else if (stackSeries && ((_b = stackSeries[seriesName]) === null || _b === void 0 ? void 0 : _b.stack)) {\n          values = stackSeries[seriesName].dataRangeValues;\n        } else if (includes(['bar', 'column', 'radar'], seriesName)) {\n          values.push(0);\n        } else if (seriesName === 'boxPlot') {\n          values = getBoxPlotValues(series, seriesName);\n        } else if (seriesName === 'bullet') {\n          values = getBulletValues(series, seriesName);\n        }\n\n        setSeriesDataRange(options, seriesName, values, valueAxisName, seriesDataRange);\n      });\n      const newDataRange = getTotalDataRange(seriesDataRange);\n      extend(state.dataRange, newDataRange);\n    }\n\n  },\n  observe: {\n    updateDataRange() {\n      this.dispatch('setDataRange');\n    }\n\n  }\n};\nexport default dataRange;","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/store/dataRange.js"],"names":["getFirstValidValue","isNull","includes","extend","getAxisName","isLabelAxisOnYAxis","getValueAxisNames","getYAxisOption","hasSecondaryYAxis","getCoordinateYValue","isCoordinateSeries","isRangeValue","getLimitSafely","baseValues","limit","min","Math","max","length","firstValue","initDataRange","accDataRangeValue","curDataRangeValue","axisName","_a","_b","_c","_d","defaultDataRange","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getTotalDataRange","seriesDataRange","Object","values","reduce","acc","cur","xAxis","yAxis","secondaryYAxis","circularAxis","verticalAxis","setSeriesDataRange","options","seriesName","valueAxisName","axisNames","chartType","forEach","Set","getBoxPlotValues","series","data","flatMap","outliers","datum","getBulletValues","markers","ranges","range","getCoordinateDataValues","categories","hasDateValue","yAxisValues","filter","value","map","xAxisValues","Date","dataRange","name","state","action","setDataRange","initStoreState","disabledSeries","stackSeries","labelAxisOnYAxis","labelAxisName","keys","firstExistValue","date","arr","Array","isArray","stack","dataRangeValues","push","newDataRange","observe","updateDataRange","dispatch"],"mappings":"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","sourcesContent":["import { getFirstValidValue, isNull, includes } from \"../helpers/utils\";\nimport { extend } from \"./store\";\nimport { getAxisName, isLabelAxisOnYAxis, getValueAxisNames, getYAxisOption, hasSecondaryYAxis, } from \"../helpers/axes\";\nimport { getCoordinateYValue, isCoordinateSeries } from \"../helpers/coordinate\";\nimport { isRangeValue } from \"../helpers/range\";\nexport function getLimitSafely(baseValues) {\n    const limit = {\n        min: Math.min(...baseValues),\n        max: Math.max(...baseValues),\n    };\n    if (baseValues.length === 1) {\n        const [firstValue] = baseValues;\n        if (firstValue > 0) {\n            limit.min = 0;\n        }\n        else if (firstValue === 0) {\n            limit.max = 10;\n        }\n        else {\n            limit.max = 0;\n        }\n    }\n    else if (limit.min === 0 && limit.max === 0) {\n        limit.max = 10;\n    }\n    else if (limit.min === limit.max) {\n        limit.min -= limit.min / 10;\n        limit.max += limit.max / 10;\n    }\n    return limit;\n}\nfunction initDataRange(accDataRangeValue, curDataRangeValue, axisName) {\n    var _a, _b, _c, _d;\n    const defaultDataRange = {\n        min: Number.MAX_SAFE_INTEGER,\n        max: Number.MIN_SAFE_INTEGER,\n    };\n    return {\n        min: Math.min(curDataRangeValue[axisName].min, (_b = (_a = accDataRangeValue[axisName]) === null || _a === void 0 ? void 0 : _a.min, (_b !== null && _b !== void 0 ? _b : defaultDataRange.min))),\n        max: Math.max(curDataRangeValue[axisName].max, (_d = (_c = accDataRangeValue[axisName]) === null || _c === void 0 ? void 0 : _c.max, (_d !== null && _d !== void 0 ? _d : defaultDataRange.max))),\n    };\n}\nfunction getTotalDataRange(seriesDataRange) {\n    return Object.values(seriesDataRange).reduce((acc, cur) => {\n        if (cur.xAxis) {\n            acc.xAxis = initDataRange(acc, cur, 'xAxis');\n        }\n        if (cur.yAxis) {\n            acc.yAxis = initDataRange(acc, cur, 'yAxis');\n        }\n        if (cur.secondaryYAxis) {\n            acc.secondaryYAxis = initDataRange(acc, cur, 'secondaryYAxis');\n        }\n        if (cur.circularAxis) {\n            acc.circularAxis = initDataRange(acc, cur, 'circularAxis');\n        }\n        if (cur.verticalAxis) {\n            acc.verticalAxis = initDataRange(acc, cur, 'verticalAxis');\n        }\n        return acc;\n    }, {});\n}\nfunction setSeriesDataRange(options, seriesName, values, valueAxisName, seriesDataRange) {\n    var _a;\n    const { secondaryYAxis } = getYAxisOption(options);\n    const axisNames = hasSecondaryYAxis(options) && ((_a = secondaryYAxis) === null || _a === void 0 ? void 0 : _a.chartType)\n        ? [secondaryYAxis.chartType === seriesName ? 'secondaryYAxis' : 'yAxis']\n        : getValueAxisNames(options, valueAxisName);\n    axisNames.forEach((axisName) => {\n        seriesDataRange[seriesName][axisName] = getLimitSafely([...new Set(values)]);\n    });\n    return seriesDataRange;\n}\nfunction getBoxPlotValues(series, seriesName) {\n    return series[seriesName].data.flatMap(({ data, outliers = [] }) => [\n        ...((data !== null && data !== void 0 ? data : [])).flatMap((datum) => datum),\n        ...((outliers !== null && outliers !== void 0 ? outliers : [])).flatMap((datum) => datum),\n    ]);\n}\nfunction getBulletValues(series, seriesName) {\n    return series[seriesName].data.flatMap(({ data, markers, ranges }) => [\n        data,\n        ...((markers !== null && markers !== void 0 ? markers : [])).flatMap((datum) => datum),\n        ...((ranges !== null && ranges !== void 0 ? ranges : [])).flatMap((range) => range),\n    ]);\n}\nfunction getCoordinateDataValues(values, categories, hasDateValue) {\n    const yAxisValues = values\n        .filter((value) => !isNull(value))\n        .map((value) => getCoordinateYValue(value));\n    const xAxisValues = categories.map((value) => hasDateValue ? Number(new Date(value)) : Number(value));\n    return { xAxisValues, yAxisValues };\n}\nconst dataRange = {\n    name: 'dataRange',\n    state: () => ({\n        dataRange: {},\n    }),\n    action: {\n        setDataRange({ state, initStoreState }) {\n            const { series, disabledSeries, stackSeries, categories, options } = state;\n            const seriesDataRange = {};\n            const labelAxisOnYAxis = isLabelAxisOnYAxis(series, options);\n            const { labelAxisName, valueAxisName } = getAxisName(labelAxisOnYAxis, series);\n            Object.keys(series).forEach((seriesName) => {\n                var _a, _b;\n                seriesDataRange[seriesName] = {};\n                let values = series[seriesName].data.flatMap(({ data, name }) => disabledSeries.includes(name) ? [] : data);\n                const firstExistValue = getFirstValidValue(values);\n                if (isCoordinateSeries(initStoreState.series)) {\n                    const hasDateValue = !!((_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.date);\n                    const { yAxisValues, xAxisValues } = getCoordinateDataValues(values, categories, hasDateValue);\n                    values = yAxisValues;\n                    seriesDataRange[seriesName][labelAxisName] = getLimitSafely([...xAxisValues]);\n                }\n                else if (!series[seriesName].data.length) {\n                    values = [];\n                }\n                else if (isRangeValue(firstExistValue)) {\n                    values = values.reduce((arr, value) => {\n                        if (isNull(value)) {\n                            return arr;\n                        }\n                        return Array.isArray(value) ? [...arr, ...value] : [...value];\n                    }, []);\n                }\n                else if (stackSeries && ((_b = stackSeries[seriesName]) === null || _b === void 0 ? void 0 : _b.stack)) {\n                    values = stackSeries[seriesName].dataRangeValues;\n                }\n                else if (includes(['bar', 'column', 'radar'], seriesName)) {\n                    values.push(0);\n                }\n                else if (seriesName === 'boxPlot') {\n                    values = getBoxPlotValues(series, seriesName);\n                }\n                else if (seriesName === 'bullet') {\n                    values = getBulletValues(series, seriesName);\n                }\n                setSeriesDataRange(options, seriesName, values, valueAxisName, seriesDataRange);\n            });\n            const newDataRange = getTotalDataRange(seriesDataRange);\n            extend(state.dataRange, newDataRange);\n        },\n    },\n    observe: {\n        updateDataRange() {\n            this.dispatch('setDataRange');\n        },\n    },\n};\nexport default dataRange;\n"]},"metadata":{},"sourceType":"module"}