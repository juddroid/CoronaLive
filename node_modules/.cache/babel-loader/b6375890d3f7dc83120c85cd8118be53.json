{"ast":null,"code":"import Component from \"./component\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getRadialPosition, calculateDegreeToRadian, DEGREE_360 } from \"../helpers/sector\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getLimitOnAxis } from \"../helpers/axes\";\nimport { radarDefault } from \"../helpers/theme\";\nimport { isNumber, isNull } from \"../helpers/utils\";\nimport { message } from \"../message\";\nimport { makeLabelsFromLimit } from \"../helpers/calculator\";\nconst NONE_AREA_OPACITY = 0;\nconst seriesOpacity = {\n  INACTIVE: 0.2,\n  ACTIVE: 1\n};\nexport default class RadarSeries extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      area: [],\n      line: [],\n      dot: []\n    };\n    this.activatedResponders = [];\n\n    this.onMouseoutComponent = () => {\n      this.eventBus.emit('seriesPointHovered', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('renderHoveredSeries', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.selectSeries = ({\n      index,\n      seriesIndex,\n      state\n    }) => {\n      if (!isNumber(index) || !isNumber(seriesIndex)) {\n        return;\n      }\n\n      const {\n        name\n      } = state.series.radar.data[seriesIndex];\n      const model = this.responders.filter(({\n        name: dataName\n      }) => dataName === name)[index];\n\n      if (!model) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models: this.getRespondersWithTheme([model], 'select'),\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.showTooltip = ({\n      index,\n      seriesIndex,\n      state\n    }) => {\n      if (!isNumber(index) || !isNumber(seriesIndex)) {\n        return;\n      }\n\n      const {\n        name\n      } = state.series.radar.data[seriesIndex];\n      const models = [this.responders.filter(({\n        name: dataName\n      }) => dataName === name)[index]];\n\n      if (!models.length) {\n        return;\n      }\n\n      this.eventBus.emit('renderHoveredSeries', {\n        models: this.getRespondersWithTheme(models, 'hover'),\n        name: this.name\n      });\n      this.activatedResponders = models;\n      this.eventBus.emit('seriesPointHovered', {\n        models: this.activatedResponders,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  initialize() {\n    this.type = 'series';\n    this.name = 'radar';\n    this.eventBus.on('selectSeries', this.selectSeries);\n    this.eventBus.on('showTooltip', this.showTooltip);\n    this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n  }\n\n  render(state) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n\n    const {\n      layout,\n      radialAxes,\n      series,\n      legend,\n      options,\n      theme,\n      scale\n    } = state;\n\n    if (!series.radar) {\n      throw new Error(message.noDataError(this.name));\n    }\n\n    this.theme = theme.series.radar;\n    this.rect = layout.plot;\n    this.activeSeriesMap = getActiveSeriesMap(legend);\n    this.selectable = this.getSelectableOption(options);\n    const categories = state.categories;\n    const {\n      axisSize,\n      centerX,\n      centerY\n    } = radialAxes.verticalAxis;\n    const {\n      limit,\n      stepSize\n    } = scale.verticalAxis;\n    const labels = makeLabelsFromLimit(limit, stepSize);\n    const {\n      min,\n      max\n    } = getLimitOnAxis(labels);\n    const renderOptions = {\n      categories,\n      degree: DEGREE_360 / categories.length,\n      centerX,\n      centerY,\n      showArea: (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.showArea, _c !== null && _c !== void 0 ? _c : false),\n      ratio: axisSize / (max - min)\n    };\n    const radarData = (_d = series.radar) === null || _d === void 0 ? void 0 : _d.data;\n    const radarPointsData = this.makeRadarPointsData(radarData, renderOptions);\n    const circleModel = this.renderDotModels(radarPointsData);\n    this.models.area = ((_f = (_e = options) === null || _e === void 0 ? void 0 : _e.series) === null || _f === void 0 ? void 0 : _f.showArea) ? this.renderAreaModels(radarPointsData) : [];\n    this.models.line = this.renderLineModels(radarPointsData);\n    this.models.dot = ((_h = (_g = options) === null || _g === void 0 ? void 0 : _g.series) === null || _h === void 0 ? void 0 : _h.showDot) ? circleModel : [];\n\n    if (!this.drawModels) {\n      this.drawModels = {\n        area: this.initDrawModels('area', centerX, centerY),\n        line: this.initDrawModels('line', centerX, centerY),\n        dot: this.models.dot.map(m => Object.assign(Object.assign({}, m), {\n          x: centerX,\n          y: centerY\n        }))\n      };\n    }\n\n    const tooltipDataArr = this.makeTooltipModel(circleModel, categories);\n    this.responders = circleModel.map((m, index) => Object.assign(Object.assign({}, m), {\n      data: tooltipDataArr[index],\n      color: getRGBA(m.color, 1)\n    }));\n  }\n\n  initDrawModels(modelName, centerX, centerY) {\n    return this.models[modelName].map(m => {\n      var _a;\n\n      return Object.assign(Object.assign({}, m), {\n        distances: (_a = m.distances) === null || _a === void 0 ? void 0 : _a.map(() => 0),\n        points: m.points.map(() => ({\n          x: centerX,\n          y: centerY\n        }))\n      });\n    });\n  }\n\n  makeTooltipModel(circleModel, categories) {\n    return circleModel.map(({\n      name,\n      color,\n      value,\n      index\n    }) => ({\n      label: name,\n      color,\n      value,\n      category: categories[index]\n    }));\n  }\n\n  getRespondersWithTheme(responders, type) {\n    const {\n      radius,\n      borderWidth,\n      borderColor,\n      color\n    } = this.theme[type].dot;\n    return responders.map(responder => {\n      const modelColor = color !== null && color !== void 0 ? color : responder.color;\n      return Object.assign(Object.assign({}, responder), {\n        radius,\n        color: modelColor,\n        style: [{\n          lineWidth: borderWidth,\n          strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)\n        }]\n      });\n    });\n  }\n\n  onClick({\n    responders\n  }) {\n    if (this.selectable) {\n      this.eventBus.emit('renderSelectedSeries', {\n        models: this.getRespondersWithTheme(responders, 'select'),\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    }\n  }\n\n  onMousemove({\n    responders\n  }) {\n    this.eventBus.emit('renderHoveredSeries', {\n      models: this.getRespondersWithTheme(responders, 'hover'),\n      name: this.name\n    });\n    this.activatedResponders = responders;\n    this.eventBus.emit('seriesPointHovered', {\n      models: this.activatedResponders,\n      name: this.name\n    });\n    this.eventBus.emit('needDraw');\n  }\n\n  makeRadarPointsData(seriesData, renderOptions) {\n    const {\n      centerX,\n      centerY,\n      degree,\n      ratio,\n      showArea\n    } = renderOptions;\n    return seriesData.map(({\n      data,\n      color: seriesColor,\n      name\n    }) => {\n      const radarPoints = data.reduce((acc, value, index) => {\n        if (isNull(value)) {\n          return {\n            distances: [...acc.distances, 0],\n            linePoints: [...acc.linePoints, null],\n            areaPoints: [...acc.areaPoints, {\n              x: centerX,\n              y: centerY\n            }]\n          };\n        }\n\n        const distance = value * ratio;\n        const point = getRadialPosition(centerX, centerY, distance, calculateDegreeToRadian(degree * index));\n        return {\n          distances: [...acc.distances, distance],\n          linePoints: [...acc.linePoints, point],\n          areaPoints: [...acc.areaPoints, point]\n        };\n      }, {\n        linePoints: [],\n        distances: [],\n        areaPoints: []\n      });\n\n      if (!isNull(data[0]) && !isNull(data[data.length - 1])) {\n        radarPoints.linePoints.push(radarPoints.linePoints[0]);\n        radarPoints.areaPoints.push(radarPoints.areaPoints[0]);\n      }\n\n      return Object.assign(Object.assign({\n        name,\n        seriesColor,\n        data\n      }, radarPoints), this.getSeriesColor(showArea, seriesColor, name));\n    });\n  }\n\n  renderAreaModels(radarPointsData) {\n    return radarPointsData.map(({\n      distances,\n      areaPoints,\n      name,\n      fillColor,\n      seriesColor\n    }) => ({\n      type: 'areaPoints',\n      name,\n      distances,\n      points: areaPoints,\n      fillColor,\n      color: getRGBA(seriesColor, 0),\n      lineWidth: 0\n    }));\n  }\n\n  renderLineModels(radarPointsData) {\n    const {\n      lineWidth,\n      dashSegments\n    } = this.theme;\n    return radarPointsData.map(({\n      distances,\n      linePoints,\n      name,\n      lineColor\n    }) => ({\n      type: 'linePoints',\n      lineWidth: lineWidth !== null && lineWidth !== void 0 ? lineWidth : radarDefault.LINE_WIDTH,\n      name,\n      distances,\n      points: linePoints,\n      color: lineColor,\n      dashSegments\n    }));\n  }\n\n  renderDotModels(radarPointsData) {\n    const {\n      radius,\n      color: dotColor\n    } = this.theme.dot;\n    const result = [];\n    radarPointsData.forEach(({\n      linePoints,\n      lineColor,\n      name,\n      data\n    }, seriesIndex) => linePoints.slice(0, linePoints.length - 1).forEach((point, index) => {\n      var _a;\n\n      if (!isNull(point)) {\n        result.push(Object.assign(Object.assign({\n          type: 'circle'\n        }, point), {\n          radius,\n          color: dotColor !== null && dotColor !== void 0 ? dotColor : lineColor,\n          style: [{\n            strokeStyle: 'rgba(0, 0, 0, 0)'\n          }],\n          name,\n          seriesIndex,\n          index,\n          value: (_a = data) === null || _a === void 0 ? void 0 : _a[index]\n        }));\n      }\n    }));\n    return result;\n  }\n\n  getSeriesColor(showArea, seriesColor, name) {\n    const active = this.activeSeriesMap[name];\n    const {\n      select,\n      areaOpacity\n    } = this.theme;\n    const selected = Object.values(this.activeSeriesMap).some(elem => !elem);\n    const color = getRGBA(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);\n    let fillOpacity = NONE_AREA_OPACITY;\n\n    if (showArea) {\n      const selectedAreaOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;\n      fillOpacity = selected ? selectedAreaOpacity : areaOpacity;\n    }\n\n    return {\n      lineColor: color,\n      fillColor: getRGBA(color, fillOpacity)\n    };\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/radarSeries.js"],"names":["Component","getActiveSeriesMap","getRadialPosition","calculateDegreeToRadian","DEGREE_360","getRGBA","getLimitOnAxis","radarDefault","isNumber","isNull","message","makeLabelsFromLimit","NONE_AREA_OPACITY","seriesOpacity","INACTIVE","ACTIVE","RadarSeries","constructor","arguments","models","area","line","dot","activatedResponders","onMouseoutComponent","eventBus","emit","name","selectSeries","index","seriesIndex","state","series","radar","data","model","responders","filter","dataName","Error","SELECT_SERIES_API_INDEX_ERROR","getRespondersWithTheme","showTooltip","length","initialize","type","on","render","_a","_b","_c","_d","_e","_f","_g","_h","layout","radialAxes","legend","options","theme","scale","noDataError","rect","plot","activeSeriesMap","selectable","getSelectableOption","categories","axisSize","centerX","centerY","verticalAxis","limit","stepSize","labels","min","max","renderOptions","degree","showArea","ratio","radarData","radarPointsData","makeRadarPointsData","circleModel","renderDotModels","renderAreaModels","renderLineModels","showDot","drawModels","initDrawModels","map","m","Object","assign","x","y","tooltipDataArr","makeTooltipModel","color","modelName","distances","points","value","label","category","radius","borderWidth","borderColor","responder","modelColor","style","lineWidth","strokeStyle","onClick","onMousemove","seriesData","seriesColor","radarPoints","reduce","acc","linePoints","areaPoints","distance","point","push","getSeriesColor","fillColor","dashSegments","lineColor","LINE_WIDTH","dotColor","result","forEach","slice","active","select","areaOpacity","selected","values","some","elem","fillOpacity","selectedAreaOpacity","restSeries"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getRadialPosition, calculateDegreeToRadian, DEGREE_360 } from \"../helpers/sector\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getLimitOnAxis } from \"../helpers/axes\";\nimport { radarDefault } from \"../helpers/theme\";\nimport { isNumber, isNull } from \"../helpers/utils\";\nimport { message } from \"../message\";\nimport { makeLabelsFromLimit } from \"../helpers/calculator\";\nconst NONE_AREA_OPACITY = 0;\nconst seriesOpacity = {\n    INACTIVE: 0.2,\n    ACTIVE: 1,\n};\nexport default class RadarSeries extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { area: [], line: [], dot: [] };\n        this.activatedResponders = [];\n        this.onMouseoutComponent = () => {\n            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });\n            this.eventBus.emit('renderHoveredSeries', {\n                models: [],\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.selectSeries = ({ index, seriesIndex, state }) => {\n            if (!isNumber(index) || !isNumber(seriesIndex)) {\n                return;\n            }\n            const { name } = state.series.radar.data[seriesIndex];\n            const model = this.responders.filter(({ name: dataName }) => dataName === name)[index];\n            if (!model) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models: this.getRespondersWithTheme([model], 'select'),\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.showTooltip = ({ index, seriesIndex, state }) => {\n            if (!isNumber(index) || !isNumber(seriesIndex)) {\n                return;\n            }\n            const { name } = state.series.radar.data[seriesIndex];\n            const models = [this.responders.filter(({ name: dataName }) => dataName === name)[index]];\n            if (!models.length) {\n                return;\n            }\n            this.eventBus.emit('renderHoveredSeries', {\n                models: this.getRespondersWithTheme(models, 'hover'),\n                name: this.name,\n            });\n            this.activatedResponders = models;\n            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n    }\n    initialize() {\n        this.type = 'series';\n        this.name = 'radar';\n        this.eventBus.on('selectSeries', this.selectSeries);\n        this.eventBus.on('showTooltip', this.showTooltip);\n        this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n    }\n    render(state) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const { layout, radialAxes, series, legend, options, theme, scale } = state;\n        if (!series.radar) {\n            throw new Error(message.noDataError(this.name));\n        }\n        this.theme = theme.series.radar;\n        this.rect = layout.plot;\n        this.activeSeriesMap = getActiveSeriesMap(legend);\n        this.selectable = this.getSelectableOption(options);\n        const categories = state.categories;\n        const { axisSize, centerX, centerY } = radialAxes.verticalAxis;\n        const { limit, stepSize } = scale.verticalAxis;\n        const labels = makeLabelsFromLimit(limit, stepSize);\n        const { min, max } = getLimitOnAxis(labels);\n        const renderOptions = {\n            categories,\n            degree: DEGREE_360 / categories.length,\n            centerX,\n            centerY,\n            showArea: (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.showArea, (_c !== null && _c !== void 0 ? _c : false)),\n            ratio: axisSize / (max - min),\n        };\n        const radarData = (_d = series.radar) === null || _d === void 0 ? void 0 : _d.data;\n        const radarPointsData = this.makeRadarPointsData(radarData, renderOptions);\n        const circleModel = this.renderDotModels(radarPointsData);\n        this.models.area = ((_f = (_e = options) === null || _e === void 0 ? void 0 : _e.series) === null || _f === void 0 ? void 0 : _f.showArea) ? this.renderAreaModels(radarPointsData) : [];\n        this.models.line = this.renderLineModels(radarPointsData);\n        this.models.dot = ((_h = (_g = options) === null || _g === void 0 ? void 0 : _g.series) === null || _h === void 0 ? void 0 : _h.showDot) ? circleModel : [];\n        if (!this.drawModels) {\n            this.drawModels = {\n                area: this.initDrawModels('area', centerX, centerY),\n                line: this.initDrawModels('line', centerX, centerY),\n                dot: this.models.dot.map((m) => (Object.assign(Object.assign({}, m), { x: centerX, y: centerY }))),\n            };\n        }\n        const tooltipDataArr = this.makeTooltipModel(circleModel, categories);\n        this.responders = circleModel.map((m, index) => (Object.assign(Object.assign({}, m), { data: tooltipDataArr[index], color: getRGBA(m.color, 1) })));\n    }\n    initDrawModels(modelName, centerX, centerY) {\n        return this.models[modelName].map((m) => {\n            var _a;\n            return (Object.assign(Object.assign({}, m), { distances: (_a = m.distances) === null || _a === void 0 ? void 0 : _a.map(() => 0), points: m.points.map(() => ({ x: centerX, y: centerY })) }));\n        });\n    }\n    makeTooltipModel(circleModel, categories) {\n        return circleModel.map(({ name, color, value, index }) => ({\n            label: name,\n            color,\n            value,\n            category: categories[index],\n        }));\n    }\n    getRespondersWithTheme(responders, type) {\n        const { radius, borderWidth, borderColor, color } = this.theme[type].dot;\n        return responders.map((responder) => {\n            const modelColor = (color !== null && color !== void 0 ? color : responder.color);\n            return Object.assign(Object.assign({}, responder), { radius, color: modelColor, style: [{ lineWidth: borderWidth, strokeStyle: (borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)) }] });\n        });\n    }\n    onClick({ responders }) {\n        if (this.selectable) {\n            this.eventBus.emit('renderSelectedSeries', {\n                models: this.getRespondersWithTheme(responders, 'select'),\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        }\n    }\n    onMousemove({ responders }) {\n        this.eventBus.emit('renderHoveredSeries', {\n            models: this.getRespondersWithTheme(responders, 'hover'),\n            name: this.name,\n        });\n        this.activatedResponders = responders;\n        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n        this.eventBus.emit('needDraw');\n    }\n    makeRadarPointsData(seriesData, renderOptions) {\n        const { centerX, centerY, degree, ratio, showArea } = renderOptions;\n        return seriesData.map(({ data, color: seriesColor, name }) => {\n            const radarPoints = data.reduce((acc, value, index) => {\n                if (isNull(value)) {\n                    return {\n                        distances: [...acc.distances, 0],\n                        linePoints: [...acc.linePoints, null],\n                        areaPoints: [...acc.areaPoints, { x: centerX, y: centerY }],\n                    };\n                }\n                const distance = value * ratio;\n                const point = getRadialPosition(centerX, centerY, distance, calculateDegreeToRadian(degree * index));\n                return {\n                    distances: [...acc.distances, distance],\n                    linePoints: [...acc.linePoints, point],\n                    areaPoints: [...acc.areaPoints, point],\n                };\n            }, { linePoints: [], distances: [], areaPoints: [] });\n            if (!isNull(data[0]) && !isNull(data[data.length - 1])) {\n                radarPoints.linePoints.push(radarPoints.linePoints[0]);\n                radarPoints.areaPoints.push(radarPoints.areaPoints[0]);\n            }\n            return Object.assign(Object.assign({ name,\n                seriesColor,\n                data }, radarPoints), this.getSeriesColor(showArea, seriesColor, name));\n        });\n    }\n    renderAreaModels(radarPointsData) {\n        return radarPointsData.map(({ distances, areaPoints, name, fillColor, seriesColor }) => ({\n            type: 'areaPoints',\n            name,\n            distances,\n            points: areaPoints,\n            fillColor,\n            color: getRGBA(seriesColor, 0),\n            lineWidth: 0,\n        }));\n    }\n    renderLineModels(radarPointsData) {\n        const { lineWidth, dashSegments } = this.theme;\n        return radarPointsData.map(({ distances, linePoints, name, lineColor }) => ({\n            type: 'linePoints',\n            lineWidth: (lineWidth !== null && lineWidth !== void 0 ? lineWidth : radarDefault.LINE_WIDTH),\n            name,\n            distances,\n            points: linePoints,\n            color: lineColor,\n            dashSegments,\n        }));\n    }\n    renderDotModels(radarPointsData) {\n        const { radius, color: dotColor } = this.theme.dot;\n        const result = [];\n        radarPointsData.forEach(({ linePoints, lineColor, name, data }, seriesIndex) => linePoints.slice(0, linePoints.length - 1).forEach((point, index) => {\n            var _a;\n            if (!isNull(point)) {\n                result.push(Object.assign(Object.assign({ type: 'circle' }, point), { radius, color: (dotColor !== null && dotColor !== void 0 ? dotColor : lineColor), style: [{ strokeStyle: 'rgba(0, 0, 0, 0)' }], name,\n                    seriesIndex,\n                    index, value: (_a = data) === null || _a === void 0 ? void 0 : _a[index] }));\n            }\n        }));\n        return result;\n    }\n    getSeriesColor(showArea, seriesColor, name) {\n        const active = this.activeSeriesMap[name];\n        const { select, areaOpacity } = this.theme;\n        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);\n        const color = getRGBA(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);\n        let fillOpacity = NONE_AREA_OPACITY;\n        if (showArea) {\n            const selectedAreaOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;\n            fillOpacity = selected ? selectedAreaOpacity : areaOpacity;\n        }\n        return { lineColor: color, fillColor: getRGBA(color, fillOpacity) };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}