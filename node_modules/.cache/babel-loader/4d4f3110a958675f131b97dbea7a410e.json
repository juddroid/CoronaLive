{"ast":null,"code":"import BoxSeries, { isLeftBottomSide, SeriesDirection } from \"./boxSeries\";\nimport { deepCopyArray, includes, isNumber, hasNegative, calculateSizeWithPercentString } from \"../helpers/utils\";\nimport { getLimitOnAxis } from \"../helpers/axes\";\nimport { isGroupStack, isPercentStack } from \"../store/stackSeriesData\";\nimport { calibrateBoxStackDrawingValue, sumValuesBeforeIndex } from \"../helpers/boxSeries\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getBoxTypeSeriesPadding } from \"../helpers/style\";\nimport { getDataInRange } from \"../helpers/range\";\nimport { message } from \"../message\";\nimport { makeLabelsFromLimit } from \"../helpers/calculator\";\n\nfunction calibrateDrawingValue(values, seriesIndex, renderOptions) {\n  const {\n    stack,\n    min,\n    max\n  } = renderOptions;\n  return isPercentStack(stack) ? values[seriesIndex] : calibrateBoxStackDrawingValue(values, seriesIndex, min, max);\n}\n\nfunction getDivisorForPercent(total, scaleType) {\n  const {\n    positive,\n    negative\n  } = total;\n  let divisor = positive + Math.abs(negative);\n\n  if (includes(['dualPercentStack', 'divergingPercentStack'], scaleType)) {\n    divisor *= 2;\n  }\n\n  return divisor;\n}\n\nfunction getDirectionKeys(seriesDirection) {\n  let result = ['positive', 'negative'];\n\n  if (seriesDirection === SeriesDirection.POSITIVE) {\n    result = ['positive'];\n  } else if (seriesDirection === SeriesDirection.NEGATIVE) {\n    result = ['negative'];\n  }\n\n  return result;\n}\n\nfunction getStackSeriesDataInViewRange(stackSeriesData, viewRange) {\n  if (!viewRange) {\n    return stackSeriesData;\n  }\n\n  const stackData = Array.isArray(stackSeriesData.stackData) ? getDataInRange(stackSeriesData.stackData, viewRange) : Object.assign({}, Object.keys(stackSeriesData.stackData).reduce((acc, name) => Object.assign(Object.assign({}, acc), {\n    [name]: getDataInRange(stackSeriesData.stackData[name], viewRange)\n  }), {}));\n  const data = stackSeriesData.data.map(seriesDatum => Object.assign(Object.assign({}, seriesDatum), {\n    data: getDataInRange(seriesDatum.data, viewRange)\n  }));\n  return Object.assign(Object.assign({}, stackSeriesData), {\n    data,\n    stackData\n  });\n}\n\nexport default class BoxStackSeries extends BoxSeries {\n  constructor() {\n    super(...arguments);\n\n    this.selectSeries = ({\n      index,\n      seriesIndex,\n      state\n    }) => {\n      if (!isNumber(index) || !isNumber(seriesIndex)) {\n        return;\n      }\n\n      const {\n        stackSeries\n      } = state;\n      const stackSeriesData = stackSeries[this.name];\n      const {\n        name\n      } = stackSeriesData.data[seriesIndex];\n      const model = this.tooltipRectMap[index].find(({\n        name: seriesName\n      }) => seriesName === name);\n\n      if (!model) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models: this.getRespondersWithTheme([model], 'select'),\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  initialize({\n    name,\n    stackChart\n  }) {\n    this.initializeFields(name);\n\n    if (stackChart) {\n      this.eventBus.on('selectSeries', this.selectSeries);\n      this.eventBus.on('showTooltip', this.showTooltip);\n      this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n    }\n  }\n\n  render(chartState, computed) {\n    var _a, _b;\n\n    const {\n      layout,\n      series: seriesData,\n      axes,\n      stackSeries,\n      legend,\n      theme,\n      scale\n    } = chartState;\n    const {\n      viewRange\n    } = computed;\n    this.isShow = !!stackSeries[this.name];\n\n    if (!this.isShow) {\n      return;\n    }\n\n    const categories = (_a = chartState.categories, _a !== null && _a !== void 0 ? _a : []);\n    const options = this.getOptions(chartState.options);\n    this.setEventDetectType(seriesData, options);\n    this.theme = theme.series[this.name];\n    this.rect = layout.plot;\n    this.activeSeriesMap = getActiveSeriesMap(legend);\n    this.selectable = this.getSelectableOption(options);\n    const stackSeriesData = getStackSeriesDataInViewRange(stackSeries[this.name], viewRange);\n    const {\n      tickDistance\n    } = axes[this.labelAxis];\n    const diverging = !!((_b = options.series) === null || _b === void 0 ? void 0 : _b.diverging);\n    const {\n      limit,\n      stepSize\n    } = this.getScaleData(scale);\n    const labels = makeLabelsFromLimit(limit, stepSize);\n    const {\n      min,\n      max\n    } = getLimitOnAxis(labels);\n    const {\n      stack,\n      scaleType\n    } = stackSeriesData;\n    this.basePosition = this.getBasePosition(axes[this.valueAxis]);\n    let offsetSize = this.getOffsetSize();\n    const {\n      centerYAxis\n    } = axes;\n\n    if (diverging) {\n      const [left, right] = this.getDivergingBasePosition(centerYAxis);\n      this.basePosition = this.getOffsetSize() / 2;\n      this.leftBasePosition = left;\n      this.rightBasePosition = right;\n      offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);\n    }\n\n    const renderOptions = {\n      stack,\n      scaleType,\n      tickDistance,\n      min,\n      max,\n      diverging,\n      hasNegativeValue: hasNegative(labels),\n      seriesDirection: this.getSeriesDirection(labels),\n      defaultPadding: getBoxTypeSeriesPadding(tickDistance),\n      offsetSize,\n      centerYAxis\n    };\n    const {\n      series,\n      connector\n    } = this.renderStackSeriesModel(stackSeriesData, renderOptions);\n    const clipRect = this.renderClipRectAreaModel();\n    const tooltipData = this.getTooltipData(stackSeriesData, categories);\n    this.models = {\n      clipRect: [clipRect],\n      series,\n      connector\n    };\n\n    if (!this.drawModels) {\n      this.drawModels = {\n        clipRect: [this.initClipRect(clipRect)],\n        series: deepCopyArray(series),\n        connector: deepCopyArray(connector)\n      };\n    }\n\n    if (getDataLabelsOptions(options, this.name).visible) {\n      const dataLabelData = this.getDataLabels(series, renderOptions);\n      const stackTotalData = this.getTotalDataLabels(stackSeriesData, renderOptions);\n      this.renderDataLabels([...dataLabelData, ...stackTotalData]);\n    }\n\n    this.tooltipRectMap = this.makeTooltipRectMap(series, tooltipData);\n    this.responders = this.getBoxSeriesResponders(series, tooltipData, axes, categories);\n  }\n\n  renderStackSeriesModel(seriesData, renderOptions) {\n    const {\n      stackData\n    } = seriesData;\n    return isGroupStack(stackData) ? this.makeStackGroupSeriesModel(seriesData, renderOptions) : this.makeStackSeriesModel(stackData, renderOptions, seriesData.data);\n  }\n\n  makeStackSeriesModel(stackData, renderOptions, seriesRawData, stackGroupCount = 1, stackGroupIndex = 0) {\n    const seriesModels = [];\n    const columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);\n    const {\n      diverging\n    } = renderOptions;\n    const isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);\n    stackData.forEach(({\n      values,\n      total\n    }, dataIndex) => {\n      const seriesPos = this.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);\n      const ratio = this.getStackValueRatio(total, renderOptions);\n      values.forEach((value, seriesIndex) => {\n        const {\n          barLength,\n          dataPosition\n        } = this.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);\n        const {\n          name\n        } = seriesRawData[seriesIndex];\n        const active = this.activeSeriesMap[name];\n        const color = getRGBA(seriesRawData[seriesIndex].color, active ? 1 : 0.2);\n        seriesModels.push(Object.assign(Object.assign({\n          type: 'rect',\n          color,\n          name,\n          value\n        }, this.getAdjustedRect(seriesPos, dataPosition, barLength !== null && barLength !== void 0 ? barLength : 0, columnWidth)), {\n          index: dataIndex\n        }));\n      });\n    });\n    return {\n      series: seriesModels,\n      connector: this.makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount, stackGroupIndex)\n    };\n  }\n\n  makeStackGroupSeriesModel(stackSeries, renderOptions) {\n    const {\n      stack\n    } = renderOptions;\n    const stackGroupData = stackSeries.stackData;\n    const seriesRawData = stackSeries.data;\n    const stackGroupIds = Object.keys(stackGroupData);\n    let seriesModels = [];\n    let connectorModels = [];\n    stackGroupIds.forEach((groupId, groupIndex) => {\n      const filtered = seriesRawData.filter(({\n        stackGroup\n      }) => stackGroup === groupId);\n      const {\n        series,\n        connector\n      } = this.makeStackSeriesModel(stackGroupData[groupId], renderOptions, filtered, stackGroupIds.length, groupIndex);\n      seriesModels = [...seriesModels, ...series];\n\n      if (stack.connector) {\n        connectorModels = [...connectorModels, ...connector];\n      }\n    });\n    return {\n      series: seriesModels,\n      connector: connectorModels\n    };\n  }\n\n  makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount = 1, stackGroupIndex = 0) {\n    const {\n      diverging,\n      stack: {\n        connector\n      }\n    } = renderOptions;\n\n    if (!connector) {\n      return [];\n    }\n\n    const columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);\n    const isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);\n    const connectorPoints = [];\n    stackData.forEach(({\n      values,\n      total\n    }, index) => {\n      const seriesPos = this.getSeriesPosition(renderOptions, columnWidth, index, stackGroupIndex, stackGroupCount);\n      const points = [];\n      const ratio = this.getStackValueRatio(total, renderOptions);\n      values.forEach((value, seriesIndex) => {\n        const {\n          barLength,\n          dataPosition\n        } = this.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);\n        const {\n          x,\n          y\n        } = this.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth);\n        const xPos = !isLBSideWithDiverging && this.isBar ? x + barLength : x;\n        const yPos = isLBSideWithDiverging && !this.isBar ? y + barLength : y;\n        points.push({\n          x: xPos,\n          y: yPos\n        });\n      });\n      connectorPoints.push(points);\n    });\n    return this.makeConnectorModel(connectorPoints, connector, columnWidth);\n  }\n\n  getTooltipData(seriesData, categories) {\n    const seriesRawData = seriesData.data;\n    const {\n      stackData\n    } = seriesData;\n    const colors = seriesRawData.map(({\n      color\n    }) => color);\n    return isGroupStack(stackData) ? this.makeGroupStackTooltipData(seriesRawData, stackData, categories) : this.makeStackTooltipData(seriesRawData, stackData, colors, categories);\n  }\n\n  makeGroupStackTooltipData(seriesRawData, stackData, categories) {\n    return Object.keys(stackData).flatMap(groupId => {\n      const rawDataWithSameGroupId = seriesRawData.filter(({\n        stackGroup\n      }) => stackGroup === groupId);\n      const colors = rawDataWithSameGroupId.map(({\n        color\n      }) => color);\n      return this.makeStackTooltipData(rawDataWithSameGroupId, stackData[groupId], colors, categories);\n    });\n  }\n\n  makeStackTooltipData(seriesRawData, stackData, colors, categories) {\n    const tooltipData = [];\n    stackData.forEach(({\n      values\n    }, dataIndex) => {\n      values.forEach((value, seriesIndex) => {\n        tooltipData.push({\n          label: seriesRawData[seriesIndex].name,\n          color: colors[seriesIndex],\n          value,\n          category: categories.length ? categories[dataIndex] : ''\n        });\n      });\n    });\n    return tooltipData;\n  }\n\n  makeConnectorModel(pointsForConnector, connector, columnWidth) {\n    if (!connector || !pointsForConnector.length) {\n      return [];\n    }\n\n    const {\n      color,\n      lineWidth,\n      dashSegments\n    } = this.theme.connector;\n    const connectorModels = [];\n    const seriesDataCount = pointsForConnector.length;\n    const seriesCount = pointsForConnector[0].length;\n\n    for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex += 1) {\n      const points = [];\n\n      for (let dataIndex = 0; dataIndex < seriesDataCount; dataIndex += 1) {\n        points.push(pointsForConnector[dataIndex][seriesIndex]);\n      }\n\n      points.forEach((point, index) => {\n        const {\n          x,\n          y\n        } = point;\n\n        if (index < points.length - 1) {\n          const {\n            x: nextX,\n            y: nextY\n          } = points[index + 1];\n          connectorModels.push({\n            type: 'line',\n            x: this.isBar ? x : x + columnWidth,\n            y: this.isBar ? y + columnWidth : y,\n            x2: nextX,\n            y2: nextY,\n            dashSegments,\n            strokeStyle: color,\n            lineWidth\n          });\n        }\n      });\n    }\n\n    return connectorModels;\n  }\n\n  getStackValueRatio(total, renderOptions) {\n    const {\n      stack: {\n        type: stackType\n      },\n      scaleType,\n      min,\n      max,\n      offsetSize\n    } = renderOptions;\n\n    if (stackType === 'percent') {\n      return offsetSize / getDivisorForPercent(total, scaleType);\n    }\n\n    return this.getValueRatio(min, max, offsetSize);\n  }\n\n  getStackBarLength(values, seriesIndex, ratio, renderOptions) {\n    const value = calibrateDrawingValue(values, seriesIndex, renderOptions);\n    return isNumber(value) ? this.getBarLength(value, ratio) : null;\n  }\n\n  getStackColumnWidth(renderOptions, stackGroupCount) {\n    const {\n      tickDistance,\n      diverging,\n      defaultPadding\n    } = renderOptions;\n    const divisor = diverging ? 1 : stackGroupCount;\n    const themeBarWidth = this.theme.barWidth;\n    return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / divisor;\n  }\n\n  getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount) {\n    const {\n      tickDistance,\n      diverging\n    } = renderOptions;\n    const groupIndex = diverging ? 0 : stackGroupIndex;\n    const groupCount = diverging ? 1 : stackGroupCount;\n    const padding = (tickDistance - columnWidth * groupCount) / 2;\n    return dataIndex * tickDistance + padding + columnWidth * groupIndex;\n  }\n\n  getStackStartPosition(values, currentIndex, ratio, renderOptions, isLBSideWithDiverging) {\n    const {\n      stack,\n      diverging,\n      seriesDirection\n    } = renderOptions;\n    let startPos;\n\n    if (diverging) {\n      startPos = isLBSideWithDiverging ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);\n    } else if (isPercentStack(stack)) {\n      startPos = this.calcStartPositionWithPercent(values, currentIndex, ratio);\n    } else if (seriesDirection === SeriesDirection.POSITIVE) {\n      startPos = this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);\n    } else if (seriesDirection === SeriesDirection.NEGATIVE) {\n      startPos = this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio);\n    } else {\n      startPos = this.calcStartPositionWithStack(values, currentIndex, renderOptions, ratio);\n    }\n\n    return startPos;\n  }\n\n  calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) {\n    const {\n      min,\n      max,\n      diverging\n    } = renderOptions;\n    const basePosition = diverging ? this.leftBasePosition : this.basePosition;\n    const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);\n    const totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);\n    const collideEdge = totalOfValues < min;\n    const usingValue = this.isBar ? totalOfValues : totalOfIndexBefore;\n    const result = max < 0 ? Math.min(usingValue - max, 0) : usingValue;\n    let pos;\n\n    if (this.isBar) {\n      pos = collideEdge ? 0 : basePosition - Math.abs(result) * ratio;\n    } else {\n      pos = basePosition + Math.abs(result) * ratio;\n    }\n\n    return pos;\n  }\n\n  calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio) {\n    const {\n      min,\n      max,\n      diverging\n    } = renderOptions;\n    const basePosition = diverging ? this.rightBasePosition : this.basePosition;\n    const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);\n    const totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);\n    const collideEdge = totalOfValues > max;\n    const usingValue = this.isBar ? totalOfIndexBefore : totalOfValues;\n    const result = min > 0 ? Math.max(usingValue - min, 0) : usingValue;\n    const barLength = result * ratio;\n    let pos;\n\n    if (this.isBar) {\n      pos = basePosition + barLength;\n    } else {\n      pos = collideEdge ? 0 : basePosition - barLength;\n    }\n\n    return pos;\n  }\n\n  calcStartPositionWithStack(values, currentIndex, renderOptions, ratio) {\n    return values[currentIndex] < 0 ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);\n  }\n\n  calcStartPositionWithPercent(values, currentIndex, ratio) {\n    const basePosition = this.basePosition;\n    const totalPrevValues = sumValuesBeforeIndex(values, currentIndex, this.isBar ? values[currentIndex] < 0 : values[currentIndex] > 0);\n    return this.isBar ? totalPrevValues * ratio + basePosition : basePosition - totalPrevValues * ratio;\n  }\n\n  getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging) {\n    const barLength = this.getStackBarLength(values, seriesIndex, ratio, renderOptions);\n    const dataPosition = this.getStackStartPosition(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);\n    return {\n      barLength,\n      dataPosition\n    };\n  }\n\n  getDataLabels(seriesModels, renderOptions) {\n    return seriesModels.map(data => this.makeDataLabel(data, renderOptions.centerYAxis));\n  }\n\n  getTotalDataLabels(seriesData, renderOptions) {\n    const {\n      stackData,\n      stack\n    } = seriesData;\n\n    if (isPercentStack(stack)) {\n      return [];\n    }\n\n    return isGroupStack(stackData) ? this.makeGroupTotalDataLabels(seriesData, renderOptions) : this.makeTotalDataLabels(stackData, renderOptions);\n  }\n\n  makeGroupTotalDataLabels(stackSeries, renderOptions) {\n    let dataLabels = [];\n    const stackGroupData = stackSeries.stackData;\n    const stackGroupIds = Object.keys(stackGroupData);\n    stackGroupIds.forEach((groupId, groupIndex) => {\n      const totalDataLabels = this.makeTotalDataLabels(stackGroupData[groupId], renderOptions, stackGroupIds.length, groupIndex);\n      dataLabels = [...dataLabels, ...totalDataLabels];\n    });\n    return dataLabels;\n  }\n\n  makeTotalDataLabels(stackData, renderOptions, stackGroupCount = 1, stackGroupIndex = 0) {\n    const dataLabels = [];\n    const {\n      min,\n      max,\n      seriesDirection,\n      diverging,\n      centerYAxis\n    } = renderOptions;\n    const columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);\n    stackData.forEach((data, dataIndex) => {\n      const {\n        total\n      } = data;\n      const seriesPos = this.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);\n      const ratio = this.getStackValueRatio(total, renderOptions);\n      const directionKeys = getDirectionKeys(seriesDirection);\n      directionKeys.forEach(key => {\n        const value = total[key];\n\n        if (!value) {\n          return;\n        }\n\n        const barLength = this.makeBarLength(value, {\n          min,\n          max,\n          ratio\n        });\n        const dataPosition = this.getStartPosition(barLength, value, renderOptions, diverging && isLeftBottomSide(stackGroupIndex));\n        const stackTotal = Object.assign({\n          type: 'stackTotal',\n          value,\n          name: `totalLabel-${key}`,\n          theme: this.theme.dataLabels.stackTotal\n        }, this.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth));\n        dataLabels.push(this.makeTotalDataLabel(stackTotal, centerYAxis));\n      });\n    });\n    return dataLabels;\n  }\n\n  makeTotalDataLabel(totalLabel, centerYAxis) {\n    return Object.assign(Object.assign({}, totalLabel), {\n      direction: this.getDataLabelDirection(totalLabel, centerYAxis),\n      plot: {\n        x: 0,\n        y: 0,\n        size: this.getOffsetSize()\n      }\n    });\n  }\n\n  onMousemoveGroupedType(responders) {\n    const rectModels = this.getRectModelsFromRectResponders(responders);\n    this.eventBus.emit('renderHoveredSeries', {\n      models: [...rectModels, ...this.getGroupedRect(responders, 'hover')],\n      name: this.name,\n      eventDetectType: this.eventDetectType\n    });\n    this.activatedResponders = rectModels;\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/boxStackSeries.js"],"names":["BoxSeries","isLeftBottomSide","SeriesDirection","deepCopyArray","includes","isNumber","hasNegative","calculateSizeWithPercentString","getLimitOnAxis","isGroupStack","isPercentStack","calibrateBoxStackDrawingValue","sumValuesBeforeIndex","getDataLabelsOptions","getRGBA","getActiveSeriesMap","getBoxTypeSeriesPadding","getDataInRange","message","makeLabelsFromLimit","calibrateDrawingValue","values","seriesIndex","renderOptions","stack","min","max","getDivisorForPercent","total","scaleType","positive","negative","divisor","Math","abs","getDirectionKeys","seriesDirection","result","POSITIVE","NEGATIVE","getStackSeriesDataInViewRange","stackSeriesData","viewRange","stackData","Array","isArray","Object","assign","keys","reduce","acc","name","data","map","seriesDatum","BoxStackSeries","constructor","arguments","selectSeries","index","state","stackSeries","model","tooltipRectMap","find","seriesName","Error","SELECT_SERIES_API_INDEX_ERROR","eventBus","emit","models","getRespondersWithTheme","eventDetectType","initialize","stackChart","initializeFields","on","showTooltip","onMouseoutComponent","render","chartState","computed","_a","_b","layout","series","seriesData","axes","legend","theme","scale","isShow","categories","options","getOptions","setEventDetectType","rect","plot","activeSeriesMap","selectable","getSelectableOption","tickDistance","labelAxis","diverging","limit","stepSize","getScaleData","labels","basePosition","getBasePosition","valueAxis","offsetSize","getOffsetSize","centerYAxis","left","right","getDivergingBasePosition","leftBasePosition","rightBasePosition","getOffsetSizeWithDiverging","hasNegativeValue","getSeriesDirection","defaultPadding","connector","renderStackSeriesModel","clipRect","renderClipRectAreaModel","tooltipData","getTooltipData","drawModels","initClipRect","visible","dataLabelData","getDataLabels","stackTotalData","getTotalDataLabels","renderDataLabels","makeTooltipRectMap","responders","getBoxSeriesResponders","makeStackGroupSeriesModel","makeStackSeriesModel","seriesRawData","stackGroupCount","stackGroupIndex","seriesModels","columnWidth","getStackColumnWidth","isLBSideWithDiverging","forEach","dataIndex","seriesPos","getSeriesPosition","ratio","getStackValueRatio","value","barLength","dataPosition","getStackRectInfo","active","color","push","type","getAdjustedRect","makeConnectorSeriesModel","stackGroupData","stackGroupIds","connectorModels","groupId","groupIndex","filtered","filter","stackGroup","length","connectorPoints","points","x","y","xPos","isBar","yPos","makeConnectorModel","colors","makeGroupStackTooltipData","makeStackTooltipData","flatMap","rawDataWithSameGroupId","label","category","pointsForConnector","lineWidth","dashSegments","seriesDataCount","seriesCount","point","nextX","nextY","x2","y2","strokeStyle","stackType","getValueRatio","getStackBarLength","getBarLength","themeBarWidth","barWidth","groupCount","padding","getStackStartPosition","currentIndex","startPos","calcStartPosOnLeftBottomSide","calcStartPosOnRightTopSide","calcStartPositionWithPercent","calcStartPositionWithStack","totalOfIndexBefore","totalOfValues","collideEdge","usingValue","pos","totalPrevValues","makeDataLabel","makeGroupTotalDataLabels","makeTotalDataLabels","dataLabels","totalDataLabels","directionKeys","key","makeBarLength","getStartPosition","stackTotal","makeTotalDataLabel","totalLabel","direction","getDataLabelDirection","size","onMousemoveGroupedType","rectModels","getRectModelsFromRectResponders","getGroupedRect","activatedResponders"],"mappings":"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","sourcesContent":["import BoxSeries, { isLeftBottomSide, SeriesDirection } from \"./boxSeries\";\nimport { deepCopyArray, includes, isNumber, hasNegative, calculateSizeWithPercentString, } from \"../helpers/utils\";\nimport { getLimitOnAxis } from \"../helpers/axes\";\nimport { isGroupStack, isPercentStack } from \"../store/stackSeriesData\";\nimport { calibrateBoxStackDrawingValue, sumValuesBeforeIndex } from \"../helpers/boxSeries\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getBoxTypeSeriesPadding } from \"../helpers/style\";\nimport { getDataInRange } from \"../helpers/range\";\nimport { message } from \"../message\";\nimport { makeLabelsFromLimit } from \"../helpers/calculator\";\nfunction calibrateDrawingValue(values, seriesIndex, renderOptions) {\n    const { stack, min, max } = renderOptions;\n    return isPercentStack(stack)\n        ? values[seriesIndex]\n        : calibrateBoxStackDrawingValue(values, seriesIndex, min, max);\n}\nfunction getDivisorForPercent(total, scaleType) {\n    const { positive, negative } = total;\n    let divisor = positive + Math.abs(negative);\n    if (includes(['dualPercentStack', 'divergingPercentStack'], scaleType)) {\n        divisor *= 2;\n    }\n    return divisor;\n}\nfunction getDirectionKeys(seriesDirection) {\n    let result = ['positive', 'negative'];\n    if (seriesDirection === SeriesDirection.POSITIVE) {\n        result = ['positive'];\n    }\n    else if (seriesDirection === SeriesDirection.NEGATIVE) {\n        result = ['negative'];\n    }\n    return result;\n}\nfunction getStackSeriesDataInViewRange(stackSeriesData, viewRange) {\n    if (!viewRange) {\n        return stackSeriesData;\n    }\n    const stackData = Array.isArray(stackSeriesData.stackData)\n        ? getDataInRange(stackSeriesData.stackData, viewRange)\n        : Object.assign({}, Object.keys(stackSeriesData.stackData).reduce((acc, name) => (Object.assign(Object.assign({}, acc), { [name]: getDataInRange(stackSeriesData.stackData[name], viewRange) })), {}));\n    const data = stackSeriesData.data.map((seriesDatum) => (Object.assign(Object.assign({}, seriesDatum), { data: getDataInRange(seriesDatum.data, viewRange) })));\n    return Object.assign(Object.assign({}, stackSeriesData), { data, stackData });\n}\nexport default class BoxStackSeries extends BoxSeries {\n    constructor() {\n        super(...arguments);\n        this.selectSeries = ({ index, seriesIndex, state, }) => {\n            if (!isNumber(index) || !isNumber(seriesIndex)) {\n                return;\n            }\n            const { stackSeries } = state;\n            const stackSeriesData = stackSeries[this.name];\n            const { name } = stackSeriesData.data[seriesIndex];\n            const model = this.tooltipRectMap[index].find(({ name: seriesName }) => seriesName === name);\n            if (!model) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models: this.getRespondersWithTheme([model], 'select'),\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        };\n    }\n    initialize({ name, stackChart }) {\n        this.initializeFields(name);\n        if (stackChart) {\n            this.eventBus.on('selectSeries', this.selectSeries);\n            this.eventBus.on('showTooltip', this.showTooltip);\n            this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n        }\n    }\n    render(chartState, computed) {\n        var _a, _b;\n        const { layout, series: seriesData, axes, stackSeries, legend, theme, scale } = chartState;\n        const { viewRange } = computed;\n        this.isShow = !!stackSeries[this.name];\n        if (!this.isShow) {\n            return;\n        }\n        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));\n        const options = this.getOptions(chartState.options);\n        this.setEventDetectType(seriesData, options);\n        this.theme = theme.series[this.name];\n        this.rect = layout.plot;\n        this.activeSeriesMap = getActiveSeriesMap(legend);\n        this.selectable = this.getSelectableOption(options);\n        const stackSeriesData = getStackSeriesDataInViewRange(stackSeries[this.name], viewRange);\n        const { tickDistance } = axes[this.labelAxis];\n        const diverging = !!((_b = options.series) === null || _b === void 0 ? void 0 : _b.diverging);\n        const { limit, stepSize } = this.getScaleData(scale);\n        const labels = makeLabelsFromLimit(limit, stepSize);\n        const { min, max } = getLimitOnAxis(labels);\n        const { stack, scaleType } = stackSeriesData;\n        this.basePosition = this.getBasePosition(axes[this.valueAxis]);\n        let offsetSize = this.getOffsetSize();\n        const { centerYAxis } = axes;\n        if (diverging) {\n            const [left, right] = this.getDivergingBasePosition(centerYAxis);\n            this.basePosition = this.getOffsetSize() / 2;\n            this.leftBasePosition = left;\n            this.rightBasePosition = right;\n            offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);\n        }\n        const renderOptions = {\n            stack,\n            scaleType,\n            tickDistance,\n            min,\n            max,\n            diverging,\n            hasNegativeValue: hasNegative(labels),\n            seriesDirection: this.getSeriesDirection(labels),\n            defaultPadding: getBoxTypeSeriesPadding(tickDistance),\n            offsetSize,\n            centerYAxis,\n        };\n        const { series, connector } = this.renderStackSeriesModel(stackSeriesData, renderOptions);\n        const clipRect = this.renderClipRectAreaModel();\n        const tooltipData = this.getTooltipData(stackSeriesData, categories);\n        this.models = {\n            clipRect: [clipRect],\n            series,\n            connector,\n        };\n        if (!this.drawModels) {\n            this.drawModels = {\n                clipRect: [this.initClipRect(clipRect)],\n                series: deepCopyArray(series),\n                connector: deepCopyArray(connector),\n            };\n        }\n        if (getDataLabelsOptions(options, this.name).visible) {\n            const dataLabelData = this.getDataLabels(series, renderOptions);\n            const stackTotalData = this.getTotalDataLabels(stackSeriesData, renderOptions);\n            this.renderDataLabels([...dataLabelData, ...stackTotalData]);\n        }\n        this.tooltipRectMap = this.makeTooltipRectMap(series, tooltipData);\n        this.responders = this.getBoxSeriesResponders(series, tooltipData, axes, categories);\n    }\n    renderStackSeriesModel(seriesData, renderOptions) {\n        const { stackData } = seriesData;\n        return isGroupStack(stackData)\n            ? this.makeStackGroupSeriesModel(seriesData, renderOptions)\n            : this.makeStackSeriesModel(stackData, renderOptions, seriesData.data);\n    }\n    makeStackSeriesModel(stackData, renderOptions, seriesRawData, stackGroupCount = 1, stackGroupIndex = 0) {\n        const seriesModels = [];\n        const columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);\n        const { diverging } = renderOptions;\n        const isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);\n        stackData.forEach(({ values, total }, dataIndex) => {\n            const seriesPos = this.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);\n            const ratio = this.getStackValueRatio(total, renderOptions);\n            values.forEach((value, seriesIndex) => {\n                const { barLength, dataPosition } = this.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);\n                const { name } = seriesRawData[seriesIndex];\n                const active = this.activeSeriesMap[name];\n                const color = getRGBA(seriesRawData[seriesIndex].color, active ? 1 : 0.2);\n                seriesModels.push(Object.assign(Object.assign({ type: 'rect', color,\n                    name,\n                    value }, this.getAdjustedRect(seriesPos, dataPosition, (barLength !== null && barLength !== void 0 ? barLength : 0), columnWidth)), { index: dataIndex }));\n            });\n        });\n        return {\n            series: seriesModels,\n            connector: this.makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount, stackGroupIndex),\n        };\n    }\n    makeStackGroupSeriesModel(stackSeries, renderOptions) {\n        const { stack } = renderOptions;\n        const stackGroupData = stackSeries.stackData;\n        const seriesRawData = stackSeries.data;\n        const stackGroupIds = Object.keys(stackGroupData);\n        let seriesModels = [];\n        let connectorModels = [];\n        stackGroupIds.forEach((groupId, groupIndex) => {\n            const filtered = seriesRawData.filter(({ stackGroup }) => stackGroup === groupId);\n            const { series, connector } = this.makeStackSeriesModel(stackGroupData[groupId], renderOptions, filtered, stackGroupIds.length, groupIndex);\n            seriesModels = [...seriesModels, ...series];\n            if (stack.connector) {\n                connectorModels = [...connectorModels, ...connector];\n            }\n        });\n        return {\n            series: seriesModels,\n            connector: connectorModels,\n        };\n    }\n    makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount = 1, stackGroupIndex = 0) {\n        const { diverging, stack: { connector }, } = renderOptions;\n        if (!connector) {\n            return [];\n        }\n        const columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);\n        const isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);\n        const connectorPoints = [];\n        stackData.forEach(({ values, total }, index) => {\n            const seriesPos = this.getSeriesPosition(renderOptions, columnWidth, index, stackGroupIndex, stackGroupCount);\n            const points = [];\n            const ratio = this.getStackValueRatio(total, renderOptions);\n            values.forEach((value, seriesIndex) => {\n                const { barLength, dataPosition } = this.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);\n                const { x, y } = this.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth);\n                const xPos = !isLBSideWithDiverging && this.isBar ? x + barLength : x;\n                const yPos = isLBSideWithDiverging && !this.isBar ? y + barLength : y;\n                points.push({ x: xPos, y: yPos });\n            });\n            connectorPoints.push(points);\n        });\n        return this.makeConnectorModel(connectorPoints, connector, columnWidth);\n    }\n    getTooltipData(seriesData, categories) {\n        const seriesRawData = seriesData.data;\n        const { stackData } = seriesData;\n        const colors = seriesRawData.map(({ color }) => color);\n        return isGroupStack(stackData)\n            ? this.makeGroupStackTooltipData(seriesRawData, stackData, categories)\n            : this.makeStackTooltipData(seriesRawData, stackData, colors, categories);\n    }\n    makeGroupStackTooltipData(seriesRawData, stackData, categories) {\n        return Object.keys(stackData).flatMap((groupId) => {\n            const rawDataWithSameGroupId = seriesRawData.filter(({ stackGroup }) => stackGroup === groupId);\n            const colors = rawDataWithSameGroupId.map(({ color }) => color);\n            return this.makeStackTooltipData(rawDataWithSameGroupId, stackData[groupId], colors, categories);\n        });\n    }\n    makeStackTooltipData(seriesRawData, stackData, colors, categories) {\n        const tooltipData = [];\n        stackData.forEach(({ values }, dataIndex) => {\n            values.forEach((value, seriesIndex) => {\n                tooltipData.push({\n                    label: seriesRawData[seriesIndex].name,\n                    color: colors[seriesIndex],\n                    value,\n                    category: categories.length ? categories[dataIndex] : '',\n                });\n            });\n        });\n        return tooltipData;\n    }\n    makeConnectorModel(pointsForConnector, connector, columnWidth) {\n        if (!connector || !pointsForConnector.length) {\n            return [];\n        }\n        const { color, lineWidth, dashSegments } = this.theme.connector;\n        const connectorModels = [];\n        const seriesDataCount = pointsForConnector.length;\n        const seriesCount = pointsForConnector[0].length;\n        for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex += 1) {\n            const points = [];\n            for (let dataIndex = 0; dataIndex < seriesDataCount; dataIndex += 1) {\n                points.push(pointsForConnector[dataIndex][seriesIndex]);\n            }\n            points.forEach((point, index) => {\n                const { x, y } = point;\n                if (index < points.length - 1) {\n                    const { x: nextX, y: nextY } = points[index + 1];\n                    connectorModels.push({\n                        type: 'line',\n                        x: this.isBar ? x : x + columnWidth,\n                        y: this.isBar ? y + columnWidth : y,\n                        x2: nextX,\n                        y2: nextY,\n                        dashSegments,\n                        strokeStyle: color,\n                        lineWidth,\n                    });\n                }\n            });\n        }\n        return connectorModels;\n    }\n    getStackValueRatio(total, renderOptions) {\n        const { stack: { type: stackType }, scaleType, min, max, offsetSize, } = renderOptions;\n        if (stackType === 'percent') {\n            return offsetSize / getDivisorForPercent(total, scaleType);\n        }\n        return this.getValueRatio(min, max, offsetSize);\n    }\n    getStackBarLength(values, seriesIndex, ratio, renderOptions) {\n        const value = calibrateDrawingValue(values, seriesIndex, renderOptions);\n        return isNumber(value) ? this.getBarLength(value, ratio) : null;\n    }\n    getStackColumnWidth(renderOptions, stackGroupCount) {\n        const { tickDistance, diverging, defaultPadding } = renderOptions;\n        const divisor = diverging ? 1 : stackGroupCount;\n        const themeBarWidth = this.theme.barWidth;\n        return themeBarWidth\n            ? calculateSizeWithPercentString(tickDistance, themeBarWidth)\n            : (tickDistance - defaultPadding * 2) / divisor;\n    }\n    getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount) {\n        const { tickDistance, diverging } = renderOptions;\n        const groupIndex = diverging ? 0 : stackGroupIndex;\n        const groupCount = diverging ? 1 : stackGroupCount;\n        const padding = (tickDistance - columnWidth * groupCount) / 2;\n        return dataIndex * tickDistance + padding + columnWidth * groupIndex;\n    }\n    getStackStartPosition(values, currentIndex, ratio, renderOptions, isLBSideWithDiverging) {\n        const { stack, diverging, seriesDirection } = renderOptions;\n        let startPos;\n        if (diverging) {\n            startPos = isLBSideWithDiverging\n                ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio)\n                : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);\n        }\n        else if (isPercentStack(stack)) {\n            startPos = this.calcStartPositionWithPercent(values, currentIndex, ratio);\n        }\n        else if (seriesDirection === SeriesDirection.POSITIVE) {\n            startPos = this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);\n        }\n        else if (seriesDirection === SeriesDirection.NEGATIVE) {\n            startPos = this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio);\n        }\n        else {\n            startPos = this.calcStartPositionWithStack(values, currentIndex, renderOptions, ratio);\n        }\n        return startPos;\n    }\n    calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) {\n        const { min, max, diverging } = renderOptions;\n        const basePosition = diverging ? this.leftBasePosition : this.basePosition;\n        const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);\n        const totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);\n        const collideEdge = totalOfValues < min;\n        const usingValue = this.isBar ? totalOfValues : totalOfIndexBefore;\n        const result = max < 0 ? Math.min(usingValue - max, 0) : usingValue;\n        let pos;\n        if (this.isBar) {\n            pos = collideEdge ? 0 : basePosition - Math.abs(result) * ratio;\n        }\n        else {\n            pos = basePosition + Math.abs(result) * ratio;\n        }\n        return pos;\n    }\n    calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio) {\n        const { min, max, diverging } = renderOptions;\n        const basePosition = diverging ? this.rightBasePosition : this.basePosition;\n        const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);\n        const totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);\n        const collideEdge = totalOfValues > max;\n        const usingValue = this.isBar ? totalOfIndexBefore : totalOfValues;\n        const result = min > 0 ? Math.max(usingValue - min, 0) : usingValue;\n        const barLength = result * ratio;\n        let pos;\n        if (this.isBar) {\n            pos = basePosition + barLength;\n        }\n        else {\n            pos = collideEdge ? 0 : basePosition - barLength;\n        }\n        return pos;\n    }\n    calcStartPositionWithStack(values, currentIndex, renderOptions, ratio) {\n        return values[currentIndex] < 0\n            ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio)\n            : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);\n    }\n    calcStartPositionWithPercent(values, currentIndex, ratio) {\n        const basePosition = this.basePosition;\n        const totalPrevValues = sumValuesBeforeIndex(values, currentIndex, this.isBar ? values[currentIndex] < 0 : values[currentIndex] > 0);\n        return this.isBar\n            ? totalPrevValues * ratio + basePosition\n            : basePosition - totalPrevValues * ratio;\n    }\n    getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging) {\n        const barLength = this.getStackBarLength(values, seriesIndex, ratio, renderOptions);\n        const dataPosition = this.getStackStartPosition(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);\n        return {\n            barLength,\n            dataPosition,\n        };\n    }\n    getDataLabels(seriesModels, renderOptions) {\n        return seriesModels.map((data) => this.makeDataLabel(data, renderOptions.centerYAxis));\n    }\n    getTotalDataLabels(seriesData, renderOptions) {\n        const { stackData, stack } = seriesData;\n        if (isPercentStack(stack)) {\n            return [];\n        }\n        return isGroupStack(stackData)\n            ? this.makeGroupTotalDataLabels(seriesData, renderOptions)\n            : this.makeTotalDataLabels(stackData, renderOptions);\n    }\n    makeGroupTotalDataLabels(stackSeries, renderOptions) {\n        let dataLabels = [];\n        const stackGroupData = stackSeries.stackData;\n        const stackGroupIds = Object.keys(stackGroupData);\n        stackGroupIds.forEach((groupId, groupIndex) => {\n            const totalDataLabels = this.makeTotalDataLabels(stackGroupData[groupId], renderOptions, stackGroupIds.length, groupIndex);\n            dataLabels = [...dataLabels, ...totalDataLabels];\n        });\n        return dataLabels;\n    }\n    makeTotalDataLabels(stackData, renderOptions, stackGroupCount = 1, stackGroupIndex = 0) {\n        const dataLabels = [];\n        const { min, max, seriesDirection, diverging, centerYAxis } = renderOptions;\n        const columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);\n        stackData.forEach((data, dataIndex) => {\n            const { total } = data;\n            const seriesPos = this.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);\n            const ratio = this.getStackValueRatio(total, renderOptions);\n            const directionKeys = getDirectionKeys(seriesDirection);\n            directionKeys.forEach((key) => {\n                const value = total[key];\n                if (!value) {\n                    return;\n                }\n                const barLength = this.makeBarLength(value, {\n                    min,\n                    max,\n                    ratio,\n                });\n                const dataPosition = this.getStartPosition(barLength, value, renderOptions, diverging && isLeftBottomSide(stackGroupIndex));\n                const stackTotal = Object.assign({ type: 'stackTotal', value, name: `totalLabel-${key}`, theme: this.theme.dataLabels.stackTotal }, this.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth));\n                dataLabels.push(this.makeTotalDataLabel(stackTotal, centerYAxis));\n            });\n        });\n        return dataLabels;\n    }\n    makeTotalDataLabel(totalLabel, centerYAxis) {\n        return Object.assign(Object.assign({}, totalLabel), { direction: this.getDataLabelDirection(totalLabel, centerYAxis), plot: {\n                x: 0,\n                y: 0,\n                size: this.getOffsetSize(),\n            } });\n    }\n    onMousemoveGroupedType(responders) {\n        const rectModels = this.getRectModelsFromRectResponders(responders);\n        this.eventBus.emit('renderHoveredSeries', {\n            models: [...rectModels, ...this.getGroupedRect(responders, 'hover')],\n            name: this.name,\n            eventDetectType: this.eventDetectType,\n        });\n        this.activatedResponders = rectModels;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}