{"ast":null,"code":"import Component from \"./component\";\nimport { isNumber, pick, isNull, calculateSizeWithPercentString, deepCopy } from \"../helpers/utils\";\nimport { message } from \"../message\";\nimport { makeGroupedSectorResponderModel } from \"../helpers/responders\";\nimport { getRadialAnchorPosition, makeAnchorPositionParam, withinRadian, getRadiusRanges, DEGREE_360, DEGREE_0, DEGREE_NEGATIVE_90 } from \"../helpers/sector\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getTotalAngle } from \"../helpers/pieSeries\";\nimport { isAvailableShowTooltipInfo } from \"../helpers/validation\";\nexport default class RadialBarSeries extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {};\n    this.activatedResponders = [];\n    this.eventDetectType = 'point';\n\n    this.onMouseoutComponent = () => {\n      this.eventBus.emit('seriesPointHovered', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('renderHoveredSeries', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.selectSeries = info => {\n      var _a;\n\n      const {\n        index,\n        seriesIndex\n      } = info;\n      const isAvailable = isNumber(index) && (this.eventDetectType === 'grouped' || isNumber(seriesIndex));\n\n      if (!isAvailable) {\n        return;\n      }\n\n      const models = this.eventDetectType === 'grouped' ? [...this.getGroupedSector([this.responders[index]], 'select'), ...this.getSectorModelsFromResponders([this.responders[index]])] : (_a = this.getResponderModelsWithTheme([this.tooltipSectorMap[index][seriesIndex]], 'select'), _a !== null && _a !== void 0 ? _a : []);\n\n      if (!models.length) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models: models,\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.showTooltip = info => {\n      const {\n        index,\n        seriesIndex\n      } = info;\n\n      if (!isAvailableShowTooltipInfo(info, this.eventDetectType, 'radialBar')) {\n        return;\n      }\n\n      const models = this.eventDetectType === 'grouped' ? this.getGroupedSector([this.responders[index]], 'hover') : this.getResponderModelsWithTheme([this.tooltipSectorMap[index][seriesIndex]], 'hover');\n\n      if (!models.length) {\n        return;\n      }\n\n      this.eventBus.emit('renderHoveredSeries', {\n        models,\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.activatedResponders = this.eventDetectType === 'grouped' ? this.tooltipSectorMap[index] : models;\n      this.eventBus.emit('seriesPointHovered', {\n        models: this.activatedResponders,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  initUpdate(delta) {\n    if (!this.drawModels) {\n      return;\n    }\n\n    const {\n      startAngle,\n      totalAngle\n    } = this.circularAxis;\n    let currentDegree;\n    Object.keys(this.models).forEach(category => {\n      const index = this.models[category].findIndex(({\n        clockwise,\n        degree: {\n          start,\n          end\n        }\n      }) => {\n        currentDegree = clockwise ? startAngle + totalAngle * delta : startAngle - totalAngle * delta;\n        return withinRadian(clockwise, start, end, currentDegree);\n      });\n      this.syncEndAngle(index < 0 ? this.models[category].length : index, category);\n\n      if (index !== -1) {\n        this.drawModels[category][index].degree.end = currentDegree;\n      }\n    });\n  }\n\n  syncEndAngle(index, category) {\n    if (index < 1) {\n      return;\n    }\n\n    for (let i = 0; i < index; i += 1) {\n      const prevTargetEndDegree = this.models[category][i].degree.end;\n\n      if (this.drawModels[category][i].degree.end !== prevTargetEndDegree) {\n        this.drawModels[category][i].degree.end = prevTargetEndDegree;\n      }\n    }\n  }\n\n  initialize() {\n    this.type = 'series';\n    this.name = 'radialBar';\n    this.eventBus.on('selectSeries', this.selectSeries);\n    this.eventBus.on('showTooltip', this.showTooltip);\n    this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n  }\n\n  render(chartState) {\n    var _a, _b;\n\n    const {\n      layout,\n      series,\n      legend,\n      options,\n      theme,\n      stackSeries,\n      scale,\n      radialAxes\n    } = chartState;\n    const categories = (_a = chartState.categories, _a !== null && _a !== void 0 ? _a : []);\n\n    if (!series.radialBar || !stackSeries.radialBar) {\n      throw new Error(message.noDataError(this.name));\n    }\n\n    this.theme = theme.series.radialBar;\n    this.rect = layout.plot;\n    this.activeSeriesMap = getActiveSeriesMap(legend);\n    this.selectable = this.getSelectableOption(options);\n    this.setEventDetectType(options);\n    const initialCategoryMap = categories.reduce((acc, category) => {\n      if (!acc[category]) {\n        acc[category] = [];\n      }\n\n      return acc;\n    }, {});\n    const seriesData = series.radialBar.data;\n    this.circularAxis = radialAxes.circularAxis;\n    const renderOptions = this.makeRenderOptions(radialAxes.verticalAxis, scale.circularAxis, (_b = options) === null || _b === void 0 ? void 0 : _b.series);\n    const {\n      categoryMap,\n      seriesModels\n    } = this.makeSeriesModelData(seriesData, stackSeries.radialBar.stackData, renderOptions, initialCategoryMap);\n    const tooltipData = this.makeTooltipData(seriesModels, categories);\n    this.models = categoryMap;\n\n    if (!this.drawModels) {\n      this.initDrawModels(categoryMap);\n    }\n\n    if (getDataLabelsOptions(options, this.name).visible) {\n      const dataLabelData = seriesModels.reduce((acc, data) => {\n        return [...acc, Object.assign(Object.assign({}, data), {\n          type: 'sector',\n          theme: this.theme.dataLabels\n        })];\n      }, []);\n      this.renderDataLabels(dataLabelData);\n    }\n\n    this.tooltipSectorMap = this.makeTooltipSectorMap(seriesModels, tooltipData);\n    this.responders = this.makeResponders(radialAxes.verticalAxis.radiusRanges, seriesModels, renderOptions, categories, tooltipData);\n  }\n\n  initDrawModels(categoryMap) {\n    this.drawModels = {};\n    Object.keys(categoryMap).forEach(category => {\n      this.drawModels[category] = categoryMap[category].map(m => Object.assign(Object.assign({}, m), {\n        degree: Object.assign(Object.assign({}, m.degree), {\n          end: m.degree.start\n        })\n      }));\n    });\n  }\n\n  makeResponders(radiusRanges, seriesModels, renderOptions, categories, tooltipData) {\n    return this.eventDetectType === 'grouped' ? makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) : seriesModels.map((m, index) => Object.assign(Object.assign({}, m), {\n      data: Object.assign({}, tooltipData[index])\n    }));\n  }\n\n  makeTooltipSectorMap(seriesModels, tooltipData) {\n    return seriesModels.reduce((acc, cur, index) => {\n      const categoryIndex = cur.index;\n\n      if (!acc[categoryIndex]) {\n        acc[categoryIndex] = [];\n      }\n\n      acc[categoryIndex].push(Object.assign(Object.assign({}, cur), {\n        data: Object.assign({}, tooltipData[index])\n      }));\n      return acc;\n    }, {});\n  }\n\n  setEventDetectType(options) {\n    var _a, _b;\n\n    if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n      this.eventDetectType = options.series.eventDetectType;\n    }\n  }\n\n  getBarWidth(tickDistance, axisSize) {\n    const {\n      barWidth\n    } = this.theme;\n    const DEFAULT_PADDING = 5;\n    return barWidth ? Math.min(tickDistance, calculateSizeWithPercentString(axisSize, barWidth)) : tickDistance - DEFAULT_PADDING * 2;\n  }\n\n  makeRenderOptions({\n    centerX,\n    centerY,\n    radiusRanges,\n    tickDistance,\n    axisSize,\n    startAngle,\n    endAngle\n  }, scale, options) {\n    var _a, _b;\n\n    const {\n      limit: {\n        max\n      },\n      stepSize\n    } = scale;\n    const clockwise = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.clockwise, _b !== null && _b !== void 0 ? _b : true);\n    const totalAngle = getTotalAngle(clockwise, startAngle, endAngle);\n    const barWidth = this.getBarWidth(tickDistance, axisSize);\n    const padding = (tickDistance - barWidth) / 2;\n    const scaleMaxLimitValue = max + (totalAngle < DEGREE_360 ? DEGREE_0 : stepSize);\n    return {\n      clockwise,\n      centerX,\n      centerY,\n      radiusRanges: getRadiusRanges(radiusRanges, padding),\n      angleRange: {\n        start: startAngle,\n        end: endAngle\n      },\n      totalAngle,\n      scaleMaxLimitValue,\n      startAngle\n    };\n  }\n\n  makeSeriesModelData(seriesData, stackSeriesData, renderOptions, initialCategoryMap) {\n    const {\n      clockwise,\n      centerX,\n      centerY,\n      radiusRanges,\n      totalAngle,\n      scaleMaxLimitValue,\n      startAngle\n    } = renderOptions;\n    const defaultStartDegree = startAngle;\n    const {\n      lineWidth,\n      strokeStyle\n    } = this.theme;\n    const sectorModels = [];\n    const categories = Object.keys(initialCategoryMap);\n    const categoryMap = deepCopy(initialCategoryMap);\n    stackSeriesData.forEach(({\n      values\n    }, categoryIndex) => {\n      const {\n        inner,\n        outer\n      } = radiusRanges[categoryIndex];\n      values.forEach((value, seriesIndex) => {\n        if (!isNull(value)) {\n          const degree = Math.max(value / scaleMaxLimitValue * totalAngle, 1) * (clockwise ? 1 : -1);\n          const prevModel = sectorModels[sectorModels.length - 1];\n          const startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;\n          const endDegree = clockwise ? Math.min(startDegree + degree, DEGREE_360) : Math.max(startDegree + degree, DEGREE_0);\n          const {\n            name,\n            color: seriesColor\n          } = seriesData[seriesIndex];\n          const color = this.getSeriesColor(name, seriesColor);\n          const sectorModel = {\n            type: 'sector',\n            name,\n            color: color,\n            x: centerX,\n            y: centerY,\n            degree: {\n              start: startDegree,\n              end: endDegree\n            },\n            radius: {\n              inner,\n              outer\n            },\n            value,\n            style: [{\n              strokeStyle\n            }],\n            lineWidth,\n            clockwise,\n            totalAngle,\n            seriesColor,\n            seriesIndex,\n            index: categoryIndex,\n            drawingStartAngle: DEGREE_NEGATIVE_90\n          };\n          categoryMap[categories[categoryIndex]].push(sectorModel);\n          sectorModels.push(sectorModel);\n        }\n      });\n    });\n    return {\n      seriesModels: sectorModels,\n      categoryMap\n    };\n  }\n\n  getSeriesColor(name, color) {\n    const {\n      select,\n      areaOpacity\n    } = this.theme;\n    const active = this.activeSeriesMap[name];\n    const selected = Object.values(this.activeSeriesMap).some(elem => !elem);\n    return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);\n  }\n\n  makeTooltipData(seriesModels, categories) {\n    const tooltipData = [];\n    seriesModels.forEach(({\n      seriesColor,\n      name,\n      value,\n      index\n    }) => {\n      if (!isNull(value)) {\n        tooltipData.push({\n          label: name,\n          color: seriesColor,\n          value: value,\n          category: isNumber(index) ? categories[index] : ''\n        });\n      }\n    });\n    return tooltipData;\n  }\n\n  makeTooltipResponder(responders) {\n    const categories = Object.keys(this.models);\n    return responders.map(responder => Object.assign(Object.assign({}, responder), getRadialAnchorPosition(makeAnchorPositionParam('center', this.models[categories[responder.index]].find(({\n      name\n    }) => name === responder.name)))));\n  }\n\n  getSectorModelsFromResponders(responders) {\n    var _a;\n\n    if (!responders.length) {\n      return [];\n    }\n\n    return _a = this.tooltipSectorMap[responders[0].index], _a !== null && _a !== void 0 ? _a : [];\n  }\n\n  getGroupedSector(responders, type) {\n    const sectorModels = this.getSectorModelsFromResponders(responders);\n    const {\n      color,\n      opacity\n    } = this.theme[type].groupedSector;\n    return sectorModels.length ? responders.map(m => Object.assign(Object.assign({}, m), {\n      color: getRGBA(color, opacity)\n    })) : [];\n  }\n\n  onMousemoveGroupedType(responders) {\n    const sectorModels = this.getSectorModelsFromResponders(responders);\n    this.eventBus.emit('renderHoveredSeries', {\n      models: this.getGroupedSector(responders, 'hover'),\n      name: this.name,\n      eventDetectType: this.eventDetectType\n    });\n    this.activatedResponders = sectorModels;\n  }\n\n  onMousemove({\n    responders\n  }) {\n    if (this.eventDetectType === 'grouped') {\n      this.onMousemoveGroupedType(responders);\n    } else {\n      this.eventBus.emit('renderHoveredSeries', {\n        models: this.getResponderModelsWithTheme(responders, 'hover'),\n        name: this.name\n      });\n      this.activatedResponders = this.makeTooltipResponder(responders);\n    }\n\n    this.eventBus.emit('seriesPointHovered', {\n      models: this.activatedResponders,\n      name: this.name,\n      eventDetectType: this.eventDetectType\n    });\n    this.eventBus.emit('needDraw');\n  }\n\n  onClick({\n    responders\n  }) {\n    if (this.selectable) {\n      let models;\n\n      if (this.eventDetectType === 'grouped') {\n        models = [...this.getGroupedSector(responders, 'select'), ...this.getSectorModelsFromResponders(responders)];\n      } else {\n        models = this.getResponderModelsWithTheme(responders, 'select');\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models,\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    }\n  }\n\n  getResponderModelsWithTheme(responders, type) {\n    const theme = this.theme[type];\n    const lineWidth = theme.lineWidth;\n    const isSameLineWidth = this.theme.lineWidth === lineWidth;\n    const thickness = isSameLineWidth ? 0 : lineWidth * 0.5;\n    return responders.map(m => {\n      var _a, _b;\n\n      return Object.assign(Object.assign({}, m), {\n        color: (_b = (_a = theme) === null || _a === void 0 ? void 0 : _a.color, _b !== null && _b !== void 0 ? _b : m.color),\n        lineWidth: lineWidth,\n        style: [pick(theme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY')],\n        radius: {\n          inner: Math.max(m.radius.inner - thickness, 0),\n          outer: m.radius.outer + thickness\n        }\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/radialBarSeries.js"],"names":["Component","isNumber","pick","isNull","calculateSizeWithPercentString","deepCopy","message","makeGroupedSectorResponderModel","getRadialAnchorPosition","makeAnchorPositionParam","withinRadian","getRadiusRanges","DEGREE_360","DEGREE_0","DEGREE_NEGATIVE_90","getActiveSeriesMap","getDataLabelsOptions","getRGBA","getTotalAngle","isAvailableShowTooltipInfo","RadialBarSeries","constructor","arguments","models","activatedResponders","eventDetectType","onMouseoutComponent","eventBus","emit","name","selectSeries","info","_a","index","seriesIndex","isAvailable","getGroupedSector","responders","getSectorModelsFromResponders","getResponderModelsWithTheme","tooltipSectorMap","length","Error","SELECT_SERIES_API_INDEX_ERROR","showTooltip","initUpdate","delta","drawModels","startAngle","totalAngle","circularAxis","currentDegree","Object","keys","forEach","category","findIndex","clockwise","degree","start","end","syncEndAngle","i","prevTargetEndDegree","initialize","type","on","render","chartState","_b","layout","series","legend","options","theme","stackSeries","scale","radialAxes","categories","radialBar","noDataError","rect","plot","activeSeriesMap","selectable","getSelectableOption","setEventDetectType","initialCategoryMap","reduce","acc","seriesData","data","renderOptions","makeRenderOptions","verticalAxis","categoryMap","seriesModels","makeSeriesModelData","stackData","tooltipData","makeTooltipData","initDrawModels","visible","dataLabelData","assign","dataLabels","renderDataLabels","makeTooltipSectorMap","makeResponders","radiusRanges","map","m","cur","categoryIndex","push","getBarWidth","tickDistance","axisSize","barWidth","DEFAULT_PADDING","Math","min","centerX","centerY","endAngle","limit","max","stepSize","padding","scaleMaxLimitValue","angleRange","stackSeriesData","defaultStartDegree","lineWidth","strokeStyle","sectorModels","values","inner","outer","value","prevModel","startDegree","endDegree","color","seriesColor","getSeriesColor","sectorModel","x","y","radius","style","drawingStartAngle","select","areaOpacity","active","selected","some","elem","restSeries","label","makeTooltipResponder","responder","find","opacity","groupedSector","onMousemoveGroupedType","onMousemove","onClick","isSameLineWidth","thickness"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { isNumber, pick, isNull, calculateSizeWithPercentString, deepCopy, } from \"../helpers/utils\";\nimport { message } from \"../message\";\nimport { makeGroupedSectorResponderModel } from \"../helpers/responders\";\nimport { getRadialAnchorPosition, makeAnchorPositionParam, withinRadian, getRadiusRanges, DEGREE_360, DEGREE_0, DEGREE_NEGATIVE_90, } from \"../helpers/sector\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getTotalAngle } from \"../helpers/pieSeries\";\nimport { isAvailableShowTooltipInfo } from \"../helpers/validation\";\nexport default class RadialBarSeries extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = {};\n        this.activatedResponders = [];\n        this.eventDetectType = 'point';\n        this.onMouseoutComponent = () => {\n            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });\n            this.eventBus.emit('renderHoveredSeries', { models: [], name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n        this.selectSeries = (info) => {\n            var _a;\n            const { index, seriesIndex } = info;\n            const isAvailable = isNumber(index) && (this.eventDetectType === 'grouped' || isNumber(seriesIndex));\n            if (!isAvailable) {\n                return;\n            }\n            const models = this.eventDetectType === 'grouped'\n                ? [\n                    ...this.getGroupedSector([this.responders[index]], 'select'),\n                    ...this.getSectorModelsFromResponders([this.responders[index]]),\n                ]\n                : (_a = this.getResponderModelsWithTheme([this.tooltipSectorMap[index][seriesIndex]], 'select'), (_a !== null && _a !== void 0 ? _a : []));\n            if (!models.length) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models: models,\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.showTooltip = (info) => {\n            const { index, seriesIndex } = info;\n            if (!isAvailableShowTooltipInfo(info, this.eventDetectType, 'radialBar')) {\n                return;\n            }\n            const models = this.eventDetectType === 'grouped'\n                ? this.getGroupedSector([this.responders[index]], 'hover')\n                : this.getResponderModelsWithTheme([this.tooltipSectorMap[index][seriesIndex]], 'hover');\n            if (!models.length) {\n                return;\n            }\n            this.eventBus.emit('renderHoveredSeries', {\n                models,\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.activatedResponders =\n                this.eventDetectType === 'grouped' ? this.tooltipSectorMap[index] : models;\n            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n    }\n    initUpdate(delta) {\n        if (!this.drawModels) {\n            return;\n        }\n        const { startAngle, totalAngle } = this.circularAxis;\n        let currentDegree;\n        Object.keys(this.models).forEach((category) => {\n            const index = this.models[category].findIndex(({ clockwise, degree: { start, end } }) => {\n                currentDegree = clockwise\n                    ? startAngle + totalAngle * delta\n                    : startAngle - totalAngle * delta;\n                return withinRadian(clockwise, start, end, currentDegree);\n            });\n            this.syncEndAngle(index < 0 ? this.models[category].length : index, category);\n            if (index !== -1) {\n                this.drawModels[category][index].degree.end = currentDegree;\n            }\n        });\n    }\n    syncEndAngle(index, category) {\n        if (index < 1) {\n            return;\n        }\n        for (let i = 0; i < index; i += 1) {\n            const prevTargetEndDegree = this.models[category][i].degree.end;\n            if (this.drawModels[category][i].degree.end !== prevTargetEndDegree) {\n                this.drawModels[category][i].degree.end = prevTargetEndDegree;\n            }\n        }\n    }\n    initialize() {\n        this.type = 'series';\n        this.name = 'radialBar';\n        this.eventBus.on('selectSeries', this.selectSeries);\n        this.eventBus.on('showTooltip', this.showTooltip);\n        this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n    }\n    render(chartState) {\n        var _a, _b;\n        const { layout, series, legend, options, theme, stackSeries, scale, radialAxes } = chartState;\n        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));\n        if (!series.radialBar || !stackSeries.radialBar) {\n            throw new Error(message.noDataError(this.name));\n        }\n        this.theme = theme.series.radialBar;\n        this.rect = layout.plot;\n        this.activeSeriesMap = getActiveSeriesMap(legend);\n        this.selectable = this.getSelectableOption(options);\n        this.setEventDetectType(options);\n        const initialCategoryMap = categories.reduce((acc, category) => {\n            if (!acc[category]) {\n                acc[category] = [];\n            }\n            return acc;\n        }, {});\n        const seriesData = series.radialBar.data;\n        this.circularAxis = radialAxes.circularAxis;\n        const renderOptions = this.makeRenderOptions(radialAxes.verticalAxis, scale.circularAxis, (_b = options) === null || _b === void 0 ? void 0 : _b.series);\n        const { categoryMap, seriesModels } = this.makeSeriesModelData(seriesData, stackSeries.radialBar.stackData, renderOptions, initialCategoryMap);\n        const tooltipData = this.makeTooltipData(seriesModels, categories);\n        this.models = categoryMap;\n        if (!this.drawModels) {\n            this.initDrawModels(categoryMap);\n        }\n        if (getDataLabelsOptions(options, this.name).visible) {\n            const dataLabelData = seriesModels.reduce((acc, data) => {\n                return [...acc, Object.assign(Object.assign({}, data), { type: 'sector', theme: this.theme.dataLabels })];\n            }, []);\n            this.renderDataLabels(dataLabelData);\n        }\n        this.tooltipSectorMap = this.makeTooltipSectorMap(seriesModels, tooltipData);\n        this.responders = this.makeResponders(radialAxes.verticalAxis.radiusRanges, seriesModels, renderOptions, categories, tooltipData);\n    }\n    initDrawModels(categoryMap) {\n        this.drawModels = {};\n        Object.keys(categoryMap).forEach((category) => {\n            this.drawModels[category] = categoryMap[category].map((m) => (Object.assign(Object.assign({}, m), { degree: Object.assign(Object.assign({}, m.degree), { end: m.degree.start }) })));\n        });\n    }\n    makeResponders(radiusRanges, seriesModels, renderOptions, categories, tooltipData) {\n        return this.eventDetectType === 'grouped'\n            ? makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories)\n            : seriesModels.map((m, index) => (Object.assign(Object.assign({}, m), { data: Object.assign({}, tooltipData[index]) })));\n    }\n    makeTooltipSectorMap(seriesModels, tooltipData) {\n        return seriesModels.reduce((acc, cur, index) => {\n            const categoryIndex = cur.index;\n            if (!acc[categoryIndex]) {\n                acc[categoryIndex] = [];\n            }\n            acc[categoryIndex].push(Object.assign(Object.assign({}, cur), { data: Object.assign({}, tooltipData[index]) }));\n            return acc;\n        }, {});\n    }\n    setEventDetectType(options) {\n        var _a, _b;\n        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n            this.eventDetectType = options.series.eventDetectType;\n        }\n    }\n    getBarWidth(tickDistance, axisSize) {\n        const { barWidth } = this.theme;\n        const DEFAULT_PADDING = 5;\n        return barWidth\n            ? Math.min(tickDistance, calculateSizeWithPercentString(axisSize, barWidth))\n            : tickDistance - DEFAULT_PADDING * 2;\n    }\n    makeRenderOptions({ centerX, centerY, radiusRanges, tickDistance, axisSize, startAngle, endAngle, }, scale, options) {\n        var _a, _b;\n        const { limit: { max }, stepSize, } = scale;\n        const clockwise = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.clockwise, (_b !== null && _b !== void 0 ? _b : true));\n        const totalAngle = getTotalAngle(clockwise, startAngle, endAngle);\n        const barWidth = this.getBarWidth(tickDistance, axisSize);\n        const padding = (tickDistance - barWidth) / 2;\n        const scaleMaxLimitValue = max + (totalAngle < DEGREE_360 ? DEGREE_0 : stepSize);\n        return {\n            clockwise,\n            centerX,\n            centerY,\n            radiusRanges: getRadiusRanges(radiusRanges, padding),\n            angleRange: {\n                start: startAngle,\n                end: endAngle,\n            },\n            totalAngle,\n            scaleMaxLimitValue,\n            startAngle,\n        };\n    }\n    makeSeriesModelData(seriesData, stackSeriesData, renderOptions, initialCategoryMap) {\n        const { clockwise, centerX, centerY, radiusRanges, totalAngle, scaleMaxLimitValue, startAngle, } = renderOptions;\n        const defaultStartDegree = startAngle;\n        const { lineWidth, strokeStyle } = this.theme;\n        const sectorModels = [];\n        const categories = Object.keys(initialCategoryMap);\n        const categoryMap = deepCopy(initialCategoryMap);\n        stackSeriesData.forEach(({ values }, categoryIndex) => {\n            const { inner, outer } = radiusRanges[categoryIndex];\n            values.forEach((value, seriesIndex) => {\n                if (!isNull(value)) {\n                    const degree = Math.max((value / scaleMaxLimitValue) * totalAngle, 1) * (clockwise ? 1 : -1);\n                    const prevModel = sectorModels[sectorModels.length - 1];\n                    const startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;\n                    const endDegree = clockwise\n                        ? Math.min(startDegree + degree, DEGREE_360)\n                        : Math.max(startDegree + degree, DEGREE_0);\n                    const { name, color: seriesColor } = seriesData[seriesIndex];\n                    const color = this.getSeriesColor(name, seriesColor);\n                    const sectorModel = {\n                        type: 'sector',\n                        name,\n                        color: color,\n                        x: centerX,\n                        y: centerY,\n                        degree: {\n                            start: startDegree,\n                            end: endDegree,\n                        },\n                        radius: {\n                            inner,\n                            outer,\n                        },\n                        value,\n                        style: [{ strokeStyle }],\n                        lineWidth,\n                        clockwise,\n                        totalAngle,\n                        seriesColor,\n                        seriesIndex,\n                        index: categoryIndex,\n                        drawingStartAngle: DEGREE_NEGATIVE_90,\n                    };\n                    categoryMap[categories[categoryIndex]].push(sectorModel);\n                    sectorModels.push(sectorModel);\n                }\n            });\n        });\n        return { seriesModels: sectorModels, categoryMap };\n    }\n    getSeriesColor(name, color) {\n        const { select, areaOpacity } = this.theme;\n        const active = this.activeSeriesMap[name];\n        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);\n        return selected\n            ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity)\n            : getRGBA(color, areaOpacity);\n    }\n    makeTooltipData(seriesModels, categories) {\n        const tooltipData = [];\n        seriesModels.forEach(({ seriesColor, name, value, index }) => {\n            if (!isNull(value)) {\n                tooltipData.push({\n                    label: name,\n                    color: seriesColor,\n                    value: value,\n                    category: isNumber(index) ? categories[index] : '',\n                });\n            }\n        });\n        return tooltipData;\n    }\n    makeTooltipResponder(responders) {\n        const categories = Object.keys(this.models);\n        return responders.map((responder) => (Object.assign(Object.assign({}, responder), getRadialAnchorPosition(makeAnchorPositionParam('center', this.models[categories[responder.index]].find(({ name }) => name === responder.name))))));\n    }\n    getSectorModelsFromResponders(responders) {\n        var _a;\n        if (!responders.length) {\n            return [];\n        }\n        return _a = this.tooltipSectorMap[responders[0].index], (_a !== null && _a !== void 0 ? _a : []);\n    }\n    getGroupedSector(responders, type) {\n        const sectorModels = this.getSectorModelsFromResponders(responders);\n        const { color, opacity } = this.theme[type].groupedSector;\n        return sectorModels.length\n            ? responders.map((m) => (Object.assign(Object.assign({}, m), { color: getRGBA(color, opacity) })))\n            : [];\n    }\n    onMousemoveGroupedType(responders) {\n        const sectorModels = this.getSectorModelsFromResponders(responders);\n        this.eventBus.emit('renderHoveredSeries', {\n            models: this.getGroupedSector(responders, 'hover'),\n            name: this.name,\n            eventDetectType: this.eventDetectType,\n        });\n        this.activatedResponders = sectorModels;\n    }\n    onMousemove({ responders }) {\n        if (this.eventDetectType === 'grouped') {\n            this.onMousemoveGroupedType(responders);\n        }\n        else {\n            this.eventBus.emit('renderHoveredSeries', {\n                models: this.getResponderModelsWithTheme(responders, 'hover'),\n                name: this.name,\n            });\n            this.activatedResponders = this.makeTooltipResponder(responders);\n        }\n        this.eventBus.emit('seriesPointHovered', {\n            models: this.activatedResponders,\n            name: this.name,\n            eventDetectType: this.eventDetectType,\n        });\n        this.eventBus.emit('needDraw');\n    }\n    onClick({ responders }) {\n        if (this.selectable) {\n            let models;\n            if (this.eventDetectType === 'grouped') {\n                models = [\n                    ...this.getGroupedSector(responders, 'select'),\n                    ...this.getSectorModelsFromResponders(responders),\n                ];\n            }\n            else {\n                models = this.getResponderModelsWithTheme(responders, 'select');\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models,\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        }\n    }\n    getResponderModelsWithTheme(responders, type) {\n        const theme = this.theme[type];\n        const lineWidth = theme.lineWidth;\n        const isSameLineWidth = this.theme.lineWidth === lineWidth;\n        const thickness = isSameLineWidth ? 0 : lineWidth * 0.5;\n        return responders.map((m) => {\n            var _a, _b;\n            return (Object.assign(Object.assign({}, m), { color: (_b = (_a = theme) === null || _a === void 0 ? void 0 : _a.color, (_b !== null && _b !== void 0 ? _b : m.color)), lineWidth: lineWidth, style: [\n                    pick(theme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY'),\n                ], radius: {\n                    inner: Math.max(m.radius.inner - thickness, 0),\n                    outer: m.radius.outer + thickness,\n                } }));\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}