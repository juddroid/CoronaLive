{"ast":null,"code":"import { AxisType } from \"../component/axis\";\nimport { divisors, makeTickPixelPositions, getTextHeight, getTextWidth } from \"./calculator\";\nimport { range, isString, isUndefined, isNumber } from \"./utils\";\nimport { ANGLE_CANDIDATES, calculateRotatedWidth, calculateRotatedHeight } from \"./geometric\";\nimport { getDateFormat, formatDate } from \"./formatDate\";\nimport { calculateDegreeToRadian } from \"./sector\";\nimport { DEFAULT_LABEL_TEXT } from \"../brushes/label\";\n\nfunction makeAdjustingIntervalInfo(blockCount, axisWidth, blockSize) {\n  let remainBlockCount;\n  let newBlockCount = Math.floor(axisWidth / blockSize);\n  let intervalInfo = null;\n  const interval = newBlockCount ? Math.floor(blockCount / newBlockCount) : blockCount;\n\n  if (interval > 1) {\n    // remainBlockCount : remaining block count after filling new blocks\n    // | | | | | | | | | | | |  - previous block interval\n    // |     |     |     |      - new block interval\n    //                   |*|*|  - remaining block\n    remainBlockCount = blockCount - interval * newBlockCount;\n\n    if (remainBlockCount >= interval) {\n      newBlockCount += Math.floor(remainBlockCount / interval);\n      remainBlockCount = remainBlockCount % interval;\n    }\n\n    intervalInfo = {\n      blockCount: newBlockCount,\n      remainBlockCount,\n      interval\n    };\n  }\n\n  return intervalInfo;\n}\n\nexport function getAutoAdjustingInterval(count, axisWidth, categories) {\n  var _a;\n\n  const autoInterval = {\n    MIN_WIDTH: 90,\n    MAX_WIDTH: 121,\n    STEP_SIZE: 5\n  };\n  const LABEL_MARGIN = 5;\n\n  if ((_a = categories) === null || _a === void 0 ? void 0 : _a[0]) {\n    const categoryMinWidth = getTextWidth(categories[0]);\n\n    if (categoryMinWidth < axisWidth / count - LABEL_MARGIN) {\n      return 1;\n    }\n  }\n\n  let candidates = [];\n  divisors(count).forEach(interval => {\n    const intervalWidth = interval / count * axisWidth;\n\n    if (intervalWidth >= autoInterval.MIN_WIDTH && intervalWidth <= autoInterval.MAX_WIDTH) {\n      candidates.push({\n        interval,\n        blockCount: Math.floor(count / interval),\n        remainBlockCount: 0\n      });\n    }\n  });\n\n  if (!candidates.length) {\n    const blockSizeRange = range(autoInterval.MIN_WIDTH, autoInterval.MAX_WIDTH, autoInterval.STEP_SIZE);\n    candidates = blockSizeRange.reduce((acc, blockSize) => {\n      const candidate = makeAdjustingIntervalInfo(count, axisWidth, blockSize);\n      return candidate ? [...acc, candidate] : acc;\n    }, []);\n  }\n\n  let tickInterval = 1;\n\n  if (candidates.length) {\n    const candidate = candidates.reduce((acc, cur) => cur.blockCount > acc.blockCount ? cur : acc, {\n      blockCount: 0,\n      interval: 1\n    });\n    tickInterval = candidate.interval;\n  }\n\n  return tickInterval;\n}\nexport function isLabelAxisOnYAxis(series, options) {\n  var _a, _b;\n\n  return !!series.bar || !!series.radialBar || !!series.bullet && !((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.vertical);\n}\nexport function hasBoxTypeSeries(series) {\n  return !!series.column || !!series.bar || !!series.boxPlot || !!series.bullet;\n}\nexport function isPointOnColumn(series, options) {\n  var _a;\n\n  if (hasBoxTypeSeries(series)) {\n    return true;\n  }\n\n  if (series.line || series.area) {\n    return Boolean((_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.pointOnColumn);\n  }\n\n  return false;\n}\nexport function isSeriesUsingRadialAxes(series) {\n  return !!series.radar || !!series.radialBar;\n}\n\nfunction getAxisNameUsingRadialAxes(labelAxisOnYAxis) {\n  return {\n    valueAxisName: labelAxisOnYAxis ? 'circularAxis' : 'verticalAxis',\n    labelAxisName: labelAxisOnYAxis ? 'verticalAxis' : 'circularAxis'\n  };\n}\n\nexport function getAxisName(labelAxisOnYAxis, series) {\n  return isSeriesUsingRadialAxes(series) ? getAxisNameUsingRadialAxes(labelAxisOnYAxis) : {\n    valueAxisName: labelAxisOnYAxis ? 'xAxis' : 'yAxis',\n    labelAxisName: labelAxisOnYAxis ? 'yAxis' : 'xAxis'\n  };\n}\nexport function getSizeKey(labelAxisOnYAxis) {\n  return {\n    valueSizeKey: labelAxisOnYAxis ? 'width' : 'height',\n    labelSizeKey: labelAxisOnYAxis ? 'height' : 'width'\n  };\n}\nexport function getLimitOnAxis(labels) {\n  const values = labels.map(label => Number(label));\n  return {\n    min: Math.min(...values),\n    max: Math.max(...values)\n  };\n}\nexport function hasSecondaryYAxis(options) {\n  var _a;\n\n  return Array.isArray((_a = options) === null || _a === void 0 ? void 0 : _a.yAxis) && options.yAxis.length === 2;\n}\nexport function getYAxisOption(options) {\n  var _a;\n\n  const secondaryYAxis = hasSecondaryYAxis(options);\n  return {\n    yAxis: secondaryYAxis ? options.yAxis[0] : (_a = options) === null || _a === void 0 ? void 0 : _a.yAxis,\n    secondaryYAxis: secondaryYAxis ? options.yAxis[1] : null\n  };\n}\nexport function getValueAxisName(options, seriesName, valueAxisName) {\n  var _a;\n\n  const {\n    secondaryYAxis\n  } = getYAxisOption(options);\n  return ((_a = secondaryYAxis) === null || _a === void 0 ? void 0 : _a.chartType) === seriesName ? 'secondaryYAxis' : valueAxisName;\n}\nexport function getValueAxisNames(options, valueAxisName) {\n  const {\n    yAxis,\n    secondaryYAxis\n  } = getYAxisOption(options);\n  return valueAxisName !== 'xAxis' && secondaryYAxis ? [yAxis.chartType, secondaryYAxis.chartType].map((seriesName, index) => seriesName ? getValueAxisName(options, seriesName, valueAxisName) : ['yAxis', 'secondaryYAxis'][index]) : [valueAxisName];\n}\nexport function getAxisTheme(theme, name) {\n  const {\n    xAxis,\n    yAxis\n  } = theme;\n  let axisTheme;\n\n  if (name === AxisType.X) {\n    axisTheme = xAxis;\n  } else if (Array.isArray(yAxis)) {\n    axisTheme = name === AxisType.Y ? yAxis[0] : yAxis[1];\n  } else {\n    axisTheme = yAxis;\n  }\n\n  return axisTheme;\n}\n\nfunction getRotationDegree(distance, labelWidth, labelHeight) {\n  let degree = 0;\n  ANGLE_CANDIDATES.every(angle => {\n    const compareWidth = calculateRotatedWidth(angle, labelWidth, labelHeight);\n    degree = angle;\n    return compareWidth > distance;\n  });\n  return distance < labelWidth ? degree : 0;\n}\n\nfunction hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, field) {\n  var _a, _b;\n\n  const prevYAxis = previousAxes[field];\n  const yAxis = currentAxes[field];\n\n  if (!prevYAxis && !yAxis) {\n    return false;\n  }\n\n  return ((_a = prevYAxis) === null || _a === void 0 ? void 0 : _a.maxLabelWidth) !== ((_b = yAxis) === null || _b === void 0 ? void 0 : _b.maxLabelWidth);\n}\n\nfunction hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) {\n  return hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'yAxis') || hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'secondaryYAxis');\n}\n\nfunction hasXAxisSizeChanged(previousAxes, currentAxes) {\n  const {\n    maxHeight: prevMaxHeight\n  } = previousAxes.xAxis;\n  const {\n    maxHeight\n  } = currentAxes.xAxis;\n  return prevMaxHeight !== maxHeight;\n}\n\nexport function hasAxesLayoutChanged(previousAxes, currentAxes) {\n  return hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) || hasXAxisSizeChanged(previousAxes, currentAxes);\n}\nexport function getRotatableOption(options) {\n  var _a, _b, _c, _d;\n\n  return _d = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.label) === null || _c === void 0 ? void 0 : _c.rotatable, _d !== null && _d !== void 0 ? _d : true;\n}\nexport function getViewAxisLabels(axisData, axisSize) {\n  const {\n    labels,\n    pointOnColumn,\n    labelDistance,\n    tickDistance,\n    labelInterval,\n    tickInterval,\n    tickCount\n  } = axisData;\n  const relativePositions = makeTickPixelPositions(axisSize, tickCount);\n  const interval = labelInterval === tickInterval ? labelInterval : 1;\n  const labelAdjustment = pointOnColumn ? (labelDistance !== null && labelDistance !== void 0 ? labelDistance : tickDistance * interval) / 2 : 0;\n  return labels.reduce((acc, text, index) => {\n    const offsetPos = relativePositions[index] + labelAdjustment;\n    const needRender = !(index % labelInterval) && offsetPos <= axisSize;\n    return needRender ? [...acc, {\n      offsetPos,\n      text\n    }] : acc;\n  }, []);\n}\nexport function makeTitleOption(title) {\n  if (isUndefined(title)) {\n    return title;\n  }\n\n  const defaultOption = {\n    text: '',\n    offsetX: 0,\n    offsetY: 0\n  };\n  return isString(title) ? Object.assign(Object.assign({}, defaultOption), {\n    text: title\n  }) : Object.assign(Object.assign({}, defaultOption), title);\n}\nexport function makeFormattedCategory(categories, date) {\n  const format = getDateFormat(date);\n  return categories.map(category => format ? formatDate(format, new Date(category)) : category);\n}\nexport function makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable) {\n  const degree = getRotationDegree(distance, maxLabelWidth, maxLabelHeight);\n\n  if (!rotatable || degree === 0) {\n    return {\n      needRotateLabel: false,\n      radian: 0,\n      rotationHeight: maxLabelHeight\n    };\n  }\n\n  return {\n    needRotateLabel: degree > 0,\n    radian: calculateDegreeToRadian(degree, 0),\n    rotationHeight: calculateRotatedHeight(degree, maxLabelWidth, maxLabelHeight)\n  };\n}\nexport function getMaxLabelSize(labels, xMargin, font = DEFAULT_LABEL_TEXT) {\n  const maxLengthLabel = labels.reduce((acc, cur) => acc.length > cur.length ? acc : cur, '');\n  return {\n    maxLabelWidth: getTextWidth(maxLengthLabel, font) + xMargin,\n    maxLabelHeight: getTextHeight(maxLengthLabel, font)\n  };\n}\nexport function getLabelXMargin(axisName, options) {\n  var _a, _b, _c, _d;\n\n  if (axisName === 'xAxis') {\n    return 0;\n  }\n\n  const axisOptions = getYAxisOption(options);\n  return Math.abs((_d = (_c = (_b = (_a = axisOptions) === null || _a === void 0 ? void 0 : _a[axisName]) === null || _b === void 0 ? void 0 : _b.label) === null || _c === void 0 ? void 0 : _c.margin, _d !== null && _d !== void 0 ? _d : 0));\n}\nexport function getInitAxisIntervalData(isLabelAxis, params) {\n  var _a, _b, _c, _d, _e, _f;\n\n  const {\n    axis,\n    categories,\n    layout,\n    isCoordinateTypeChart\n  } = params;\n  const tickInterval = (_b = (_a = axis) === null || _a === void 0 ? void 0 : _a.tick) === null || _b === void 0 ? void 0 : _b.interval;\n  const labelInterval = (_d = (_c = axis) === null || _c === void 0 ? void 0 : _c.label) === null || _d === void 0 ? void 0 : _d.interval;\n  const existIntervalOptions = isNumber(tickInterval) || isNumber(labelInterval);\n  const needAdjustInterval = isLabelAxis && !isNumber((_f = (_e = axis) === null || _e === void 0 ? void 0 : _e.scale) === null || _f === void 0 ? void 0 : _f.stepSize) && !params.shift && !existIntervalOptions && !isCoordinateTypeChart;\n  const initTickInterval = needAdjustInterval ? getInitTickInterval(categories, layout) : 1;\n  const initLabelInterval = needAdjustInterval ? initTickInterval : 1;\n  const axisData = {\n    tickInterval: tickInterval !== null && tickInterval !== void 0 ? tickInterval : initTickInterval,\n    labelInterval: labelInterval !== null && labelInterval !== void 0 ? labelInterval : initLabelInterval\n  };\n  return axisData;\n}\n\nfunction getInitTickInterval(categories, layout) {\n  if (!categories || !layout) {\n    return 1;\n  }\n\n  const {\n    width\n  } = layout.xAxis;\n  const count = categories.length;\n  return getAutoAdjustingInterval(count, width, categories);\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/helpers/axes.js"],"names":["AxisType","divisors","makeTickPixelPositions","getTextHeight","getTextWidth","range","isString","isUndefined","isNumber","ANGLE_CANDIDATES","calculateRotatedWidth","calculateRotatedHeight","getDateFormat","formatDate","calculateDegreeToRadian","DEFAULT_LABEL_TEXT","makeAdjustingIntervalInfo","blockCount","axisWidth","blockSize","remainBlockCount","newBlockCount","Math","floor","intervalInfo","interval","getAutoAdjustingInterval","count","categories","_a","autoInterval","MIN_WIDTH","MAX_WIDTH","STEP_SIZE","LABEL_MARGIN","categoryMinWidth","candidates","forEach","intervalWidth","push","length","blockSizeRange","reduce","acc","candidate","tickInterval","cur","isLabelAxisOnYAxis","series","options","_b","bar","radialBar","bullet","vertical","hasBoxTypeSeries","column","boxPlot","isPointOnColumn","line","area","Boolean","xAxis","pointOnColumn","isSeriesUsingRadialAxes","radar","getAxisNameUsingRadialAxes","labelAxisOnYAxis","valueAxisName","labelAxisName","getAxisName","getSizeKey","valueSizeKey","labelSizeKey","getLimitOnAxis","labels","values","map","label","Number","min","max","hasSecondaryYAxis","Array","isArray","yAxis","getYAxisOption","secondaryYAxis","getValueAxisName","seriesName","chartType","getValueAxisNames","index","getAxisTheme","theme","name","axisTheme","X","Y","getRotationDegree","distance","labelWidth","labelHeight","degree","every","angle","compareWidth","hasYAxisMaxLabelLengthChanged","previousAxes","currentAxes","field","prevYAxis","maxLabelWidth","hasYAxisTypeMaxLabelChanged","hasXAxisSizeChanged","maxHeight","prevMaxHeight","hasAxesLayoutChanged","getRotatableOption","_c","_d","rotatable","getViewAxisLabels","axisData","axisSize","labelDistance","tickDistance","labelInterval","tickCount","relativePositions","labelAdjustment","text","offsetPos","needRender","makeTitleOption","title","defaultOption","offsetX","offsetY","Object","assign","makeFormattedCategory","date","format","category","Date","makeRotationData","maxLabelHeight","needRotateLabel","radian","rotationHeight","getMaxLabelSize","xMargin","font","maxLengthLabel","getLabelXMargin","axisName","axisOptions","abs","margin","getInitAxisIntervalData","isLabelAxis","params","_e","_f","axis","layout","isCoordinateTypeChart","tick","existIntervalOptions","needAdjustInterval","scale","stepSize","shift","initTickInterval","getInitTickInterval","initLabelInterval","width"],"mappings":"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","sourcesContent":["import { AxisType } from \"../component/axis\";\nimport { divisors, makeTickPixelPositions, getTextHeight, getTextWidth, } from \"./calculator\";\nimport { range, isString, isUndefined, isNumber } from \"./utils\";\nimport { ANGLE_CANDIDATES, calculateRotatedWidth, calculateRotatedHeight, } from \"./geometric\";\nimport { getDateFormat, formatDate } from \"./formatDate\";\nimport { calculateDegreeToRadian } from \"./sector\";\nimport { DEFAULT_LABEL_TEXT } from \"../brushes/label\";\nfunction makeAdjustingIntervalInfo(blockCount, axisWidth, blockSize) {\n    let remainBlockCount;\n    let newBlockCount = Math.floor(axisWidth / blockSize);\n    let intervalInfo = null;\n    const interval = newBlockCount ? Math.floor(blockCount / newBlockCount) : blockCount;\n    if (interval > 1) {\n        // remainBlockCount : remaining block count after filling new blocks\n        // | | | | | | | | | | | |  - previous block interval\n        // |     |     |     |      - new block interval\n        //                   |*|*|  - remaining block\n        remainBlockCount = blockCount - interval * newBlockCount;\n        if (remainBlockCount >= interval) {\n            newBlockCount += Math.floor(remainBlockCount / interval);\n            remainBlockCount = remainBlockCount % interval;\n        }\n        intervalInfo = {\n            blockCount: newBlockCount,\n            remainBlockCount,\n            interval,\n        };\n    }\n    return intervalInfo;\n}\nexport function getAutoAdjustingInterval(count, axisWidth, categories) {\n    var _a;\n    const autoInterval = {\n        MIN_WIDTH: 90,\n        MAX_WIDTH: 121,\n        STEP_SIZE: 5,\n    };\n    const LABEL_MARGIN = 5;\n    if ((_a = categories) === null || _a === void 0 ? void 0 : _a[0]) {\n        const categoryMinWidth = getTextWidth(categories[0]);\n        if (categoryMinWidth < axisWidth / count - LABEL_MARGIN) {\n            return 1;\n        }\n    }\n    let candidates = [];\n    divisors(count).forEach((interval) => {\n        const intervalWidth = (interval / count) * axisWidth;\n        if (intervalWidth >= autoInterval.MIN_WIDTH && intervalWidth <= autoInterval.MAX_WIDTH) {\n            candidates.push({ interval, blockCount: Math.floor(count / interval), remainBlockCount: 0 });\n        }\n    });\n    if (!candidates.length) {\n        const blockSizeRange = range(autoInterval.MIN_WIDTH, autoInterval.MAX_WIDTH, autoInterval.STEP_SIZE);\n        candidates = blockSizeRange.reduce((acc, blockSize) => {\n            const candidate = makeAdjustingIntervalInfo(count, axisWidth, blockSize);\n            return candidate ? [...acc, candidate] : acc;\n        }, []);\n    }\n    let tickInterval = 1;\n    if (candidates.length) {\n        const candidate = candidates.reduce((acc, cur) => (cur.blockCount > acc.blockCount ? cur : acc), { blockCount: 0, interval: 1 });\n        tickInterval = candidate.interval;\n    }\n    return tickInterval;\n}\nexport function isLabelAxisOnYAxis(series, options) {\n    var _a, _b;\n    return (!!series.bar ||\n        !!series.radialBar ||\n        (!!series.bullet && !((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.vertical)));\n}\nexport function hasBoxTypeSeries(series) {\n    return !!series.column || !!series.bar || !!series.boxPlot || !!series.bullet;\n}\nexport function isPointOnColumn(series, options) {\n    var _a;\n    if (hasBoxTypeSeries(series)) {\n        return true;\n    }\n    if (series.line || series.area) {\n        return Boolean((_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.pointOnColumn);\n    }\n    return false;\n}\nexport function isSeriesUsingRadialAxes(series) {\n    return !!series.radar || !!series.radialBar;\n}\nfunction getAxisNameUsingRadialAxes(labelAxisOnYAxis) {\n    return {\n        valueAxisName: labelAxisOnYAxis ? 'circularAxis' : 'verticalAxis',\n        labelAxisName: labelAxisOnYAxis ? 'verticalAxis' : 'circularAxis',\n    };\n}\nexport function getAxisName(labelAxisOnYAxis, series) {\n    return isSeriesUsingRadialAxes(series)\n        ? getAxisNameUsingRadialAxes(labelAxisOnYAxis)\n        : {\n            valueAxisName: labelAxisOnYAxis ? 'xAxis' : 'yAxis',\n            labelAxisName: labelAxisOnYAxis ? 'yAxis' : 'xAxis',\n        };\n}\nexport function getSizeKey(labelAxisOnYAxis) {\n    return {\n        valueSizeKey: labelAxisOnYAxis ? 'width' : 'height',\n        labelSizeKey: labelAxisOnYAxis ? 'height' : 'width',\n    };\n}\nexport function getLimitOnAxis(labels) {\n    const values = labels.map((label) => Number(label));\n    return {\n        min: Math.min(...values),\n        max: Math.max(...values),\n    };\n}\nexport function hasSecondaryYAxis(options) {\n    var _a;\n    return Array.isArray((_a = options) === null || _a === void 0 ? void 0 : _a.yAxis) && options.yAxis.length === 2;\n}\nexport function getYAxisOption(options) {\n    var _a;\n    const secondaryYAxis = hasSecondaryYAxis(options);\n    return {\n        yAxis: secondaryYAxis ? options.yAxis[0] : (_a = options) === null || _a === void 0 ? void 0 : _a.yAxis,\n        secondaryYAxis: secondaryYAxis ? options.yAxis[1] : null,\n    };\n}\nexport function getValueAxisName(options, seriesName, valueAxisName) {\n    var _a;\n    const { secondaryYAxis } = getYAxisOption(options);\n    return ((_a = secondaryYAxis) === null || _a === void 0 ? void 0 : _a.chartType) === seriesName ? 'secondaryYAxis' : valueAxisName;\n}\nexport function getValueAxisNames(options, valueAxisName) {\n    const { yAxis, secondaryYAxis } = getYAxisOption(options);\n    return valueAxisName !== 'xAxis' && secondaryYAxis\n        ? [yAxis.chartType, secondaryYAxis.chartType].map((seriesName, index) => seriesName\n            ? getValueAxisName(options, seriesName, valueAxisName)\n            : ['yAxis', 'secondaryYAxis'][index])\n        : [valueAxisName];\n}\nexport function getAxisTheme(theme, name) {\n    const { xAxis, yAxis } = theme;\n    let axisTheme;\n    if (name === AxisType.X) {\n        axisTheme = xAxis;\n    }\n    else if (Array.isArray(yAxis)) {\n        axisTheme = name === AxisType.Y ? yAxis[0] : yAxis[1];\n    }\n    else {\n        axisTheme = yAxis;\n    }\n    return axisTheme;\n}\nfunction getRotationDegree(distance, labelWidth, labelHeight) {\n    let degree = 0;\n    ANGLE_CANDIDATES.every((angle) => {\n        const compareWidth = calculateRotatedWidth(angle, labelWidth, labelHeight);\n        degree = angle;\n        return compareWidth > distance;\n    });\n    return distance < labelWidth ? degree : 0;\n}\nfunction hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, field) {\n    var _a, _b;\n    const prevYAxis = previousAxes[field];\n    const yAxis = currentAxes[field];\n    if (!prevYAxis && !yAxis) {\n        return false;\n    }\n    return ((_a = prevYAxis) === null || _a === void 0 ? void 0 : _a.maxLabelWidth) !== ((_b = yAxis) === null || _b === void 0 ? void 0 : _b.maxLabelWidth);\n}\nfunction hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) {\n    return (hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'yAxis') ||\n        hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'secondaryYAxis'));\n}\nfunction hasXAxisSizeChanged(previousAxes, currentAxes) {\n    const { maxHeight: prevMaxHeight } = previousAxes.xAxis;\n    const { maxHeight } = currentAxes.xAxis;\n    return prevMaxHeight !== maxHeight;\n}\nexport function hasAxesLayoutChanged(previousAxes, currentAxes) {\n    return (hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) ||\n        hasXAxisSizeChanged(previousAxes, currentAxes));\n}\nexport function getRotatableOption(options) {\n    var _a, _b, _c, _d;\n    return _d = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.label) === null || _c === void 0 ? void 0 : _c.rotatable, (_d !== null && _d !== void 0 ? _d : true);\n}\nexport function getViewAxisLabels(axisData, axisSize) {\n    const { labels, pointOnColumn, labelDistance, tickDistance, labelInterval, tickInterval, tickCount, } = axisData;\n    const relativePositions = makeTickPixelPositions(axisSize, tickCount);\n    const interval = labelInterval === tickInterval ? labelInterval : 1;\n    const labelAdjustment = pointOnColumn ? ((labelDistance !== null && labelDistance !== void 0 ? labelDistance : tickDistance * interval)) / 2 : 0;\n    return labels.reduce((acc, text, index) => {\n        const offsetPos = relativePositions[index] + labelAdjustment;\n        const needRender = !(index % labelInterval) && offsetPos <= axisSize;\n        return needRender ? [...acc, { offsetPos, text }] : acc;\n    }, []);\n}\nexport function makeTitleOption(title) {\n    if (isUndefined(title)) {\n        return title;\n    }\n    const defaultOption = { text: '', offsetX: 0, offsetY: 0 };\n    return isString(title) ? Object.assign(Object.assign({}, defaultOption), { text: title }) : Object.assign(Object.assign({}, defaultOption), title);\n}\nexport function makeFormattedCategory(categories, date) {\n    const format = getDateFormat(date);\n    return categories.map((category) => (format ? formatDate(format, new Date(category)) : category));\n}\nexport function makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable) {\n    const degree = getRotationDegree(distance, maxLabelWidth, maxLabelHeight);\n    if (!rotatable || degree === 0) {\n        return {\n            needRotateLabel: false,\n            radian: 0,\n            rotationHeight: maxLabelHeight,\n        };\n    }\n    return {\n        needRotateLabel: degree > 0,\n        radian: calculateDegreeToRadian(degree, 0),\n        rotationHeight: calculateRotatedHeight(degree, maxLabelWidth, maxLabelHeight),\n    };\n}\nexport function getMaxLabelSize(labels, xMargin, font = DEFAULT_LABEL_TEXT) {\n    const maxLengthLabel = labels.reduce((acc, cur) => (acc.length > cur.length ? acc : cur), '');\n    return {\n        maxLabelWidth: getTextWidth(maxLengthLabel, font) + xMargin,\n        maxLabelHeight: getTextHeight(maxLengthLabel, font),\n    };\n}\nexport function getLabelXMargin(axisName, options) {\n    var _a, _b, _c, _d;\n    if (axisName === 'xAxis') {\n        return 0;\n    }\n    const axisOptions = getYAxisOption(options);\n    return Math.abs((_d = (_c = (_b = (_a = axisOptions) === null || _a === void 0 ? void 0 : _a[axisName]) === null || _b === void 0 ? void 0 : _b.label) === null || _c === void 0 ? void 0 : _c.margin, (_d !== null && _d !== void 0 ? _d : 0)));\n}\nexport function getInitAxisIntervalData(isLabelAxis, params) {\n    var _a, _b, _c, _d, _e, _f;\n    const { axis, categories, layout, isCoordinateTypeChart } = params;\n    const tickInterval = (_b = (_a = axis) === null || _a === void 0 ? void 0 : _a.tick) === null || _b === void 0 ? void 0 : _b.interval;\n    const labelInterval = (_d = (_c = axis) === null || _c === void 0 ? void 0 : _c.label) === null || _d === void 0 ? void 0 : _d.interval;\n    const existIntervalOptions = isNumber(tickInterval) || isNumber(labelInterval);\n    const needAdjustInterval = isLabelAxis &&\n        !isNumber((_f = (_e = axis) === null || _e === void 0 ? void 0 : _e.scale) === null || _f === void 0 ? void 0 : _f.stepSize) &&\n        !params.shift &&\n        !existIntervalOptions &&\n        !isCoordinateTypeChart;\n    const initTickInterval = needAdjustInterval ? getInitTickInterval(categories, layout) : 1;\n    const initLabelInterval = needAdjustInterval ? initTickInterval : 1;\n    const axisData = {\n        tickInterval: (tickInterval !== null && tickInterval !== void 0 ? tickInterval : initTickInterval),\n        labelInterval: (labelInterval !== null && labelInterval !== void 0 ? labelInterval : initLabelInterval),\n    };\n    return axisData;\n}\nfunction getInitTickInterval(categories, layout) {\n    if (!categories || !layout) {\n        return 1;\n    }\n    const { width } = layout.xAxis;\n    const count = categories.length;\n    return getAutoAdjustingInterval(count, width, categories);\n}\n"]},"metadata":{},"sourceType":"module"}