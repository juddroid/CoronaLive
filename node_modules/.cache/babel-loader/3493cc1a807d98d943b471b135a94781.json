{"ast":null,"code":"import { label, bubbleLabel } from \"./label\";\nimport { getTextHeight, getTextWidth } from \"../helpers/calculator\";\nimport { line } from \"./basic\";\nimport { getFont } from \"../helpers/style\";\nimport { pick, includes } from \"../helpers/utils\";\nexport function dataLabel(ctx, model) {\n  var _a;\n\n  const {\n    x,\n    y,\n    text,\n    textAlign,\n    textBaseline,\n    opacity,\n    callout,\n    theme,\n    radian\n  } = model;\n  const {\n    color,\n    textBubble\n  } = theme;\n  const font = getFont(theme);\n  const textStyle = {\n    textAlign,\n    textBaseline,\n    font,\n    fillStyle: color\n  };\n  const textStrokeStyle = getTextStrokeStyle(theme);\n\n  if (callout) {\n    const {\n      theme: {\n        lineWidth,\n        lineColor\n      }\n    } = callout;\n    line(ctx, Object.assign(Object.assign({\n      type: 'line'\n    }, pick(callout, 'x', 'y', 'x2', 'y2')), {\n      strokeStyle: lineColor,\n      lineWidth\n    }));\n  }\n\n  if ((_a = textBubble) === null || _a === void 0 ? void 0 : _a.visible) {\n    drawBubbleLabel(ctx, model);\n    return;\n  }\n\n  label(ctx, {\n    type: 'label',\n    x,\n    y,\n    text,\n    style: [textStyle],\n    stroke: [textStrokeStyle],\n    opacity,\n    radian\n  });\n}\nexport function drawBubbleLabel(ctx, model) {\n  const {\n    text,\n    theme,\n    radian = 0\n  } = model;\n  const {\n    color,\n    textStrokeColor\n  } = theme;\n  const font = getFont(theme);\n  const bubbleRect = getBubbleRect(model);\n  const {\n    x,\n    y,\n    width,\n    height\n  } = bubbleRect;\n  bubbleLabel(ctx, {\n    type: 'bubbleLabel',\n    radian,\n    rotationPosition: {\n      x: model.x,\n      y: model.y\n    },\n    bubble: bubbleRect,\n    label: {\n      x: x + width / 2,\n      y: y + height / 2,\n      text,\n      style: [{\n        font,\n        fillStyle: color,\n        textAlign: 'center',\n        textBaseline: 'middle'\n      }],\n      strokeStyle: textStrokeColor\n    }\n  });\n}\nexport function getBubbleArrowPoints(direction, {\n  x,\n  y\n}, arrowPointTheme) {\n  const width = arrowPointTheme.width;\n  const height = arrowPointTheme.height;\n  let points = [];\n\n  if (direction === 'top') {\n    points = [{\n      x: x - width / 2,\n      y: y + height\n    }, {\n      x,\n      y\n    }, {\n      x: x + width / 2,\n      y: y + height\n    }];\n  } else if (direction === 'bottom') {\n    points = [{\n      x: x + width / 2,\n      y: y - height\n    }, {\n      x,\n      y\n    }, {\n      x: x - width / 2,\n      y: y - height\n    }];\n  } else if (direction === 'right') {\n    points = [{\n      x: x - height,\n      y: y - width / 2\n    }, {\n      x,\n      y\n    }, {\n      x: x - height,\n      y: y + width / 2\n    }];\n  } else if (direction === 'left') {\n    points = [{\n      x: x + height,\n      y: y + width / 2\n    }, {\n      x,\n      y\n    }, {\n      x: x + height,\n      y: y - width / 2\n    }];\n  }\n\n  return points;\n}\n\nfunction getBubbleRect(model) {\n  const {\n    text,\n    theme,\n    textAlign,\n    textBaseline\n  } = model;\n  const font = getFont(theme);\n  const {\n    arrow,\n    paddingX,\n    paddingY,\n    borderRadius,\n    borderColor,\n    borderWidth,\n    backgroundColor,\n    shadowBlur,\n    shadowOffsetX,\n    shadowOffsetY,\n    shadowColor\n  } = theme.textBubble;\n  const labelWidth = getTextWidth(text, font);\n  const width = labelWidth + paddingX * 2;\n  const height = getTextHeight(text, font) + paddingY * 2;\n  let {\n    x,\n    y\n  } = model;\n\n  if (textAlign === 'center') {\n    x -= width / 2;\n  } else if (includes(['right', 'end'], textAlign)) {\n    x -= width;\n  }\n\n  if (textBaseline === 'middle') {\n    y -= height / 2;\n  } else if (textBaseline === 'bottom') {\n    y -= height;\n  }\n\n  const rect = {\n    x,\n    y,\n    width,\n    height\n  };\n  return Object.assign(Object.assign(Object.assign({}, rect), {\n    radius: borderRadius,\n    lineWidth: borderWidth,\n    fill: backgroundColor,\n    strokeStyle: borderColor,\n    style: [{\n      shadowBlur,\n      shadowOffsetX,\n      shadowOffsetY,\n      shadowColor\n    }]\n  }), getArrowInfo(rect, textAlign, textBaseline, arrow));\n}\n\nfunction getArrowInfo(rect, textAlign, textBaseline, theme) {\n  var _a, _b;\n\n  if (!((_a = theme) === null || _a === void 0 ? void 0 : _a.visible)) {\n    return null;\n  }\n\n  const arrowHeight = theme.height;\n  const {\n    width,\n    height\n  } = rect;\n  const direction = (_b = theme.direction, _b !== null && _b !== void 0 ? _b : getArrowDirection(textAlign, textBaseline));\n  let {\n    x: boxX,\n    y: boxY\n  } = rect;\n  let {\n    x: pointX,\n    y: pointY\n  } = rect;\n\n  if (direction === 'top') {\n    boxY += arrowHeight;\n  } else if (direction === 'bottom') {\n    boxY -= arrowHeight;\n    pointY += height;\n  } else if (direction === 'right') {\n    boxX -= arrowHeight;\n    pointX += width;\n  } else if (direction === 'left') {\n    boxX += arrowHeight;\n  }\n\n  if (textAlign === 'center') {\n    pointX = rect.x + width / 2;\n  } else if (textBaseline === 'middle') {\n    pointY = rect.y + height / 2;\n  }\n\n  return {\n    direction,\n    points: getBubbleArrowPoints(direction, {\n      x: pointX,\n      y: pointY\n    }, theme),\n    x: boxX,\n    y: boxY\n  };\n}\n\nfunction getArrowDirection(textAlign, textBaseline) {\n  let direction = 'top';\n\n  if (textAlign === 'center' && textBaseline === 'top') {\n    direction = 'top';\n  } else if (textAlign === 'center' && textBaseline === 'bottom') {\n    direction = 'bottom';\n  } else if (textBaseline === 'middle' && textAlign === 'right') {\n    direction = 'right';\n  } else if (textBaseline === 'middle' && textAlign === 'left') {\n    direction = 'left';\n  }\n\n  return direction;\n}\n\nfunction getTextStrokeStyle(theme) {\n  const {\n    textStrokeColor\n  } = theme;\n  const textStrokeStyle = pick(theme, 'lineWidth', 'shadowColor', 'shadowBlur');\n\n  if (textStrokeColor) {\n    textStrokeStyle.strokeStyle = textStrokeColor;\n  }\n\n  return textStrokeStyle;\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js"],"names":["label","bubbleLabel","getTextHeight","getTextWidth","line","getFont","pick","includes","dataLabel","ctx","model","_a","x","y","text","textAlign","textBaseline","opacity","callout","theme","radian","color","textBubble","font","textStyle","fillStyle","textStrokeStyle","getTextStrokeStyle","lineWidth","lineColor","Object","assign","type","strokeStyle","visible","drawBubbleLabel","style","stroke","textStrokeColor","bubbleRect","getBubbleRect","width","height","rotationPosition","bubble","getBubbleArrowPoints","direction","arrowPointTheme","points","arrow","paddingX","paddingY","borderRadius","borderColor","borderWidth","backgroundColor","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","labelWidth","rect","radius","fill","getArrowInfo","_b","arrowHeight","getArrowDirection","boxX","boxY","pointX","pointY"],"mappings":"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","sourcesContent":["import { label, bubbleLabel } from \"./label\";\nimport { getTextHeight, getTextWidth } from \"../helpers/calculator\";\nimport { line } from \"./basic\";\nimport { getFont } from \"../helpers/style\";\nimport { pick, includes } from \"../helpers/utils\";\nexport function dataLabel(ctx, model) {\n    var _a;\n    const { x, y, text, textAlign, textBaseline, opacity, callout, theme, radian } = model;\n    const { color, textBubble } = theme;\n    const font = getFont(theme);\n    const textStyle = { textAlign, textBaseline, font, fillStyle: color };\n    const textStrokeStyle = getTextStrokeStyle(theme);\n    if (callout) {\n        const { theme: { lineWidth, lineColor }, } = callout;\n        line(ctx, Object.assign(Object.assign({ type: 'line' }, pick(callout, 'x', 'y', 'x2', 'y2')), { strokeStyle: lineColor, lineWidth }));\n    }\n    if ((_a = textBubble) === null || _a === void 0 ? void 0 : _a.visible) {\n        drawBubbleLabel(ctx, model);\n        return;\n    }\n    label(ctx, {\n        type: 'label',\n        x,\n        y,\n        text,\n        style: [textStyle],\n        stroke: [textStrokeStyle],\n        opacity,\n        radian,\n    });\n}\nexport function drawBubbleLabel(ctx, model) {\n    const { text, theme, radian = 0 } = model;\n    const { color, textStrokeColor } = theme;\n    const font = getFont(theme);\n    const bubbleRect = getBubbleRect(model);\n    const { x, y, width, height } = bubbleRect;\n    bubbleLabel(ctx, {\n        type: 'bubbleLabel',\n        radian,\n        rotationPosition: { x: model.x, y: model.y },\n        bubble: bubbleRect,\n        label: {\n            x: x + width / 2,\n            y: y + height / 2,\n            text,\n            style: [{ font, fillStyle: color, textAlign: 'center', textBaseline: 'middle' }],\n            strokeStyle: textStrokeColor,\n        },\n    });\n}\nexport function getBubbleArrowPoints(direction, { x, y }, arrowPointTheme) {\n    const width = arrowPointTheme.width;\n    const height = arrowPointTheme.height;\n    let points = [];\n    if (direction === 'top') {\n        points = [\n            { x: x - width / 2, y: y + height },\n            { x, y },\n            { x: x + width / 2, y: y + height },\n        ];\n    }\n    else if (direction === 'bottom') {\n        points = [\n            { x: x + width / 2, y: y - height },\n            { x, y },\n            { x: x - width / 2, y: y - height },\n        ];\n    }\n    else if (direction === 'right') {\n        points = [\n            { x: x - height, y: y - width / 2 },\n            { x, y },\n            { x: x - height, y: y + width / 2 },\n        ];\n    }\n    else if (direction === 'left') {\n        points = [\n            { x: x + height, y: y + width / 2 },\n            { x, y },\n            { x: x + height, y: y - width / 2 },\n        ];\n    }\n    return points;\n}\nfunction getBubbleRect(model) {\n    const { text, theme, textAlign, textBaseline } = model;\n    const font = getFont(theme);\n    const { arrow, paddingX, paddingY, borderRadius, borderColor, borderWidth, backgroundColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowColor, } = theme.textBubble;\n    const labelWidth = getTextWidth(text, font);\n    const width = labelWidth + paddingX * 2;\n    const height = getTextHeight(text, font) + paddingY * 2;\n    let { x, y } = model;\n    if (textAlign === 'center') {\n        x -= width / 2;\n    }\n    else if (includes(['right', 'end'], textAlign)) {\n        x -= width;\n    }\n    if (textBaseline === 'middle') {\n        y -= height / 2;\n    }\n    else if (textBaseline === 'bottom') {\n        y -= height;\n    }\n    const rect = { x, y, width, height };\n    return Object.assign(Object.assign(Object.assign({}, rect), { radius: borderRadius, lineWidth: borderWidth, fill: backgroundColor, strokeStyle: borderColor, style: [\n            {\n                shadowBlur,\n                shadowOffsetX,\n                shadowOffsetY,\n                shadowColor,\n            },\n        ] }), getArrowInfo(rect, textAlign, textBaseline, arrow));\n}\nfunction getArrowInfo(rect, textAlign, textBaseline, theme) {\n    var _a, _b;\n    if (!((_a = theme) === null || _a === void 0 ? void 0 : _a.visible)) {\n        return null;\n    }\n    const arrowHeight = theme.height;\n    const { width, height } = rect;\n    const direction = (_b = theme.direction, (_b !== null && _b !== void 0 ? _b : getArrowDirection(textAlign, textBaseline)));\n    let { x: boxX, y: boxY } = rect;\n    let { x: pointX, y: pointY } = rect;\n    if (direction === 'top') {\n        boxY += arrowHeight;\n    }\n    else if (direction === 'bottom') {\n        boxY -= arrowHeight;\n        pointY += height;\n    }\n    else if (direction === 'right') {\n        boxX -= arrowHeight;\n        pointX += width;\n    }\n    else if (direction === 'left') {\n        boxX += arrowHeight;\n    }\n    if (textAlign === 'center') {\n        pointX = rect.x + width / 2;\n    }\n    else if (textBaseline === 'middle') {\n        pointY = rect.y + height / 2;\n    }\n    return {\n        direction,\n        points: getBubbleArrowPoints(direction, { x: pointX, y: pointY }, theme),\n        x: boxX,\n        y: boxY,\n    };\n}\nfunction getArrowDirection(textAlign, textBaseline) {\n    let direction = 'top';\n    if (textAlign === 'center' && textBaseline === 'top') {\n        direction = 'top';\n    }\n    else if (textAlign === 'center' && textBaseline === 'bottom') {\n        direction = 'bottom';\n    }\n    else if (textBaseline === 'middle' && textAlign === 'right') {\n        direction = 'right';\n    }\n    else if (textBaseline === 'middle' && textAlign === 'left') {\n        direction = 'left';\n    }\n    return direction;\n}\nfunction getTextStrokeStyle(theme) {\n    const { textStrokeColor } = theme;\n    const textStrokeStyle = pick(theme, 'lineWidth', 'shadowColor', 'shadowBlur');\n    if (textStrokeColor) {\n        textStrokeStyle.strokeStyle = textStrokeColor;\n    }\n    return textStrokeStyle;\n}\n"]},"metadata":{},"sourceType":"module"}