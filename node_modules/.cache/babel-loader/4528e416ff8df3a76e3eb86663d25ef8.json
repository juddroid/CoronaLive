{"ast":null,"code":"import { getDistance } from \"./calculator\";\nimport { range } from \"./utils\";\nimport { getRadiusRanges } from \"./sector\"; // eslint-disable-next-line complexity\n\nexport function isSameSeriesResponder({\n  models,\n  comparisonModel,\n  name,\n  eventDetectType\n}) {\n  switch (name) {\n    case 'heatmap':\n      return isClickSameNameResponder(models, comparisonModel);\n\n    case 'bullet':\n      return eventDetectType === 'grouped' ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameNameResponder(models, comparisonModel);\n\n    case 'radar':\n    case 'bubble':\n    case 'scatter':\n    case 'area':\n    case 'line':\n      return isClickSameCircleResponder(models, comparisonModel);\n\n    case 'pie':\n      return isClickSameDataResponder(models, comparisonModel);\n\n    case 'column':\n    case 'bar':\n      return eventDetectType === 'grouped' ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameDataResponder(models, comparisonModel);\n\n    case 'boxPlot':\n      return eventDetectType === 'grouped' ? isClickSameDataResponder(models, comparisonModel) : isClickSameBoxPlotDataResponder(models, comparisonModel);\n\n    case 'treemap':\n      return isClickSameLabelResponder(models, comparisonModel);\n\n    default:\n      return false;\n  }\n}\nexport function getNearestResponder(responders, mousePosition, rect) {\n  let minDistance = Infinity;\n  let result = [];\n  responders.forEach(responder => {\n    const {\n      x,\n      y,\n      radius\n    } = responder;\n    const responderPoint = {\n      x: x + rect.x,\n      y: y + rect.y\n    };\n    const distance = getDistance(responderPoint, mousePosition);\n\n    if (minDistance > distance) {\n      minDistance = distance;\n      result = [responder];\n    } else if (minDistance === distance) {\n      if (result.length && result[0].radius > radius) {\n        result = [responder];\n      } else {\n        result.push(responder);\n      }\n    }\n  });\n  return result;\n}\nexport function makeRectResponderModel(rect, axis, categories, vertical = true) {\n  const {\n    pointOnColumn,\n    tickCount,\n    tickDistance\n  } = axis;\n  const {\n    width,\n    height\n  } = rect;\n  const halfDetectAreaIndex = pointOnColumn ? [] : [0, tickCount - 1];\n  const halfSize = tickDistance / 2;\n  return range(0, tickCount).map(index => {\n    const half = halfDetectAreaIndex.includes(index);\n    const size = half ? halfSize : tickDistance;\n    let startPos = 0;\n\n    if (index !== 0) {\n      startPos += pointOnColumn ? tickDistance * index : halfSize + tickDistance * (index - 1);\n    }\n\n    return {\n      type: 'rect',\n      y: vertical ? 0 : startPos,\n      height: vertical ? height : size,\n      x: vertical ? startPos : 0,\n      width: vertical ? size : width,\n      index,\n      label: categories[index]\n    };\n  });\n}\nexport function makeTooltipCircleMap(seriesCircleModel, tooltipDataArr) {\n  const dataMap = tooltipDataArr.reduce((acc, cur) => {\n    const {\n      index,\n      seriesIndex\n    } = cur;\n\n    if (!acc[seriesIndex]) {\n      acc[seriesIndex] = [];\n    }\n\n    acc[seriesIndex][index] = cur;\n    return acc;\n  }, []);\n  return seriesCircleModel.reduce((acc, model) => {\n    const {\n      seriesIndex,\n      index\n    } = model;\n    const data = dataMap[seriesIndex][index];\n    const {\n      category\n    } = data;\n\n    if (!category) {\n      return acc;\n    }\n\n    if (!acc[category]) {\n      acc[category] = [];\n    }\n\n    acc[category].push(Object.assign(Object.assign({}, model), {\n      data\n    }));\n    return acc;\n  }, {});\n}\nexport function getDeepestNode(responders) {\n  return responders.reduce((acc, responder) => {\n    if (!acc.length || responder.depth > acc[0].depth) {\n      return [responder];\n    }\n\n    return acc;\n  }, []);\n}\nexport function isClickSameNameResponder(responders, selectedSeries) {\n  var _a;\n\n  return responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders[0].name === selectedSeries[0].name;\n}\nexport function isClickSameCircleResponder(responders, selectedSeries) {\n  var _a;\n\n  let same = false;\n\n  if (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders.length === selectedSeries.length) {\n    same = responders.reduce((acc, cur, idx) => {\n      return acc && cur.seriesIndex === selectedSeries[idx].seriesIndex && cur.index === selectedSeries[idx].index;\n    }, true);\n  }\n\n  return same;\n}\nexport function isClickSameDataResponder(responders, selectedSeries) {\n  var _a;\n\n  let same = false;\n\n  if (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders.length === selectedSeries.length) {\n    same = responders.reduce((acc, cur, idx) => {\n      var _a, _b, _c, _d;\n\n      return acc && ((_a = cur.data) === null || _a === void 0 ? void 0 : _a.label) === ((_b = selectedSeries[idx].data) === null || _b === void 0 ? void 0 : _b.label) && ((_c = cur.data) === null || _c === void 0 ? void 0 : _c.category) === ((_d = selectedSeries[idx].data) === null || _d === void 0 ? void 0 : _d.category);\n    }, true);\n  }\n\n  return same;\n}\nexport function isClickSameLabelResponder(responders, selectedSeries) {\n  var _a;\n\n  return responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders[0].label === selectedSeries[0].label;\n}\nexport function isClickSameGroupedRectResponder(responders, selectedSeries) {\n  var _a;\n\n  return responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders[0].index === selectedSeries[0].index;\n}\nexport function isClickSameBoxPlotDataResponder(responders, selectedSeries) {\n  var _a, _b, _c, _d, _e;\n\n  let same = false;\n\n  if (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length)) {\n    const {\n      type,\n      data\n    } = responders[0];\n    same = type === selectedSeries[0].type && ((_b = data) === null || _b === void 0 ? void 0 : _b.label) === ((_c = selectedSeries[0].data) === null || _c === void 0 ? void 0 : _c.label) && ((_d = data) === null || _d === void 0 ? void 0 : _d.category) === ((_e = selectedSeries[0].data) === null || _e === void 0 ? void 0 : _e.category);\n  }\n\n  return same;\n}\nexport function makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) {\n  const {\n    centerX,\n    centerY,\n    angleRange: {\n      start,\n      end\n    },\n    clockwise\n  } = renderOptions;\n  return getRadiusRanges(radiusRanges, 0).map((radius, index) => ({\n    type: 'sector',\n    x: centerX,\n    y: centerY,\n    degree: {\n      start,\n      end\n    },\n    radius,\n    name: categories[index],\n    clockwise,\n    index\n  }));\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/helpers/responders.js"],"names":["getDistance","range","getRadiusRanges","isSameSeriesResponder","models","comparisonModel","name","eventDetectType","isClickSameNameResponder","isClickSameGroupedRectResponder","isClickSameCircleResponder","isClickSameDataResponder","isClickSameBoxPlotDataResponder","isClickSameLabelResponder","getNearestResponder","responders","mousePosition","rect","minDistance","Infinity","result","forEach","responder","x","y","radius","responderPoint","distance","length","push","makeRectResponderModel","axis","categories","vertical","pointOnColumn","tickCount","tickDistance","width","height","halfDetectAreaIndex","halfSize","map","index","half","includes","size","startPos","type","label","makeTooltipCircleMap","seriesCircleModel","tooltipDataArr","dataMap","reduce","acc","cur","seriesIndex","model","data","category","Object","assign","getDeepestNode","depth","selectedSeries","_a","same","idx","_b","_c","_d","_e","makeGroupedSectorResponderModel","radiusRanges","renderOptions","centerX","centerY","angleRange","start","end","clockwise","degree"],"mappings":"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","sourcesContent":["import { getDistance } from \"./calculator\";\nimport { range } from \"./utils\";\nimport { getRadiusRanges } from \"./sector\";\n// eslint-disable-next-line complexity\nexport function isSameSeriesResponder({ models, comparisonModel, name, eventDetectType, }) {\n    switch (name) {\n        case 'heatmap':\n            return isClickSameNameResponder(models, comparisonModel);\n        case 'bullet':\n            return eventDetectType === 'grouped'\n                ? isClickSameGroupedRectResponder(models, comparisonModel)\n                : isClickSameNameResponder(models, comparisonModel);\n        case 'radar':\n        case 'bubble':\n        case 'scatter':\n        case 'area':\n        case 'line':\n            return isClickSameCircleResponder(models, comparisonModel);\n        case 'pie':\n            return isClickSameDataResponder(models, comparisonModel);\n        case 'column':\n        case 'bar':\n            return eventDetectType === 'grouped'\n                ? isClickSameGroupedRectResponder(models, comparisonModel)\n                : isClickSameDataResponder(models, comparisonModel);\n        case 'boxPlot':\n            return eventDetectType === 'grouped'\n                ? isClickSameDataResponder(models, comparisonModel)\n                : isClickSameBoxPlotDataResponder(models, comparisonModel);\n        case 'treemap':\n            return isClickSameLabelResponder(models, comparisonModel);\n        default:\n            return false;\n    }\n}\nexport function getNearestResponder(responders, mousePosition, rect) {\n    let minDistance = Infinity;\n    let result = [];\n    responders.forEach((responder) => {\n        const { x, y, radius } = responder;\n        const responderPoint = { x: x + rect.x, y: y + rect.y };\n        const distance = getDistance(responderPoint, mousePosition);\n        if (minDistance > distance) {\n            minDistance = distance;\n            result = [responder];\n        }\n        else if (minDistance === distance) {\n            if (result.length && result[0].radius > radius) {\n                result = [responder];\n            }\n            else {\n                result.push(responder);\n            }\n        }\n    });\n    return result;\n}\nexport function makeRectResponderModel(rect, axis, categories, vertical = true) {\n    const { pointOnColumn, tickCount, tickDistance } = axis;\n    const { width, height } = rect;\n    const halfDetectAreaIndex = pointOnColumn ? [] : [0, tickCount - 1];\n    const halfSize = tickDistance / 2;\n    return range(0, tickCount).map((index) => {\n        const half = halfDetectAreaIndex.includes(index);\n        const size = half ? halfSize : tickDistance;\n        let startPos = 0;\n        if (index !== 0) {\n            startPos += pointOnColumn ? tickDistance * index : halfSize + tickDistance * (index - 1);\n        }\n        return {\n            type: 'rect',\n            y: vertical ? 0 : startPos,\n            height: vertical ? height : size,\n            x: vertical ? startPos : 0,\n            width: vertical ? size : width,\n            index,\n            label: categories[index],\n        };\n    });\n}\nexport function makeTooltipCircleMap(seriesCircleModel, tooltipDataArr) {\n    const dataMap = tooltipDataArr.reduce((acc, cur) => {\n        const { index, seriesIndex } = cur;\n        if (!acc[seriesIndex]) {\n            acc[seriesIndex] = [];\n        }\n        acc[seriesIndex][index] = cur;\n        return acc;\n    }, []);\n    return seriesCircleModel.reduce((acc, model) => {\n        const { seriesIndex, index } = model;\n        const data = dataMap[seriesIndex][index];\n        const { category } = data;\n        if (!category) {\n            return acc;\n        }\n        if (!acc[category]) {\n            acc[category] = [];\n        }\n        acc[category].push(Object.assign(Object.assign({}, model), { data }));\n        return acc;\n    }, {});\n}\nexport function getDeepestNode(responders) {\n    return responders.reduce((acc, responder) => {\n        if (!acc.length || responder.depth > acc[0].depth) {\n            return [responder];\n        }\n        return acc;\n    }, []);\n}\nexport function isClickSameNameResponder(responders, selectedSeries) {\n    var _a;\n    return (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders[0].name === selectedSeries[0].name);\n}\nexport function isClickSameCircleResponder(responders, selectedSeries) {\n    var _a;\n    let same = false;\n    if (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders.length === selectedSeries.length) {\n        same = responders.reduce((acc, cur, idx) => {\n            return (acc &&\n                cur.seriesIndex === selectedSeries[idx].seriesIndex &&\n                cur.index === selectedSeries[idx].index);\n        }, true);\n    }\n    return same;\n}\nexport function isClickSameDataResponder(responders, selectedSeries) {\n    var _a;\n    let same = false;\n    if (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders.length === selectedSeries.length) {\n        same = responders.reduce((acc, cur, idx) => {\n            var _a, _b, _c, _d;\n            return (acc &&\n                ((_a = cur.data) === null || _a === void 0 ? void 0 : _a.label) === ((_b = selectedSeries[idx].data) === null || _b === void 0 ? void 0 : _b.label) &&\n                ((_c = cur.data) === null || _c === void 0 ? void 0 : _c.category) === ((_d = selectedSeries[idx].data) === null || _d === void 0 ? void 0 : _d.category));\n        }, true);\n    }\n    return same;\n}\nexport function isClickSameLabelResponder(responders, selectedSeries) {\n    var _a;\n    return (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders[0].label === selectedSeries[0].label);\n}\nexport function isClickSameGroupedRectResponder(responders, selectedSeries) {\n    var _a;\n    return (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders[0].index === selectedSeries[0].index);\n}\nexport function isClickSameBoxPlotDataResponder(responders, selectedSeries) {\n    var _a, _b, _c, _d, _e;\n    let same = false;\n    if (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length)) {\n        const { type, data } = responders[0];\n        same =\n            type === selectedSeries[0].type &&\n                ((_b = data) === null || _b === void 0 ? void 0 : _b.label) === ((_c = selectedSeries[0].data) === null || _c === void 0 ? void 0 : _c.label) &&\n                ((_d = data) === null || _d === void 0 ? void 0 : _d.category) === ((_e = selectedSeries[0].data) === null || _e === void 0 ? void 0 : _e.category);\n    }\n    return same;\n}\nexport function makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) {\n    const { centerX, centerY, angleRange: { start, end }, clockwise, } = renderOptions;\n    return getRadiusRanges(radiusRanges, 0).map((radius, index) => ({\n        type: 'sector',\n        x: centerX,\n        y: centerY,\n        degree: { start, end },\n        radius,\n        name: categories[index],\n        clockwise,\n        index,\n    }));\n}\n"]},"metadata":{},"sourceType":"module"}