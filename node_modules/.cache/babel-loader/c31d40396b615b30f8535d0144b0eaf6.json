{"ast":null,"code":"import { pick } from \"./utils\";\nexport const DEGREE_180 = 180;\nexport const DEGREE_NEGATIVE_180 = -180;\nexport const DEGREE_360 = 360;\nexport const DEGREE_0 = 0;\nexport const DEGREE_NEGATIVE_90 = -90;\nexport const DEGREE_90 = 90;\nconst MINIMUM_RADIUS = 10;\nexport function makeAnchorPositionParam(anchor, model) {\n  return Object.assign({\n    anchor\n  }, pick(model, 'x', 'y', 'radius', 'degree', 'drawingStartAngle'));\n}\nexport function calculateDegreeToRadian(degree, drawingStartAngle = DEGREE_NEGATIVE_90) {\n  let result = 0;\n\n  if (degree % DEGREE_360 === 0) {\n    result = Math.PI / DEGREE_180 * drawingStartAngle;\n  } else if (degree >= 0 && degree < DEGREE_360) {\n    result = Math.PI / DEGREE_180 * (degree + drawingStartAngle);\n  }\n\n  return result;\n}\nexport function calculateRadianToDegree(radian, drawingStartAngle = DEGREE_NEGATIVE_90) {\n  return (radian * DEGREE_180 / Math.PI - drawingStartAngle + DEGREE_360) % DEGREE_360;\n}\nexport function getRadialAnchorPosition(param) {\n  const {\n    anchor,\n    x,\n    y,\n    radius: {\n      inner,\n      outer\n    },\n    degree: {\n      start,\n      end\n    },\n    drawingStartAngle\n  } = param;\n  const halfDegree = start + (end - start) / 2;\n  const radian = calculateDegreeToRadian(halfDegree, drawingStartAngle);\n  const r = anchor === 'outer' ? outer : (outer + inner) / 2;\n  return getRadialPosition(x, y, r, radian);\n}\nexport function getRadialPosition(x, y, r, radian) {\n  return {\n    x: Math.round(x + r * Math.cos(radian)),\n    y: Math.round(y + r * Math.sin(radian))\n  };\n}\nexport function withinRadian(clockwise, startDegree, endDegree, currentDegree) {\n  return clockwise ? startDegree <= currentDegree && endDegree >= currentDegree : startDegree >= currentDegree && endDegree <= currentDegree;\n}\nexport function initSectorOptions(options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n\n  const clockwise = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.clockwise, _b !== null && _b !== void 0 ? _b : true);\n  return {\n    clockwise,\n    startAngle: (_e = (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.angleRange) === null || _d === void 0 ? void 0 : _d.start, _e !== null && _e !== void 0 ? _e : clockwise ? DEGREE_0 : DEGREE_360),\n    endAngle: (_h = (_g = (_f = options) === null || _f === void 0 ? void 0 : _f.angleRange) === null || _g === void 0 ? void 0 : _g.end, _h !== null && _h !== void 0 ? _h : clockwise ? DEGREE_360 : DEGREE_0)\n  };\n}\nexport function getDefaultRadius({\n  width,\n  height\n}, isSemiCircular = false, maxLabelWidth = 0, maxLabelHeight = 0) {\n  let result;\n\n  if (isSemiCircular) {\n    result = Math.min(width / 2, height) - maxLabelHeight;\n  } else if (width > height) {\n    result = height / 2 - maxLabelHeight;\n  } else {\n    result = width / 2 - maxLabelWidth;\n  }\n\n  return Math.max(result, MINIMUM_RADIUS);\n}\n\nfunction getRadian(startAngle, endAngle, drawingStartAngle, needCalculateByHalf) {\n  const degree = needCalculateByHalf ? (endAngle + startAngle) / 2 : startAngle;\n  return calculateDegreeToRadian(degree, drawingStartAngle);\n}\n\nexport function getRadialLabelAlign(model, anchor, needCalculateByHalf = true) {\n  const {\n    totalAngle,\n    degree: {\n      start,\n      end\n    },\n    drawingStartAngle\n  } = model;\n  let textAlign = 'center';\n\n  if (anchor !== 'outer') {\n    return textAlign;\n  }\n\n  const radian0 = calculateDegreeToRadian(0, drawingStartAngle);\n  const halfRadian = calculateDegreeToRadian(totalAngle / 2, drawingStartAngle);\n  const radian = getRadian(start, end, drawingStartAngle, needCalculateByHalf);\n\n  if (drawingStartAngle >= DEGREE_NEGATIVE_90 && drawingStartAngle < DEGREE_90) {\n    if (radian0 < radian && halfRadian > radian) {\n      textAlign = 'left';\n    } else if (halfRadian < radian) {\n      textAlign = 'right';\n    }\n  } else if (radian0 < radian && halfRadian > radian) {\n    textAlign = 'right';\n  } else if (halfRadian < radian) {\n    textAlign = 'left';\n  }\n\n  return textAlign;\n}\nexport function getRadiusRanges(radiusRanges, padding) {\n  return radiusRanges.reduce((acc, cur, index) => {\n    if (index) {\n      acc.push({\n        inner: cur + padding,\n        outer: radiusRanges[index - 1] - padding\n      });\n    }\n\n    if (index === radiusRanges.length - 1) {\n      acc.push({\n        inner: padding,\n        outer: cur - padding\n      });\n    }\n\n    return acc;\n  }, []);\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/helpers/sector.js"],"names":["pick","DEGREE_180","DEGREE_NEGATIVE_180","DEGREE_360","DEGREE_0","DEGREE_NEGATIVE_90","DEGREE_90","MINIMUM_RADIUS","makeAnchorPositionParam","anchor","model","Object","assign","calculateDegreeToRadian","degree","drawingStartAngle","result","Math","PI","calculateRadianToDegree","radian","getRadialAnchorPosition","param","x","y","radius","inner","outer","start","end","halfDegree","r","getRadialPosition","round","cos","sin","withinRadian","clockwise","startDegree","endDegree","currentDegree","initSectorOptions","options","_a","_b","_c","_d","_e","_f","_g","_h","startAngle","angleRange","endAngle","getDefaultRadius","width","height","isSemiCircular","maxLabelWidth","maxLabelHeight","min","max","getRadian","needCalculateByHalf","getRadialLabelAlign","totalAngle","textAlign","radian0","halfRadian","getRadiusRanges","radiusRanges","padding","reduce","acc","cur","index","push","length"],"mappings":"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","sourcesContent":["import { pick } from \"./utils\";\nexport const DEGREE_180 = 180;\nexport const DEGREE_NEGATIVE_180 = -180;\nexport const DEGREE_360 = 360;\nexport const DEGREE_0 = 0;\nexport const DEGREE_NEGATIVE_90 = -90;\nexport const DEGREE_90 = 90;\nconst MINIMUM_RADIUS = 10;\nexport function makeAnchorPositionParam(anchor, model) {\n    return Object.assign({ anchor }, pick(model, 'x', 'y', 'radius', 'degree', 'drawingStartAngle'));\n}\nexport function calculateDegreeToRadian(degree, drawingStartAngle = DEGREE_NEGATIVE_90) {\n    let result = 0;\n    if (degree % DEGREE_360 === 0) {\n        result = (Math.PI / DEGREE_180) * drawingStartAngle;\n    }\n    else if (degree >= 0 && degree < DEGREE_360) {\n        result = (Math.PI / DEGREE_180) * (degree + drawingStartAngle);\n    }\n    return result;\n}\nexport function calculateRadianToDegree(radian, drawingStartAngle = DEGREE_NEGATIVE_90) {\n    return ((radian * DEGREE_180) / Math.PI - drawingStartAngle + DEGREE_360) % DEGREE_360;\n}\nexport function getRadialAnchorPosition(param) {\n    const { anchor, x, y, radius: { inner, outer }, degree: { start, end }, drawingStartAngle, } = param;\n    const halfDegree = start + (end - start) / 2;\n    const radian = calculateDegreeToRadian(halfDegree, drawingStartAngle);\n    const r = anchor === 'outer' ? outer : (outer + inner) / 2;\n    return getRadialPosition(x, y, r, radian);\n}\nexport function getRadialPosition(x, y, r, radian) {\n    return { x: Math.round(x + r * Math.cos(radian)), y: Math.round(y + r * Math.sin(radian)) };\n}\nexport function withinRadian(clockwise, startDegree, endDegree, currentDegree) {\n    return clockwise\n        ? startDegree <= currentDegree && endDegree >= currentDegree\n        : startDegree >= currentDegree && endDegree <= currentDegree;\n}\nexport function initSectorOptions(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const clockwise = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.clockwise, (_b !== null && _b !== void 0 ? _b : true));\n    return {\n        clockwise,\n        startAngle: (_e = (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.angleRange) === null || _d === void 0 ? void 0 : _d.start, (_e !== null && _e !== void 0 ? _e : (clockwise ? DEGREE_0 : DEGREE_360))),\n        endAngle: (_h = (_g = (_f = options) === null || _f === void 0 ? void 0 : _f.angleRange) === null || _g === void 0 ? void 0 : _g.end, (_h !== null && _h !== void 0 ? _h : (clockwise ? DEGREE_360 : DEGREE_0))),\n    };\n}\nexport function getDefaultRadius({ width, height }, isSemiCircular = false, maxLabelWidth = 0, maxLabelHeight = 0) {\n    let result;\n    if (isSemiCircular) {\n        result = Math.min(width / 2, height) - maxLabelHeight;\n    }\n    else if (width > height) {\n        result = height / 2 - maxLabelHeight;\n    }\n    else {\n        result = width / 2 - maxLabelWidth;\n    }\n    return Math.max(result, MINIMUM_RADIUS);\n}\nfunction getRadian(startAngle, endAngle, drawingStartAngle, needCalculateByHalf) {\n    const degree = needCalculateByHalf ? (endAngle + startAngle) / 2 : startAngle;\n    return calculateDegreeToRadian(degree, drawingStartAngle);\n}\nexport function getRadialLabelAlign(model, anchor, needCalculateByHalf = true) {\n    const { totalAngle, degree: { start, end }, drawingStartAngle, } = model;\n    let textAlign = 'center';\n    if (anchor !== 'outer') {\n        return textAlign;\n    }\n    const radian0 = calculateDegreeToRadian(0, drawingStartAngle);\n    const halfRadian = calculateDegreeToRadian(totalAngle / 2, drawingStartAngle);\n    const radian = getRadian(start, end, drawingStartAngle, needCalculateByHalf);\n    if (drawingStartAngle >= DEGREE_NEGATIVE_90 && drawingStartAngle < DEGREE_90) {\n        if (radian0 < radian && halfRadian > radian) {\n            textAlign = 'left';\n        }\n        else if (halfRadian < radian) {\n            textAlign = 'right';\n        }\n    }\n    else if (radian0 < radian && halfRadian > radian) {\n        textAlign = 'right';\n    }\n    else if (halfRadian < radian) {\n        textAlign = 'left';\n    }\n    return textAlign;\n}\nexport function getRadiusRanges(radiusRanges, padding) {\n    return radiusRanges.reduce((acc, cur, index) => {\n        if (index) {\n            acc.push({\n                inner: cur + padding,\n                outer: radiusRanges[index - 1] - padding,\n            });\n        }\n        if (index === radiusRanges.length - 1) {\n            acc.push({\n                inner: padding,\n                outer: cur - padding,\n            });\n        }\n        return acc;\n    }, []);\n}\n"]},"metadata":{},"sourceType":"module"}