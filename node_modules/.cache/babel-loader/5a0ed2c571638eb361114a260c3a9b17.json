{"ast":null,"code":"import { isExist, omit } from \"../helpers/utils\";\nimport { add, multiply, divide } from \"../helpers/calculator\";\nimport { calculateCoordinateScale, makeScaleOption } from \"./coordinateScaleCalculator\";\nconst msMap = {\n  year: 31536000000,\n  month: 2678400000,\n  week: 604800000,\n  date: 86400000,\n  hour: 3600000,\n  minute: 60000,\n  second: 1000\n};\nexport function calculateDatetimeScale(options) {\n  const {\n    dataRange,\n    rawCategoriesSize,\n    scaleOption\n  } = options;\n  const datetimeInfo = makeDatetimeInfo(dataRange, rawCategoriesSize, scaleOption);\n  const {\n    minDate,\n    divisionNumber,\n    limit\n  } = datetimeInfo;\n  const scale = calculateCoordinateScale(Object.assign(Object.assign({}, omit(options, 'scaleOption')), {\n    dataRange: limit,\n    minStepSize: 1\n  }));\n  return restoreScaleToDatetimeType(scale, minDate, divisionNumber);\n}\nconst msTypes = ['year', 'month', 'week', 'date', 'hour', 'minute', 'second'];\n\nfunction restoreScaleToDatetimeType(scale, minDate, divisionNumber) {\n  const {\n    limit,\n    stepSize\n  } = scale;\n  const {\n    min,\n    max\n  } = limit;\n  return Object.assign(Object.assign({}, scale), {\n    stepSize: multiply(stepSize, divisionNumber),\n    limit: {\n      min: multiply(add(min, minDate), divisionNumber),\n      max: multiply(add(max, minDate), divisionNumber)\n    }\n  });\n}\n\nfunction makeDatetimeInfo(limit, count, scaleOption) {\n  var _a, _b;\n\n  const dateType = findDateType(limit, count);\n  const divisionNumber = (_b = (_a = scaleOption) === null || _a === void 0 ? void 0 : _a.stepSize, _b !== null && _b !== void 0 ? _b : msMap[dateType]);\n  const scale = makeScaleOption(limit, scaleOption);\n  const minDate = divide(Number(new Date(scale.min)), divisionNumber);\n  const maxDate = divide(Number(new Date(scale.max)), divisionNumber);\n  return {\n    divisionNumber,\n    minDate,\n    limit: {\n      min: 0,\n      max: maxDate - minDate\n    }\n  };\n}\n\nfunction findDateType({\n  max,\n  min\n}, count) {\n  const diff = max - min;\n  const lastTypeIndex = msTypes.length - 1;\n  let foundType;\n\n  if (diff) {\n    msTypes.every((type, index) => {\n      const millisecond = msMap[type];\n      const dividedCount = Math.floor(diff / millisecond);\n      let foundIndex;\n\n      if (dividedCount) {\n        foundIndex = index < lastTypeIndex && dividedCount < 2 && dividedCount < count ? index + 1 : index;\n        foundType = msTypes[foundIndex];\n      }\n\n      return !isExist(foundIndex);\n    });\n  } else {\n    foundType = 'second';\n  }\n\n  return foundType;\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/scale/datetimeScaleCalculator.js"],"names":["isExist","omit","add","multiply","divide","calculateCoordinateScale","makeScaleOption","msMap","year","month","week","date","hour","minute","second","calculateDatetimeScale","options","dataRange","rawCategoriesSize","scaleOption","datetimeInfo","makeDatetimeInfo","minDate","divisionNumber","limit","scale","Object","assign","minStepSize","restoreScaleToDatetimeType","msTypes","stepSize","min","max","count","_a","_b","dateType","findDateType","Number","Date","maxDate","diff","lastTypeIndex","length","foundType","every","type","index","millisecond","dividedCount","Math","floor","foundIndex"],"mappings":"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","sourcesContent":["import { isExist, omit } from \"../helpers/utils\";\nimport { add, multiply, divide } from \"../helpers/calculator\";\nimport { calculateCoordinateScale, makeScaleOption } from \"./coordinateScaleCalculator\";\nconst msMap = {\n    year: 31536000000,\n    month: 2678400000,\n    week: 604800000,\n    date: 86400000,\n    hour: 3600000,\n    minute: 60000,\n    second: 1000,\n};\nexport function calculateDatetimeScale(options) {\n    const { dataRange, rawCategoriesSize, scaleOption } = options;\n    const datetimeInfo = makeDatetimeInfo(dataRange, rawCategoriesSize, scaleOption);\n    const { minDate, divisionNumber, limit } = datetimeInfo;\n    const scale = calculateCoordinateScale(Object.assign(Object.assign({}, omit(options, 'scaleOption')), { dataRange: limit, minStepSize: 1 }));\n    return restoreScaleToDatetimeType(scale, minDate, divisionNumber);\n}\nconst msTypes = ['year', 'month', 'week', 'date', 'hour', 'minute', 'second'];\nfunction restoreScaleToDatetimeType(scale, minDate, divisionNumber) {\n    const { limit, stepSize } = scale;\n    const { min, max } = limit;\n    return Object.assign(Object.assign({}, scale), { stepSize: multiply(stepSize, divisionNumber), limit: {\n            min: multiply(add(min, minDate), divisionNumber),\n            max: multiply(add(max, minDate), divisionNumber),\n        } });\n}\nfunction makeDatetimeInfo(limit, count, scaleOption) {\n    var _a, _b;\n    const dateType = findDateType(limit, count);\n    const divisionNumber = (_b = (_a = scaleOption) === null || _a === void 0 ? void 0 : _a.stepSize, (_b !== null && _b !== void 0 ? _b : msMap[dateType]));\n    const scale = makeScaleOption(limit, scaleOption);\n    const minDate = divide(Number(new Date(scale.min)), divisionNumber);\n    const maxDate = divide(Number(new Date(scale.max)), divisionNumber);\n    return { divisionNumber, minDate, limit: { min: 0, max: maxDate - minDate } };\n}\nfunction findDateType({ max, min }, count) {\n    const diff = max - min;\n    const lastTypeIndex = msTypes.length - 1;\n    let foundType;\n    if (diff) {\n        msTypes.every((type, index) => {\n            const millisecond = msMap[type];\n            const dividedCount = Math.floor(diff / millisecond);\n            let foundIndex;\n            if (dividedCount) {\n                foundIndex =\n                    index < lastTypeIndex && dividedCount < 2 && dividedCount < count ? index + 1 : index;\n                foundType = msTypes[foundIndex];\n            }\n            return !isExist(foundIndex);\n        });\n    }\n    else {\n        foundType = 'second';\n    }\n    return foundType;\n}\n"]},"metadata":{},"sourceType":"module"}