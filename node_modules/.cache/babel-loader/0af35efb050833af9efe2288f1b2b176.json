{"ast":null,"code":"import { getCoordinateXValue, getCoordinateYValue } from \"../helpers/coordinate\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getValueRatio } from \"../helpers/calculator\";\nimport { deepCopy, deepMergedCopy, isNull, isNumber, isString } from \"../helpers/utils\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getNearestResponder } from \"../helpers/responders\";\nimport Component from \"./component\";\nimport { message } from \"../message\";\nconst MINIMUM_RADIUS = 0.5;\nconst MINIMUM_DETECTING_AREA_RADIUS = 1;\nexport function getMaxRadius(bubbleData) {\n  return bubbleData.reduce((acc, cur) => {\n    const NonNullData = cur.data.filter(datum => !isNull(datum));\n    return Math.max(acc, ...NonNullData.map(({\n      r\n    }) => r));\n  }, 0);\n}\nexport default class BubbleSeries extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      series: []\n    };\n    this.activatedResponders = [];\n    this.maxRadius = -1;\n    this.maxValue = -1;\n\n    this.onMouseoutComponent = () => {\n      this.eventBus.emit('seriesPointHovered', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('renderHoveredSeries', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.selectSeries = ({\n      index,\n      seriesIndex,\n      state\n    }) => {\n      if (!isNumber(index) || !isNumber(seriesIndex)) {\n        return;\n      }\n\n      const {\n        name\n      } = state.series.bubble.data[index];\n      const model = this.responders.filter(({\n        name: dataName\n      }) => dataName === name)[seriesIndex];\n\n      if (!model) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models: [model],\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.showTooltip = info => {\n      const {\n        index,\n        seriesIndex,\n        state\n      } = info;\n\n      if (!isNumber(index) || !isNumber(seriesIndex)) {\n        return;\n      }\n\n      const {\n        name\n      } = state.series.bubble.data[seriesIndex];\n      const models = [this.responders.filter(({\n        name: dataName\n      }) => dataName === name)[index]];\n\n      if (!models.length) {\n        return;\n      }\n\n      this.eventBus.emit('renderHoveredSeries', {\n        models,\n        name: this.name\n      });\n      this.activatedResponders = models;\n      this.eventBus.emit('seriesPointHovered', {\n        models: this.activatedResponders,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  initialize() {\n    this.type = 'series';\n    this.name = 'bubble';\n    this.eventBus.on('selectSeries', this.selectSeries);\n    this.eventBus.on('showTooltip', this.showTooltip);\n    this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n  }\n\n  initUpdate(delta) {\n    this.drawModels.series.forEach((model, index) => {\n      model.radius = this.models.series[index].radius * delta;\n    });\n  }\n\n  render(chartState) {\n    const {\n      layout,\n      series,\n      scale,\n      axes,\n      circleLegend,\n      legend,\n      options,\n      theme\n    } = chartState;\n    const {\n      plot\n    } = layout;\n\n    if (!series.bubble) {\n      throw new Error(message.noDataError(this.name));\n    }\n\n    const {\n      xAxis,\n      yAxis\n    } = axes;\n    const bubbleData = series.bubble.data;\n    this.theme = theme.series.bubble;\n    this.rect = plot;\n    this.activeSeriesMap = getActiveSeriesMap(legend);\n    this.selectable = this.getSelectableOption(options);\n    const xAxisTickSize = this.rect.width / xAxis.tickCount;\n    const yAxisTickSize = this.rect.height / yAxis.tickCount;\n    this.maxRadius = circleLegend.radius ? circleLegend.radius : Math.min(xAxisTickSize, yAxisTickSize);\n    this.maxValue = getMaxRadius(bubbleData);\n    const seriesModel = this.renderBubblePointsModel(bubbleData, scale);\n    const tooltipModel = this.makeTooltipModel(bubbleData);\n    this.models.series = seriesModel;\n\n    if (!this.drawModels) {\n      this.drawModels = deepCopy(this.models);\n    }\n\n    this.responders = seriesModel.map((m, index) => Object.assign(Object.assign({}, m), {\n      type: 'circle',\n      detectionSize: 0,\n      radius: m.radius + MINIMUM_DETECTING_AREA_RADIUS,\n      color: getRGBA(m.color, 0.85),\n      data: tooltipModel[index],\n      index\n    }));\n  }\n\n  renderBubblePointsModel(seriesRawData, scale) {\n    const xAxisLimit = scale.xAxis.limit;\n    const yAxisLimit = scale.yAxis.limit;\n    const {\n      borderWidth,\n      borderColor\n    } = this.theme;\n    return seriesRawData.flatMap(({\n      data,\n      name,\n      color: seriesColor\n    }, seriesIndex) => {\n      const circleModels = [];\n      const active = this.activeSeriesMap[name];\n      const color = getRGBA(seriesColor, active ? 0.8 : 0.1);\n      const nonNullData = data.filter(datum => !isNull(datum));\n      nonNullData.forEach(datum => {\n        const rawXValue = getCoordinateXValue(datum);\n        const xValue = isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);\n        const yValue = getCoordinateYValue(datum);\n        const xValueRatio = getValueRatio(xValue, xAxisLimit);\n        const yValueRatio = getValueRatio(yValue, yAxisLimit);\n        const x = xValueRatio * this.rect.width;\n        const y = (1 - yValueRatio) * this.rect.height;\n        const radius = Math.max(MINIMUM_RADIUS, datum.r / this.maxValue * this.maxRadius);\n        circleModels.push({\n          x,\n          y,\n          type: 'circle',\n          radius,\n          color,\n          style: ['default'],\n          seriesIndex,\n          name,\n          borderWidth,\n          borderColor\n        });\n      });\n      return circleModels;\n    });\n  }\n\n  makeTooltipModel(circleData) {\n    return [...circleData].flatMap(({\n      data,\n      name,\n      color\n    }) => {\n      const tooltipData = [];\n      const nonNullData = data.filter(datum => !isNull(datum));\n      nonNullData.forEach(datum => {\n        const {\n          r,\n          label\n        } = datum;\n        tooltipData.push({\n          label: `${name}/${label}`,\n          color,\n          value: {\n            x: getCoordinateXValue(datum),\n            y: getCoordinateYValue(datum),\n            r\n          }\n        });\n      });\n      return tooltipData;\n    });\n  }\n\n  getResponderAppliedTheme(responders, type) {\n    return responders.map(responder => deepMergedCopy(responder, this.theme[type]));\n  }\n\n  onMousemove({\n    responders,\n    mousePosition\n  }) {\n    const closestResponder = getNearestResponder(responders, mousePosition, this.rect);\n    const responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'hover');\n    this.eventBus.emit('renderHoveredSeries', {\n      models: responderWithTheme,\n      name: this.name\n    });\n    this.activatedResponders = closestResponder;\n    this.eventBus.emit('seriesPointHovered', {\n      models: this.activatedResponders,\n      name: this.name\n    });\n    this.eventBus.emit('needDraw');\n  }\n\n  onClick({\n    responders,\n    mousePosition\n  }) {\n    if (this.selectable) {\n      const closestResponder = getNearestResponder(responders, mousePosition, this.rect);\n      const responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'select');\n      this.eventBus.emit('renderSelectedSeries', {\n        models: responderWithTheme,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/bubbleSeries.js"],"names":["getCoordinateXValue","getCoordinateYValue","getRGBA","getValueRatio","deepCopy","deepMergedCopy","isNull","isNumber","isString","getActiveSeriesMap","getNearestResponder","Component","message","MINIMUM_RADIUS","MINIMUM_DETECTING_AREA_RADIUS","getMaxRadius","bubbleData","reduce","acc","cur","NonNullData","data","filter","datum","Math","max","map","r","BubbleSeries","constructor","arguments","models","series","activatedResponders","maxRadius","maxValue","onMouseoutComponent","eventBus","emit","name","selectSeries","index","seriesIndex","state","bubble","model","responders","dataName","Error","SELECT_SERIES_API_INDEX_ERROR","showTooltip","info","length","initialize","type","on","initUpdate","delta","drawModels","forEach","radius","render","chartState","layout","scale","axes","circleLegend","legend","options","theme","plot","noDataError","xAxis","yAxis","rect","activeSeriesMap","selectable","getSelectableOption","xAxisTickSize","width","tickCount","yAxisTickSize","height","min","seriesModel","renderBubblePointsModel","tooltipModel","makeTooltipModel","m","Object","assign","detectionSize","color","seriesRawData","xAxisLimit","limit","yAxisLimit","borderWidth","borderColor","flatMap","seriesColor","circleModels","active","nonNullData","rawXValue","xValue","Number","Date","yValue","xValueRatio","yValueRatio","x","y","push","style","circleData","tooltipData","label","value","getResponderAppliedTheme","responder","onMousemove","mousePosition","closestResponder","responderWithTheme","onClick"],"mappings":"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","sourcesContent":["import { getCoordinateXValue, getCoordinateYValue } from \"../helpers/coordinate\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getValueRatio } from \"../helpers/calculator\";\nimport { deepCopy, deepMergedCopy, isNull, isNumber, isString } from \"../helpers/utils\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getNearestResponder } from \"../helpers/responders\";\nimport Component from \"./component\";\nimport { message } from \"../message\";\nconst MINIMUM_RADIUS = 0.5;\nconst MINIMUM_DETECTING_AREA_RADIUS = 1;\nexport function getMaxRadius(bubbleData) {\n    return bubbleData.reduce((acc, cur) => {\n        const NonNullData = cur.data.filter((datum) => !isNull(datum));\n        return Math.max(acc, ...NonNullData.map(({ r }) => r));\n    }, 0);\n}\nexport default class BubbleSeries extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { series: [] };\n        this.activatedResponders = [];\n        this.maxRadius = -1;\n        this.maxValue = -1;\n        this.onMouseoutComponent = () => {\n            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });\n            this.eventBus.emit('renderHoveredSeries', {\n                models: [],\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.selectSeries = ({ index, seriesIndex, state }) => {\n            if (!isNumber(index) || !isNumber(seriesIndex)) {\n                return;\n            }\n            const { name } = state.series.bubble.data[index];\n            const model = this.responders.filter(({ name: dataName }) => dataName === name)[seriesIndex];\n            if (!model) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models: [model],\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.showTooltip = (info) => {\n            const { index, seriesIndex, state } = info;\n            if (!isNumber(index) || !isNumber(seriesIndex)) {\n                return;\n            }\n            const { name } = state.series.bubble.data[seriesIndex];\n            const models = [this.responders.filter(({ name: dataName }) => dataName === name)[index]];\n            if (!models.length) {\n                return;\n            }\n            this.eventBus.emit('renderHoveredSeries', { models, name: this.name });\n            this.activatedResponders = models;\n            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n    }\n    initialize() {\n        this.type = 'series';\n        this.name = 'bubble';\n        this.eventBus.on('selectSeries', this.selectSeries);\n        this.eventBus.on('showTooltip', this.showTooltip);\n        this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n    }\n    initUpdate(delta) {\n        this.drawModels.series.forEach((model, index) => {\n            model.radius = this.models.series[index].radius * delta;\n        });\n    }\n    render(chartState) {\n        const { layout, series, scale, axes, circleLegend, legend, options, theme } = chartState;\n        const { plot } = layout;\n        if (!series.bubble) {\n            throw new Error(message.noDataError(this.name));\n        }\n        const { xAxis, yAxis } = axes;\n        const bubbleData = series.bubble.data;\n        this.theme = theme.series.bubble;\n        this.rect = plot;\n        this.activeSeriesMap = getActiveSeriesMap(legend);\n        this.selectable = this.getSelectableOption(options);\n        const xAxisTickSize = this.rect.width / xAxis.tickCount;\n        const yAxisTickSize = this.rect.height / yAxis.tickCount;\n        this.maxRadius = circleLegend.radius\n            ? circleLegend.radius\n            : Math.min(xAxisTickSize, yAxisTickSize);\n        this.maxValue = getMaxRadius(bubbleData);\n        const seriesModel = this.renderBubblePointsModel(bubbleData, scale);\n        const tooltipModel = this.makeTooltipModel(bubbleData);\n        this.models.series = seriesModel;\n        if (!this.drawModels) {\n            this.drawModels = deepCopy(this.models);\n        }\n        this.responders = seriesModel.map((m, index) => (Object.assign(Object.assign({}, m), { type: 'circle', detectionSize: 0, radius: m.radius + MINIMUM_DETECTING_AREA_RADIUS, color: getRGBA(m.color, 0.85), data: tooltipModel[index], index })));\n    }\n    renderBubblePointsModel(seriesRawData, scale) {\n        const xAxisLimit = scale.xAxis.limit;\n        const yAxisLimit = scale.yAxis.limit;\n        const { borderWidth, borderColor } = this.theme;\n        return seriesRawData.flatMap(({ data, name, color: seriesColor }, seriesIndex) => {\n            const circleModels = [];\n            const active = this.activeSeriesMap[name];\n            const color = getRGBA(seriesColor, active ? 0.8 : 0.1);\n            const nonNullData = data.filter((datum) => !isNull(datum));\n            nonNullData.forEach((datum) => {\n                const rawXValue = getCoordinateXValue(datum);\n                const xValue = isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);\n                const yValue = getCoordinateYValue(datum);\n                const xValueRatio = getValueRatio(xValue, xAxisLimit);\n                const yValueRatio = getValueRatio(yValue, yAxisLimit);\n                const x = xValueRatio * this.rect.width;\n                const y = (1 - yValueRatio) * this.rect.height;\n                const radius = Math.max(MINIMUM_RADIUS, (datum.r / this.maxValue) * this.maxRadius);\n                circleModels.push({\n                    x,\n                    y,\n                    type: 'circle',\n                    radius,\n                    color,\n                    style: ['default'],\n                    seriesIndex,\n                    name,\n                    borderWidth,\n                    borderColor,\n                });\n            });\n            return circleModels;\n        });\n    }\n    makeTooltipModel(circleData) {\n        return [...circleData].flatMap(({ data, name, color }) => {\n            const tooltipData = [];\n            const nonNullData = data.filter((datum) => !isNull(datum));\n            nonNullData.forEach((datum) => {\n                const { r, label } = datum;\n                tooltipData.push({\n                    label: `${name}/${label}`,\n                    color,\n                    value: {\n                        x: getCoordinateXValue(datum),\n                        y: getCoordinateYValue(datum),\n                        r,\n                    },\n                });\n            });\n            return tooltipData;\n        });\n    }\n    getResponderAppliedTheme(responders, type) {\n        return responders.map((responder) => deepMergedCopy(responder, this.theme[type]));\n    }\n    onMousemove({ responders, mousePosition }) {\n        const closestResponder = getNearestResponder(responders, mousePosition, this.rect);\n        const responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'hover');\n        this.eventBus.emit('renderHoveredSeries', { models: responderWithTheme, name: this.name });\n        this.activatedResponders = closestResponder;\n        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n        this.eventBus.emit('needDraw');\n    }\n    onClick({ responders, mousePosition }) {\n        if (this.selectable) {\n            const closestResponder = getNearestResponder(responders, mousePosition, this.rect);\n            const responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'select');\n            this.eventBus.emit('renderSelectedSeries', {\n                models: responderWithTheme,\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}