{"ast":null,"code":"import { isNull, pickProperty } from \"../helpers/utils\";\nimport { message } from \"../message\";\nlet currentCollectorObserver = null;\nlet currentRunningObserver = null;\nconst observerCallCue = [];\nlet doingInvisibleWork = false;\nexport function observe(fn) {\n  const observer = () => {\n    if (currentRunningObserver === observer) {\n      return;\n    } // If there is observer running or doing invisible work\n\n\n    if (doingInvisibleWork || !isNull(currentRunningObserver)) {\n      if (observerCallCue.includes(observer)) {\n        observerCallCue.splice(observerCallCue.indexOf(observer), 1);\n      } // We use observer call cue because avoid nested observer call.\n\n\n      observerCallCue.push(observer); // or If there are no observers running. Run the observer and run the next observer in the call queue.\n    } else if (isNull(currentRunningObserver)) {\n      currentRunningObserver = observer;\n      fn();\n      currentRunningObserver = null;\n      digestObserverCallCue();\n    }\n  };\n\n  observer.deps = []; // first observer excution for collect dependencies\n\n  currentCollectorObserver = observer;\n  currentCollectorObserver();\n  currentCollectorObserver = null;\n  return () => {\n    observer.deps.forEach(dep => {\n      const index = dep.findIndex(ob => ob === observer);\n      dep.splice(index, 1);\n    });\n    observer.deps = [];\n  };\n}\n\nfunction digestObserverCallCue() {\n  if (observerCallCue.length) {\n    const nextObserver = observerCallCue.shift();\n\n    if (nextObserver) {\n      nextObserver();\n    }\n  }\n}\n\nexport function isObservable(target) {\n  return typeof target === 'object' && target.__toastUIChartOb__;\n}\nexport function observable(target, source = target) {\n  if (isObservable(source)) {\n    throw new Error(message.ALREADY_OBSERVABLE_ERROR);\n  }\n\n  if (!isObservable(target)) {\n    Object.defineProperty(target, '__toastUIChartOb__', {\n      enumerable: false\n    });\n  }\n\n  for (const key in source) {\n    if (!source.hasOwnProperty(key)) {\n      continue;\n    }\n\n    const obs = [];\n    let value = source[key];\n    const descriptor = Object.getOwnPropertyDescriptor(source, key);\n    const preGetter = descriptor && descriptor.get;\n    const preSetter = descriptor && descriptor.set;\n    /* eslint-disable no-loop-func */\n\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: true,\n      get: function () {\n        // It's some kind a trick to get observable information from closure using getter for notify()\n        if (currentCollectorObserver === observableInfo) {\n          return {\n            target,\n            key,\n            value,\n            obs\n          };\n        }\n\n        if (!doingInvisibleWork && currentCollectorObserver && !obs.includes(currentCollectorObserver)) {\n          // if there is collector observer in running, collect current data as dependency\n          obs.push(currentCollectorObserver);\n          currentCollectorObserver.deps.push(obs);\n        }\n\n        return value;\n      },\n      set: function (v) {\n        const prevValue = value;\n\n        if (preSetter) {\n          preSetter.call(target, v);\n          value = preGetter ? preGetter.call(target) : target[key];\n        } else {\n          value = v;\n        }\n\n        if (prevValue !== value) {\n          // Run observers\n          invokeObs(obs);\n        }\n      }\n    });\n\n    if (typeof target[key] === 'object' && !Array.isArray(target[key])) {\n      observable(target[key]);\n    }\n    /* eslint-enable no-loop-func */\n\n  }\n\n  return target;\n}\nexport function setValue(target, key, source) {\n  return observable(target, {\n    [key]: source\n  });\n}\nexport function extend(target, source) {\n  if (isObservable(source)) {\n    throw new Error(message.ALREADY_OBSERVABLE_ERROR);\n  }\n\n  return observable(target, source);\n}\nexport function notify(target, key) {\n  const obInfo = observableInfo(target, key);\n\n  if (obInfo) {\n    invokeObs(obInfo.obs);\n  }\n}\nexport function invisibleWork(fn) {\n  doingInvisibleWork = true;\n  fn();\n  doingInvisibleWork = false;\n  digestObserverCallCue();\n}\nexport function notifyByPath(holder, namePath) {\n  const splited = namePath.split('.');\n  const key = splited.splice(splited.length - 1, 1)[0];\n  const target = pickProperty(holder, splited);\n\n  if (target) {\n    notify(target, key);\n  }\n}\n\nfunction invokeObs(obs) {\n  obs.forEach(ob => ob());\n}\n\nfunction observableInfo(target, key) {\n  currentCollectorObserver = observableInfo;\n  const obInfo = target[key];\n  currentCollectorObserver = null;\n\n  if (typeof obInfo === 'object' && obInfo.hasOwnProperty('target') && obInfo.hasOwnProperty('obs')) {\n    return obInfo;\n  }\n\n  return null;\n}\n\nexport function computed(target, key, fn) {\n  let cachedValue;\n  const computedBox = {};\n  Object.defineProperty(computedBox, key, {\n    configurable: true,\n    enumerable: true,\n    get: () => cachedValue\n  });\n  extend(target, computedBox);\n  observe(() => {\n    const prevValue = cachedValue;\n    cachedValue = fn();\n\n    if (prevValue !== cachedValue) {\n      target[key] = cachedValue;\n    }\n  });\n}\nexport function watch(holder, path, fn) {\n  const splited = path.split('.');\n  const key = splited.splice(splited.length - 1, 1)[0];\n  const target = pickProperty(holder, splited);\n\n  if (!target) {\n    return null;\n  }\n\n  const obInfo = observableInfo(target, key);\n\n  if (!obInfo) {\n    return null;\n  }\n\n  const watcher = () => {\n    fn(target[key]);\n  };\n\n  obInfo.obs.push(watcher);\n  return () => {\n    const index = obInfo.obs.findIndex(ob => ob === watcher);\n\n    if (index > -1) {\n      obInfo.obs.splice(index, 1);\n    }\n  };\n}\nexport function makeObservableObjectToNormal(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/store/reactive.js"],"names":["isNull","pickProperty","message","currentCollectorObserver","currentRunningObserver","observerCallCue","doingInvisibleWork","observe","fn","observer","includes","splice","indexOf","push","digestObserverCallCue","deps","forEach","dep","index","findIndex","ob","length","nextObserver","shift","isObservable","target","__toastUIChartOb__","observable","source","Error","ALREADY_OBSERVABLE_ERROR","Object","defineProperty","enumerable","key","hasOwnProperty","obs","value","descriptor","getOwnPropertyDescriptor","preGetter","get","preSetter","set","configurable","observableInfo","v","prevValue","call","invokeObs","Array","isArray","setValue","extend","notify","obInfo","invisibleWork","notifyByPath","holder","namePath","splited","split","computed","cachedValue","computedBox","watch","path","watcher","makeObservableObjectToNormal","obj","JSON","parse","stringify"],"mappings":"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","sourcesContent":["import { isNull, pickProperty } from \"../helpers/utils\";\nimport { message } from \"../message\";\nlet currentCollectorObserver = null;\nlet currentRunningObserver = null;\nconst observerCallCue = [];\nlet doingInvisibleWork = false;\nexport function observe(fn) {\n    const observer = () => {\n        if (currentRunningObserver === observer) {\n            return;\n        }\n        // If there is observer running or doing invisible work\n        if (doingInvisibleWork || !isNull(currentRunningObserver)) {\n            if (observerCallCue.includes(observer)) {\n                observerCallCue.splice(observerCallCue.indexOf(observer), 1);\n            }\n            // We use observer call cue because avoid nested observer call.\n            observerCallCue.push(observer);\n            // or If there are no observers running. Run the observer and run the next observer in the call queue.\n        }\n        else if (isNull(currentRunningObserver)) {\n            currentRunningObserver = observer;\n            fn();\n            currentRunningObserver = null;\n            digestObserverCallCue();\n        }\n    };\n    observer.deps = [];\n    // first observer excution for collect dependencies\n    currentCollectorObserver = observer;\n    currentCollectorObserver();\n    currentCollectorObserver = null;\n    return () => {\n        observer.deps.forEach((dep) => {\n            const index = dep.findIndex((ob) => ob === observer);\n            dep.splice(index, 1);\n        });\n        observer.deps = [];\n    };\n}\nfunction digestObserverCallCue() {\n    if (observerCallCue.length) {\n        const nextObserver = observerCallCue.shift();\n        if (nextObserver) {\n            nextObserver();\n        }\n    }\n}\nexport function isObservable(target) {\n    return typeof target === 'object' && target.__toastUIChartOb__;\n}\nexport function observable(target, source = target) {\n    if (isObservable(source)) {\n        throw new Error(message.ALREADY_OBSERVABLE_ERROR);\n    }\n    if (!isObservable(target)) {\n        Object.defineProperty(target, '__toastUIChartOb__', {\n            enumerable: false,\n        });\n    }\n    for (const key in source) {\n        if (!source.hasOwnProperty(key)) {\n            continue;\n        }\n        const obs = [];\n        let value = source[key];\n        const descriptor = Object.getOwnPropertyDescriptor(source, key);\n        const preGetter = descriptor && descriptor.get;\n        const preSetter = descriptor && descriptor.set;\n        /* eslint-disable no-loop-func */\n        Object.defineProperty(target, key, {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                // It's some kind a trick to get observable information from closure using getter for notify()\n                if (currentCollectorObserver === observableInfo) {\n                    return { target, key, value, obs };\n                }\n                if (!doingInvisibleWork &&\n                    currentCollectorObserver &&\n                    !obs.includes(currentCollectorObserver)) {\n                    // if there is collector observer in running, collect current data as dependency\n                    obs.push(currentCollectorObserver);\n                    currentCollectorObserver.deps.push(obs);\n                }\n                return value;\n            },\n            set: function (v) {\n                const prevValue = value;\n                if (preSetter) {\n                    preSetter.call(target, v);\n                    value = preGetter ? preGetter.call(target) : target[key];\n                }\n                else {\n                    value = v;\n                }\n                if (prevValue !== value) {\n                    // Run observers\n                    invokeObs(obs);\n                }\n            },\n        });\n        if (typeof target[key] === 'object' && !Array.isArray(target[key])) {\n            observable(target[key]);\n        }\n        /* eslint-enable no-loop-func */\n    }\n    return target;\n}\nexport function setValue(target, key, source) {\n    return observable(target, {\n        [key]: source,\n    });\n}\nexport function extend(target, source) {\n    if (isObservable(source)) {\n        throw new Error(message.ALREADY_OBSERVABLE_ERROR);\n    }\n    return observable(target, source);\n}\nexport function notify(target, key) {\n    const obInfo = observableInfo(target, key);\n    if (obInfo) {\n        invokeObs(obInfo.obs);\n    }\n}\nexport function invisibleWork(fn) {\n    doingInvisibleWork = true;\n    fn();\n    doingInvisibleWork = false;\n    digestObserverCallCue();\n}\nexport function notifyByPath(holder, namePath) {\n    const splited = namePath.split('.');\n    const key = splited.splice(splited.length - 1, 1)[0];\n    const target = pickProperty(holder, splited);\n    if (target) {\n        notify(target, key);\n    }\n}\nfunction invokeObs(obs) {\n    obs.forEach((ob) => ob());\n}\nfunction observableInfo(target, key) {\n    currentCollectorObserver = observableInfo;\n    const obInfo = target[key];\n    currentCollectorObserver = null;\n    if (typeof obInfo === 'object' &&\n        obInfo.hasOwnProperty('target') &&\n        obInfo.hasOwnProperty('obs')) {\n        return obInfo;\n    }\n    return null;\n}\nexport function computed(target, key, fn) {\n    let cachedValue;\n    const computedBox = {};\n    Object.defineProperty(computedBox, key, {\n        configurable: true,\n        enumerable: true,\n        get: () => cachedValue,\n    });\n    extend(target, computedBox);\n    observe(() => {\n        const prevValue = cachedValue;\n        cachedValue = fn();\n        if (prevValue !== cachedValue) {\n            target[key] = cachedValue;\n        }\n    });\n}\nexport function watch(holder, path, fn) {\n    const splited = path.split('.');\n    const key = splited.splice(splited.length - 1, 1)[0];\n    const target = pickProperty(holder, splited);\n    if (!target) {\n        return null;\n    }\n    const obInfo = observableInfo(target, key);\n    if (!obInfo) {\n        return null;\n    }\n    const watcher = () => {\n        fn(target[key]);\n    };\n    obInfo.obs.push(watcher);\n    return () => {\n        const index = obInfo.obs.findIndex((ob) => ob === watcher);\n        if (index > -1) {\n            obInfo.obs.splice(index, 1);\n        }\n    };\n}\nexport function makeObservableObjectToNormal(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n"]},"metadata":{},"sourceType":"module"}