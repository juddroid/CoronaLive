{"ast":null,"code":"import { isNull, isNumber, isUndefined, sortCategories } from \"../helpers/utils\";\nimport { getCoordinateXValue } from \"../helpers/coordinate\";\nimport { getDataInRange } from \"../helpers/range\";\nexport function makeRawCategories(series, categories) {\n  if (categories) {\n    return categories;\n  }\n\n  const firstValues = new Set();\n  Object.keys(series).forEach(key => {\n    var _a;\n\n    if (key === 'pie') {\n      return;\n    }\n\n    (_a = series[key].data, _a !== null && _a !== void 0 ? _a : series[key]).forEach(({\n      data,\n      name,\n      visible\n    }) => {\n      if (Array.isArray(data)) {\n        data.forEach(datum => {\n          if (!isNull(datum)) {\n            const rawXValue = getCoordinateXValue(datum);\n            firstValues.add(isNumber(rawXValue) ? rawXValue : rawXValue.toString());\n          }\n        });\n      } else if (key === 'bullet' && isUndefined(visible) || visible) {\n        firstValues.add(name);\n      }\n    });\n  });\n  return Array.from(firstValues).sort(sortCategories).map(category => String(category));\n}\nconst category = {\n  name: 'category',\n  state: ({\n    categories,\n    series\n  }) => ({\n    categories: makeRawCategories(series, categories)\n  }),\n  action: {\n    setCategory({\n      state,\n      computed\n    }) {\n      const {\n        viewRange\n      } = computed;\n      let categories = state.rawCategories;\n\n      if (viewRange) {\n        if (Array.isArray(categories)) {\n          categories = getDataInRange(categories, viewRange);\n        } else {\n          categories = Object.assign(Object.assign({}, categories), {\n            x: getDataInRange(categories.x, viewRange)\n          });\n        }\n      }\n\n      state.categories = categories;\n      this.notify(state, 'categories');\n    },\n\n    initCategory({\n      initStoreState,\n      state\n    }) {\n      const {\n        zoomRange\n      } = state;\n      let categories = makeRawCategories(initStoreState.series);\n\n      if (zoomRange && Array.isArray(categories)) {\n        categories = getDataInRange(categories, zoomRange);\n      }\n\n      state.categories = categories;\n      this.notify(state, 'categories');\n    },\n\n    removeCategoryByName({\n      state\n    }, name) {\n      const index = state.categories.findIndex(seriesName => seriesName === name);\n      state.categories.splice(index, 1);\n      this.notify(state, 'axes');\n    }\n\n  },\n  observe: {\n    updateCategory() {\n      this.dispatch('setCategory');\n    }\n\n  }\n};\nexport default category;","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/store/category.js"],"names":["isNull","isNumber","isUndefined","sortCategories","getCoordinateXValue","getDataInRange","makeRawCategories","series","categories","firstValues","Set","Object","keys","forEach","key","_a","data","name","visible","Array","isArray","datum","rawXValue","add","toString","from","sort","map","category","String","state","action","setCategory","computed","viewRange","rawCategories","assign","x","notify","initCategory","initStoreState","zoomRange","removeCategoryByName","index","findIndex","seriesName","splice","observe","updateCategory","dispatch"],"mappings":"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","sourcesContent":["import { isNull, isNumber, isUndefined, sortCategories } from \"../helpers/utils\";\nimport { getCoordinateXValue } from \"../helpers/coordinate\";\nimport { getDataInRange } from \"../helpers/range\";\nexport function makeRawCategories(series, categories) {\n    if (categories) {\n        return categories;\n    }\n    const firstValues = new Set();\n    Object.keys(series).forEach((key) => {\n        var _a;\n        if (key === 'pie') {\n            return;\n        }\n        (_a = series[key].data, (_a !== null && _a !== void 0 ? _a : series[key])).forEach(({ data, name, visible }) => {\n            if (Array.isArray(data)) {\n                data.forEach((datum) => {\n                    if (!isNull(datum)) {\n                        const rawXValue = getCoordinateXValue(datum);\n                        firstValues.add(isNumber(rawXValue) ? rawXValue : rawXValue.toString());\n                    }\n                });\n            }\n            else if ((key === 'bullet' && isUndefined(visible)) || visible) {\n                firstValues.add(name);\n            }\n        });\n    });\n    return Array.from(firstValues)\n        .sort(sortCategories)\n        .map((category) => String(category));\n}\nconst category = {\n    name: 'category',\n    state: ({ categories, series }) => ({\n        categories: makeRawCategories(series, categories),\n    }),\n    action: {\n        setCategory({ state, computed }) {\n            const { viewRange } = computed;\n            let categories = state.rawCategories;\n            if (viewRange) {\n                if (Array.isArray(categories)) {\n                    categories = getDataInRange(categories, viewRange);\n                }\n                else {\n                    categories = Object.assign(Object.assign({}, categories), { x: getDataInRange(categories.x, viewRange) });\n                }\n            }\n            state.categories = categories;\n            this.notify(state, 'categories');\n        },\n        initCategory({ initStoreState, state }) {\n            const { zoomRange } = state;\n            let categories = makeRawCategories(initStoreState.series);\n            if (zoomRange && Array.isArray(categories)) {\n                categories = getDataInRange(categories, zoomRange);\n            }\n            state.categories = categories;\n            this.notify(state, 'categories');\n        },\n        removeCategoryByName({ state }, name) {\n            const index = state.categories.findIndex((seriesName) => seriesName === name);\n            state.categories.splice(index, 1);\n            this.notify(state, 'axes');\n        },\n    },\n    observe: {\n        updateCategory() {\n            this.dispatch('setCategory');\n        },\n    },\n};\nexport default category;\n"]},"metadata":{},"sourceType":"module"}