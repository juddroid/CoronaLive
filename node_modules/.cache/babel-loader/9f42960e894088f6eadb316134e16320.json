{"ast":null,"code":"import Component from \"./component\";\nimport { calculateDegreeToRadian, getRadialPosition, getRadialLabelAlign } from \"../helpers/sector\";\nimport { getTitleFontString } from \"../helpers/style\";\nimport { includes } from \"../helpers/utils\";\nconst RECT_SIZE = 4;\n\nfunction hasNeedRender(index, pointOnColumn, labelInterval, innerRadius, outerRadius) {\n  return !pointOnColumn && index === 0 ? false : !(index % labelInterval) && (pointOnColumn && innerRadius <= outerRadius || !pointOnColumn && innerRadius < outerRadius);\n}\n\nexport default class RadialAxis extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      dot: [],\n      verticalAxisLabel: [],\n      circularAxisLabel: []\n    };\n  }\n\n  initialize() {\n    this.type = 'axis';\n    this.name = 'radial';\n  }\n\n  render({\n    layout,\n    radialAxes,\n    theme\n  }) {\n    this.rect = layout.plot;\n\n    if (!radialAxes) {\n      return;\n    }\n\n    this.verticalAxisTheme = theme.verticalAxis;\n    this.circularAxisTheme = theme.circularAxis;\n    this.models.verticalAxisLabel = this.renderVerticalAxisLabel(radialAxes.verticalAxis);\n    this.models.dot = this.renderDotModel(radialAxes.circularAxis);\n    this.models.circularAxisLabel = this.renderCircularAxisLabel(radialAxes.circularAxis);\n  }\n\n  getBubbleShadowStyle() {\n    const {\n      visible,\n      shadowColor,\n      shadowOffsetX,\n      shadowOffsetY,\n      shadowBlur\n    } = this.verticalAxisTheme.label.textBubble;\n    return visible && shadowColor ? [{\n      shadowColor,\n      shadowOffsetX,\n      shadowOffsetY,\n      shadowBlur\n    }] : null;\n  }\n\n  renderVerticalAxisLabel(verticalAxis) {\n    const {\n      radiusRanges,\n      pointOnColumn,\n      centerX,\n      centerY,\n      labels,\n      tickDistance,\n      labelInterval,\n      maxLabelWidth,\n      maxLabelHeight,\n      labelMargin,\n      labelAlign: textAlign,\n      outerRadius,\n      startAngle\n    } = verticalAxis;\n    const labelAdjustment = pointOnColumn ? tickDistance / 2 : 0;\n    const font = getTitleFontString(this.verticalAxisTheme.label);\n    const {\n      visible: textBubbleVisible,\n      backgroundColor,\n      borderRadius,\n      borderColor,\n      borderWidth,\n      paddingX,\n      paddingY\n    } = this.verticalAxisTheme.label.textBubble;\n    const labelPaddingX = textBubbleVisible ? paddingX : 0;\n    const labelPaddingY = textBubbleVisible ? paddingY : 0;\n    const width = maxLabelWidth + labelPaddingX * 2 - labelMargin;\n    const height = maxLabelHeight + labelPaddingY * 2;\n    const fontColor = this.verticalAxisTheme.label.color;\n    return radiusRanges.reduce((acc, radius, index) => {\n      const {\n        x,\n        y\n      } = getRadialPosition(centerX, centerY, radius - labelAdjustment, calculateDegreeToRadian(startAngle));\n      const needRender = hasNeedRender(index, pointOnColumn, labelInterval, radius, outerRadius);\n      let posX = x + labelMargin;\n      let labelPosX = x + labelMargin + labelPaddingX;\n\n      if (textAlign === 'center') {\n        posX = x - labelMargin - width / 2;\n        labelPosX = x - labelMargin;\n      } else if (includes(['right', 'end'], textAlign)) {\n        posX = x - labelMargin - width;\n        labelPosX = x - labelMargin - labelPaddingX;\n      }\n\n      return needRender ? [...acc, {\n        type: 'bubbleLabel',\n        rotationPosition: {\n          x,\n          y\n        },\n        radian: calculateDegreeToRadian(startAngle, 0),\n        bubble: {\n          x: posX,\n          y: y - height / 2,\n          width,\n          height,\n          align: textAlign,\n          radius: borderRadius,\n          fill: backgroundColor,\n          lineWidth: borderWidth,\n          strokeStyle: borderColor,\n          style: this.getBubbleShadowStyle()\n        },\n        label: {\n          text: labels[index],\n          x: labelPosX,\n          y,\n          style: [{\n            font,\n            fillStyle: fontColor,\n            textAlign,\n            textBaseline: 'middle'\n          }]\n        }\n      }] : acc;\n    }, []);\n  }\n\n  renderDotModel(circularAxis) {\n    const {\n      degree,\n      centerX,\n      centerY,\n      labels,\n      labelInterval,\n      outerRadius,\n      drawingStartAngle,\n      clockwise\n    } = circularAxis;\n    const {\n      dotColor\n    } = this.circularAxisTheme;\n    return labels.reduce((acc, cur, index) => {\n      const startDegree = drawingStartAngle + degree * index * (clockwise ? 1 : -1);\n      const {\n        x,\n        y\n      } = getRadialPosition(centerX, centerY, outerRadius, calculateDegreeToRadian(startDegree));\n      return index % labelInterval === 0 ? [...acc, {\n        type: 'rect',\n        color: dotColor,\n        width: RECT_SIZE,\n        height: RECT_SIZE,\n        x: x - RECT_SIZE / 2,\n        y: y - RECT_SIZE / 2\n      }] : acc;\n    }, []);\n  }\n\n  renderCircularAxisLabel(circularAxis) {\n    const {\n      centerX,\n      centerY,\n      labels,\n      labelInterval,\n      totalAngle,\n      drawingStartAngle,\n      labelMargin,\n      clockwise,\n      outerRadius\n    } = circularAxis;\n    const radius = outerRadius + labelMargin;\n    const labelTheme = this.circularAxisTheme.label;\n    const font = getTitleFontString(labelTheme);\n    const degree = circularAxis.degree * (clockwise ? 1 : -1);\n    return labels.reduce((acc, text, index) => {\n      const startDegree = drawingStartAngle + degree * index;\n      const endDegree = drawingStartAngle + degree * (index + 1);\n      const degreeRange = {\n        start: startDegree,\n        end: endDegree\n      };\n      const textAlign = getRadialLabelAlign({\n        totalAngle,\n        degree: degreeRange,\n        drawingStartAngle: 0\n      }, 'outer', false);\n      return index % labelInterval === 0 ? [...acc, Object.assign({\n        type: 'label',\n        style: [{\n          textAlign,\n          font,\n          fillStyle: labelTheme.color\n        }],\n        text\n      }, getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(startDegree)))] : acc;\n    }, []);\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/radialAxis.js"],"names":["Component","calculateDegreeToRadian","getRadialPosition","getRadialLabelAlign","getTitleFontString","includes","RECT_SIZE","hasNeedRender","index","pointOnColumn","labelInterval","innerRadius","outerRadius","RadialAxis","constructor","arguments","models","dot","verticalAxisLabel","circularAxisLabel","initialize","type","name","render","layout","radialAxes","theme","rect","plot","verticalAxisTheme","verticalAxis","circularAxisTheme","circularAxis","renderVerticalAxisLabel","renderDotModel","renderCircularAxisLabel","getBubbleShadowStyle","visible","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","label","textBubble","radiusRanges","centerX","centerY","labels","tickDistance","maxLabelWidth","maxLabelHeight","labelMargin","labelAlign","textAlign","startAngle","labelAdjustment","font","textBubbleVisible","backgroundColor","borderRadius","borderColor","borderWidth","paddingX","paddingY","labelPaddingX","labelPaddingY","width","height","fontColor","color","reduce","acc","radius","x","y","needRender","posX","labelPosX","rotationPosition","radian","bubble","align","fill","lineWidth","strokeStyle","style","text","fillStyle","textBaseline","degree","drawingStartAngle","clockwise","dotColor","cur","startDegree","totalAngle","labelTheme","endDegree","degreeRange","start","end","Object","assign"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { calculateDegreeToRadian, getRadialPosition, getRadialLabelAlign, } from \"../helpers/sector\";\nimport { getTitleFontString } from \"../helpers/style\";\nimport { includes } from \"../helpers/utils\";\nconst RECT_SIZE = 4;\nfunction hasNeedRender(index, pointOnColumn, labelInterval, innerRadius, outerRadius) {\n    return !pointOnColumn && index === 0\n        ? false\n        : !(index % labelInterval) &&\n            ((pointOnColumn && innerRadius <= outerRadius) ||\n                (!pointOnColumn && innerRadius < outerRadius));\n}\nexport default class RadialAxis extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { dot: [], verticalAxisLabel: [], circularAxisLabel: [] };\n    }\n    initialize() {\n        this.type = 'axis';\n        this.name = 'radial';\n    }\n    render({ layout, radialAxes, theme }) {\n        this.rect = layout.plot;\n        if (!radialAxes) {\n            return;\n        }\n        this.verticalAxisTheme = theme.verticalAxis;\n        this.circularAxisTheme = theme.circularAxis;\n        this.models.verticalAxisLabel = this.renderVerticalAxisLabel(radialAxes.verticalAxis);\n        this.models.dot = this.renderDotModel(radialAxes.circularAxis);\n        this.models.circularAxisLabel = this.renderCircularAxisLabel(radialAxes.circularAxis);\n    }\n    getBubbleShadowStyle() {\n        const { visible, shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur, } = this.verticalAxisTheme.label.textBubble;\n        return visible && shadowColor\n            ? [\n                {\n                    shadowColor,\n                    shadowOffsetX,\n                    shadowOffsetY,\n                    shadowBlur,\n                },\n            ]\n            : null;\n    }\n    renderVerticalAxisLabel(verticalAxis) {\n        const { radiusRanges, pointOnColumn, centerX, centerY, labels, tickDistance, labelInterval, maxLabelWidth, maxLabelHeight, labelMargin, labelAlign: textAlign, outerRadius, startAngle, } = verticalAxis;\n        const labelAdjustment = pointOnColumn ? tickDistance / 2 : 0;\n        const font = getTitleFontString(this.verticalAxisTheme.label);\n        const { visible: textBubbleVisible, backgroundColor, borderRadius, borderColor, borderWidth, paddingX, paddingY, } = this.verticalAxisTheme.label.textBubble;\n        const labelPaddingX = textBubbleVisible ? paddingX : 0;\n        const labelPaddingY = textBubbleVisible ? paddingY : 0;\n        const width = maxLabelWidth + labelPaddingX * 2 - labelMargin;\n        const height = maxLabelHeight + labelPaddingY * 2;\n        const fontColor = this.verticalAxisTheme.label.color;\n        return radiusRanges.reduce((acc, radius, index) => {\n            const { x, y } = getRadialPosition(centerX, centerY, radius - labelAdjustment, calculateDegreeToRadian(startAngle));\n            const needRender = hasNeedRender(index, pointOnColumn, labelInterval, radius, outerRadius);\n            let posX = x + labelMargin;\n            let labelPosX = x + labelMargin + labelPaddingX;\n            if (textAlign === 'center') {\n                posX = x - labelMargin - width / 2;\n                labelPosX = x - labelMargin;\n            }\n            else if (includes(['right', 'end'], textAlign)) {\n                posX = x - labelMargin - width;\n                labelPosX = x - labelMargin - labelPaddingX;\n            }\n            return needRender\n                ? [\n                    ...acc,\n                    {\n                        type: 'bubbleLabel',\n                        rotationPosition: { x, y },\n                        radian: calculateDegreeToRadian(startAngle, 0),\n                        bubble: {\n                            x: posX,\n                            y: y - height / 2,\n                            width,\n                            height,\n                            align: textAlign,\n                            radius: borderRadius,\n                            fill: backgroundColor,\n                            lineWidth: borderWidth,\n                            strokeStyle: borderColor,\n                            style: this.getBubbleShadowStyle(),\n                        },\n                        label: {\n                            text: labels[index],\n                            x: labelPosX,\n                            y,\n                            style: [{ font, fillStyle: fontColor, textAlign, textBaseline: 'middle' }],\n                        },\n                    },\n                ]\n                : acc;\n        }, []);\n    }\n    renderDotModel(circularAxis) {\n        const { degree, centerX, centerY, labels, labelInterval, outerRadius, drawingStartAngle, clockwise, } = circularAxis;\n        const { dotColor } = this.circularAxisTheme;\n        return labels.reduce((acc, cur, index) => {\n            const startDegree = drawingStartAngle + degree * index * (clockwise ? 1 : -1);\n            const { x, y } = getRadialPosition(centerX, centerY, outerRadius, calculateDegreeToRadian(startDegree));\n            return index % labelInterval === 0\n                ? [\n                    ...acc,\n                    {\n                        type: 'rect',\n                        color: dotColor,\n                        width: RECT_SIZE,\n                        height: RECT_SIZE,\n                        x: x - RECT_SIZE / 2,\n                        y: y - RECT_SIZE / 2,\n                    },\n                ]\n                : acc;\n        }, []);\n    }\n    renderCircularAxisLabel(circularAxis) {\n        const { centerX, centerY, labels, labelInterval, totalAngle, drawingStartAngle, labelMargin, clockwise, outerRadius, } = circularAxis;\n        const radius = outerRadius + labelMargin;\n        const labelTheme = this.circularAxisTheme.label;\n        const font = getTitleFontString(labelTheme);\n        const degree = circularAxis.degree * (clockwise ? 1 : -1);\n        return labels.reduce((acc, text, index) => {\n            const startDegree = drawingStartAngle + degree * index;\n            const endDegree = drawingStartAngle + degree * (index + 1);\n            const degreeRange = {\n                start: startDegree,\n                end: endDegree,\n            };\n            const textAlign = getRadialLabelAlign({\n                totalAngle,\n                degree: degreeRange,\n                drawingStartAngle: 0,\n            }, 'outer', false);\n            return index % labelInterval === 0\n                ? [\n                    ...acc,\n                    Object.assign({ type: 'label', style: [{ textAlign, font, fillStyle: labelTheme.color }], text }, getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(startDegree))),\n                ]\n                : acc;\n        }, []);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}