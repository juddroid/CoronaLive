{"ast":null,"code":"import { getAxisName, getSizeKey, hasBoxTypeSeries, isLabelAxisOnYAxis, isPointOnColumn, getYAxisOption, getAxisTheme, getViewAxisLabels, hasAxesLayoutChanged, getRotatableOption, makeFormattedCategory, getMaxLabelSize, makeTitleOption, makeRotationData, getLabelXMargin, getInitAxisIntervalData } from \"../helpers/axes\";\nimport { makeLabelsFromLimit, getAxisLabelAnchorPoint } from \"../helpers/calculator\";\nimport { deepMergedCopy, hasNegativeOnly, isNumber, pickProperty } from \"../helpers/utils\";\nimport { isZooming } from \"../helpers/range\";\nimport { isCoordinateSeries } from \"../helpers/coordinate\";\nimport { AxisType } from \"../component/axis\";\nimport { getTitleFontString } from \"../helpers/style\";\nexport function isCenterYAxis(options, isBar) {\n  var _a;\n\n  const diverging = !!pickProperty(options, ['series', 'diverging']);\n  const alignCenter = ((_a = options.yAxis) === null || _a === void 0 ? void 0 : _a.align) === 'center';\n  return isBar && diverging && alignCenter;\n}\n\nfunction isDivergingBoxSeries(series, options) {\n  var _a;\n\n  return hasBoxTypeSeries(series) && !!((_a = options.series) === null || _a === void 0 ? void 0 : _a.diverging);\n}\n\nfunction getZeroPosition(limit, axisSize, labelAxisOnYAxis, isDivergingSeries) {\n  const {\n    min,\n    max\n  } = limit;\n  const hasZeroValue = min <= 0 && max >= 0;\n\n  if (!hasZeroValue || isDivergingSeries) {\n    return null;\n  }\n\n  const position = (0 - min) / (max - min) * axisSize;\n  return labelAxisOnYAxis ? position : axisSize - position;\n}\n\nfunction getAxisFormatter(options, axisName) {\n  var _a, _b, _c;\n\n  const axisOptions = Object.assign(Object.assign({}, getYAxisOption(options)), {\n    xAxis: options.xAxis\n  });\n  return _c = (_b = (_a = axisOptions[axisName]) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.formatter, _c !== null && _c !== void 0 ? _c : value => value;\n}\n\nexport function getLabelAxisData(stateProp) {\n  var _a, _b;\n\n  const {\n    axisSize,\n    categories,\n    series,\n    options,\n    theme,\n    scale,\n    zoomRange,\n    rawCategories,\n    initialAxisData,\n    isCoordinateTypeChart,\n    axisName\n  } = stateProp;\n  const pointOnColumn = isPointOnColumn(series, options);\n  const labelsBeforeFormatting = !isZooming(rawCategories, zoomRange) && isCoordinateTypeChart ? makeLabelsFromLimit(scale.limit, scale.stepSize, options) : makeFormattedCategory(categories, (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.date);\n  const formatter = getAxisFormatter(options, axisName); // @TODO: regenerate label when exceeding max width\n\n  const labels = labelsBeforeFormatting.map((label, index) => formatter(label, {\n    index,\n    labels: labelsBeforeFormatting,\n    axisName\n  }));\n  const tickIntervalCount = categories.length - (pointOnColumn ? 0 : 1);\n  const tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;\n  const labelDistance = axisSize / (labels.length - (pointOnColumn ? 0 : 1));\n  const tickCount = labels.length + (pointOnColumn ? 1 : 0);\n  const viewLabels = getViewAxisLabels(Object.assign({\n    labels,\n    pointOnColumn,\n    tickDistance,\n    tickCount\n  }, initialAxisData), axisSize);\n  const axisLabelMargin = getLabelXMargin(axisName, options);\n  return Object.assign(Object.assign({\n    labels,\n    viewLabels,\n    pointOnColumn,\n    labelDistance,\n    tickDistance,\n    tickCount,\n    isLabelAxis: true\n  }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));\n}\n\nfunction getValueAxisData(stateProp) {\n  var _a;\n\n  const {\n    scale,\n    axisSize,\n    series,\n    options,\n    centerYAxis,\n    initialAxisData,\n    theme,\n    labelOnYAxis,\n    axisName\n  } = stateProp;\n  const {\n    limit,\n    stepSize\n  } = scale;\n  const size = centerYAxis ? (_a = centerYAxis) === null || _a === void 0 ? void 0 : _a.xAxisHalfSize : axisSize;\n  const divergingBoxSeries = isDivergingBoxSeries(series, options);\n  const formatter = getAxisFormatter(options, axisName);\n  const zeroPosition = getZeroPosition(limit, axisSize, isLabelAxisOnYAxis(series, options), divergingBoxSeries);\n  let valueLabels = makeLabelsFromLimit(limit, stepSize);\n\n  if (!centerYAxis && divergingBoxSeries) {\n    valueLabels = getDivergingValues(valueLabels);\n  }\n\n  const labels = valueLabels.map((label, index) => formatter(label, {\n    index,\n    labels: valueLabels,\n    axisName\n  }));\n  const tickDistance = size / Math.max(valueLabels.length, 1);\n  const tickCount = valueLabels.length;\n  const pointOnColumn = false;\n  const viewLabels = getViewAxisLabels(Object.assign({\n    labels: labelOnYAxis ? labels : [...labels].reverse(),\n    pointOnColumn,\n    tickDistance,\n    tickCount\n  }, initialAxisData), size);\n  const axisLabelMargin = getLabelXMargin(axisName, options);\n  const axisData = Object.assign(Object.assign({\n    labels,\n    viewLabels,\n    pointOnColumn,\n    isLabelAxis: false,\n    tickCount,\n    tickDistance\n  }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));\n\n  if (isNumber(zeroPosition)) {\n    axisData.zeroPosition = zeroPosition;\n  }\n\n  return axisData;\n}\n\nfunction getDivergingValues(valueLabels) {\n  return hasNegativeOnly(valueLabels) ? valueLabels.reverse().slice(1).concat(valueLabels) : valueLabels.slice(1).reverse().concat(valueLabels);\n}\n\nfunction makeDefaultAxisData(isLabelAxis, params) {\n  var _a, _b;\n\n  const axisData = getInitAxisIntervalData(isLabelAxis, params);\n  const title = makeTitleOption((_b = (_a = params) === null || _a === void 0 ? void 0 : _a.axis) === null || _b === void 0 ? void 0 : _b.title);\n\n  if (title) {\n    axisData.title = title;\n  }\n\n  return axisData;\n}\n\nfunction getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart) {\n  var _a, _b, _c;\n\n  const {\n    yAxis,\n    secondaryYAxis\n  } = getYAxisOption(options);\n  const shift = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.shift;\n  return {\n    xAxis: makeDefaultAxisData(!labelOnYAxis, {\n      categories,\n      axis: (_c = options) === null || _c === void 0 ? void 0 : _c.xAxis,\n      layout,\n      shift,\n      isCoordinateTypeChart\n    }),\n    yAxis: makeDefaultAxisData(labelOnYAxis, {\n      axis: yAxis\n    }),\n    secondaryYAxis: secondaryYAxis ? makeDefaultAxisData(labelOnYAxis, {\n      axis: secondaryYAxis\n    }) : null\n  };\n}\n\nfunction getSecondaryYAxisData({\n  state,\n  labelOnYAxis,\n  valueAxisSize,\n  labelAxisSize,\n  initialAxisData,\n  isCoordinateTypeChart\n}) {\n  var _a, _b;\n\n  const {\n    scale,\n    options,\n    series,\n    zoomRange,\n    theme\n  } = state;\n  const categories = state.categories;\n  const rawCategories = state.rawCategories;\n  return labelOnYAxis ? getLabelAxisData({\n    scale: scale.secondaryYAxis,\n    axisSize: labelAxisSize,\n    categories: (_b = (_a = getYAxisOption(options).secondaryYAxis) === null || _a === void 0 ? void 0 : _a.categories, _b !== null && _b !== void 0 ? _b : categories),\n    rawCategories,\n    options,\n    series,\n    theme: getAxisTheme(theme, AxisType.SECONDARY_Y),\n    zoomRange,\n    initialAxisData,\n    isCoordinateTypeChart,\n    axisName: AxisType.SECONDARY_Y\n  }) : getValueAxisData({\n    scale: scale.secondaryYAxis,\n    axisSize: valueAxisSize,\n    options,\n    series,\n    theme: getAxisTheme(theme, AxisType.SECONDARY_Y),\n    centerYAxis: null,\n    initialAxisData,\n    axisName: AxisType.SECONDARY_Y\n  });\n}\n\nfunction makeXAxisData({\n  axisData,\n  axisSize,\n  centerYAxis,\n  rotatable,\n  labelMargin = 0\n}) {\n  const {\n    viewLabels,\n    pointOnColumn,\n    maxLabelWidth,\n    maxLabelHeight\n  } = axisData;\n  const offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;\n  const size = centerYAxis ? centerYAxis.xAxisHalfSize : axisSize;\n  const distance = size / (viewLabels.length - (pointOnColumn ? 0 : 1));\n  const rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable);\n  const {\n    needRotateLabel,\n    rotationHeight\n  } = rotationData;\n  const maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;\n  return Object.assign(Object.assign(Object.assign({}, axisData), rotationData), {\n    maxHeight,\n    offsetY\n  });\n}\n\nfunction getAxisInfo(labelOnYAxis, plot, series) {\n  const {\n    valueAxisName,\n    labelAxisName\n  } = getAxisName(labelOnYAxis, series);\n  const {\n    valueSizeKey,\n    labelSizeKey\n  } = getSizeKey(labelOnYAxis);\n  const valueAxisSize = plot[valueSizeKey];\n  const labelAxisSize = plot[labelSizeKey];\n  return {\n    valueAxisName,\n    valueAxisSize,\n    labelAxisName,\n    labelAxisSize\n  };\n}\n\nfunction getCategoriesWithTypes(categories, rawCategories) {\n  var _a, _b;\n\n  return {\n    categories: (_a = categories, _a !== null && _a !== void 0 ? _a : []),\n    rawCategories: (_b = rawCategories, _b !== null && _b !== void 0 ? _b : [])\n  };\n}\n\nconst axes = {\n  name: 'axes',\n  state: ({\n    series,\n    options\n  }) => {\n    const {\n      secondaryYAxis\n    } = getYAxisOption(options);\n    const axesState = {\n      xAxis: {},\n      yAxis: {}\n    };\n\n    if (isCenterYAxis(options, !!series.bar)) {\n      axesState.centerYAxis = {};\n    }\n\n    if (secondaryYAxis) {\n      axesState.secondaryYAxis = {};\n    }\n\n    return {\n      axes: axesState\n    };\n  },\n  action: {\n    setAxesData({\n      state,\n      initStoreState\n    }) {\n      var _a, _b;\n\n      const {\n        scale,\n        options,\n        series,\n        layout,\n        zoomRange,\n        theme\n      } = state;\n      const {\n        xAxis,\n        yAxis,\n        plot\n      } = layout;\n      const isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);\n      const labelOnYAxis = isLabelAxisOnYAxis(series, options);\n      const {\n        categories,\n        rawCategories\n      } = getCategoriesWithTypes(state.categories, state.rawCategories);\n      const {\n        valueAxisName,\n        valueAxisSize,\n        labelAxisName,\n        labelAxisSize\n      } = getAxisInfo(labelOnYAxis, plot, series);\n      const hasCenterYAxis = state.axes.centerYAxis;\n      const initialAxisData = getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart);\n      const valueAxisData = getValueAxisData({\n        scale: scale[valueAxisName],\n        axisSize: valueAxisSize,\n        options,\n        series,\n        theme: getAxisTheme(theme, valueAxisName),\n        centerYAxis: hasCenterYAxis ? {\n          xAxisHalfSize: (xAxis.width - yAxis.width) / 2\n        } : null,\n        initialAxisData: initialAxisData[valueAxisName],\n        labelOnYAxis,\n        axisName: valueAxisName\n      });\n      const labelAxisData = getLabelAxisData({\n        scale: scale[labelAxisName],\n        axisSize: labelAxisSize,\n        categories,\n        rawCategories,\n        options,\n        series,\n        theme: getAxisTheme(theme, labelAxisName),\n        zoomRange,\n        initialAxisData: initialAxisData[labelAxisName],\n        isCoordinateTypeChart,\n        labelOnYAxis,\n        axisName: labelAxisName\n      });\n      let secondaryYAxis, centerYAxis;\n\n      if (state.axes.secondaryYAxis) {\n        secondaryYAxis = getSecondaryYAxisData({\n          state,\n          labelOnYAxis,\n          valueAxisSize,\n          labelAxisSize,\n          labelAxisName,\n          valueAxisName,\n          initialAxisData: initialAxisData.secondaryYAxis,\n          isCoordinateTypeChart\n        });\n      }\n\n      if (hasCenterYAxis) {\n        const xAxisHalfSize = (xAxis.width - yAxis.width) / 2;\n        centerYAxis = deepMergedCopy(valueAxisData, {\n          x: xAxis.x + xAxisHalfSize,\n          xAxisHalfSize,\n          secondStartX: (xAxis.width + yAxis.width) / 2,\n          yAxisLabelAnchorPoint: yAxis.width / 2,\n          yAxisHeight: yAxis.height\n        });\n      }\n\n      const axesState = {\n        xAxis: makeXAxisData({\n          axisData: labelOnYAxis ? valueAxisData : labelAxisData,\n          axisSize: labelOnYAxis ? valueAxisSize : labelAxisSize,\n          centerYAxis,\n          rotatable: getRotatableOption(options),\n          labelMargin: (_b = (_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.margin\n        }),\n        yAxis: labelOnYAxis ? labelAxisData : valueAxisData,\n        secondaryYAxis,\n        centerYAxis\n      };\n\n      if (hasAxesLayoutChanged(state.axes, axesState)) {\n        this.notify(state, 'layout');\n      }\n\n      state.axes = axesState;\n    }\n\n  },\n  computed: {},\n  observe: {\n    updateAxes() {\n      this.dispatch('setAxesData');\n    }\n\n  }\n};\nexport default axes;","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/store/axes.js"],"names":["getAxisName","getSizeKey","hasBoxTypeSeries","isLabelAxisOnYAxis","isPointOnColumn","getYAxisOption","getAxisTheme","getViewAxisLabels","hasAxesLayoutChanged","getRotatableOption","makeFormattedCategory","getMaxLabelSize","makeTitleOption","makeRotationData","getLabelXMargin","getInitAxisIntervalData","makeLabelsFromLimit","getAxisLabelAnchorPoint","deepMergedCopy","hasNegativeOnly","isNumber","pickProperty","isZooming","isCoordinateSeries","AxisType","getTitleFontString","isCenterYAxis","options","isBar","_a","diverging","alignCenter","yAxis","align","isDivergingBoxSeries","series","getZeroPosition","limit","axisSize","labelAxisOnYAxis","isDivergingSeries","min","max","hasZeroValue","position","getAxisFormatter","axisName","_b","_c","axisOptions","Object","assign","xAxis","label","formatter","value","getLabelAxisData","stateProp","categories","theme","scale","zoomRange","rawCategories","initialAxisData","isCoordinateTypeChart","pointOnColumn","labelsBeforeFormatting","stepSize","date","labels","map","index","tickIntervalCount","length","tickDistance","labelDistance","tickCount","viewLabels","axisLabelMargin","isLabelAxis","getValueAxisData","centerYAxis","labelOnYAxis","size","xAxisHalfSize","divergingBoxSeries","zeroPosition","valueLabels","getDivergingValues","Math","reverse","axisData","slice","concat","makeDefaultAxisData","params","title","axis","getInitialAxisData","layout","secondaryYAxis","shift","getSecondaryYAxisData","state","valueAxisSize","labelAxisSize","SECONDARY_Y","makeXAxisData","rotatable","labelMargin","maxLabelWidth","maxLabelHeight","offsetY","distance","rotationData","needRotateLabel","rotationHeight","maxHeight","getAxisInfo","plot","valueAxisName","labelAxisName","valueSizeKey","labelSizeKey","getCategoriesWithTypes","axes","name","axesState","bar","action","setAxesData","initStoreState","hasCenterYAxis","valueAxisData","width","labelAxisData","x","secondStartX","yAxisLabelAnchorPoint","yAxisHeight","height","margin","notify","computed","observe","updateAxes","dispatch"],"mappings":"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","sourcesContent":["import { getAxisName, getSizeKey, hasBoxTypeSeries, isLabelAxisOnYAxis, isPointOnColumn, getYAxisOption, getAxisTheme, getViewAxisLabels, hasAxesLayoutChanged, getRotatableOption, makeFormattedCategory, getMaxLabelSize, makeTitleOption, makeRotationData, getLabelXMargin, getInitAxisIntervalData, } from \"../helpers/axes\";\nimport { makeLabelsFromLimit, getAxisLabelAnchorPoint } from \"../helpers/calculator\";\nimport { deepMergedCopy, hasNegativeOnly, isNumber, pickProperty } from \"../helpers/utils\";\nimport { isZooming } from \"../helpers/range\";\nimport { isCoordinateSeries } from \"../helpers/coordinate\";\nimport { AxisType } from \"../component/axis\";\nimport { getTitleFontString } from \"../helpers/style\";\nexport function isCenterYAxis(options, isBar) {\n    var _a;\n    const diverging = !!pickProperty(options, ['series', 'diverging']);\n    const alignCenter = ((_a = options.yAxis) === null || _a === void 0 ? void 0 : _a.align) === 'center';\n    return isBar && diverging && alignCenter;\n}\nfunction isDivergingBoxSeries(series, options) {\n    var _a;\n    return hasBoxTypeSeries(series) && !!((_a = options.series) === null || _a === void 0 ? void 0 : _a.diverging);\n}\nfunction getZeroPosition(limit, axisSize, labelAxisOnYAxis, isDivergingSeries) {\n    const { min, max } = limit;\n    const hasZeroValue = min <= 0 && max >= 0;\n    if (!hasZeroValue || isDivergingSeries) {\n        return null;\n    }\n    const position = ((0 - min) / (max - min)) * axisSize;\n    return labelAxisOnYAxis ? position : axisSize - position;\n}\nfunction getAxisFormatter(options, axisName) {\n    var _a, _b, _c;\n    const axisOptions = Object.assign(Object.assign({}, getYAxisOption(options)), { xAxis: options.xAxis });\n    return _c = (_b = (_a = axisOptions[axisName]) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.formatter, (_c !== null && _c !== void 0 ? _c : ((value) => value));\n}\nexport function getLabelAxisData(stateProp) {\n    var _a, _b;\n    const { axisSize, categories, series, options, theme, scale, zoomRange, rawCategories, initialAxisData, isCoordinateTypeChart, axisName, } = stateProp;\n    const pointOnColumn = isPointOnColumn(series, options);\n    const labelsBeforeFormatting = !isZooming(rawCategories, zoomRange) && isCoordinateTypeChart\n        ? makeLabelsFromLimit(scale.limit, scale.stepSize, options)\n        : makeFormattedCategory(categories, (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.date);\n    const formatter = getAxisFormatter(options, axisName);\n    // @TODO: regenerate label when exceeding max width\n    const labels = labelsBeforeFormatting.map((label, index) => formatter(label, { index, labels: labelsBeforeFormatting, axisName }));\n    const tickIntervalCount = categories.length - (pointOnColumn ? 0 : 1);\n    const tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;\n    const labelDistance = axisSize / (labels.length - (pointOnColumn ? 0 : 1));\n    const tickCount = labels.length + (pointOnColumn ? 1 : 0);\n    const viewLabels = getViewAxisLabels(Object.assign({ labels,\n        pointOnColumn,\n        tickDistance,\n        tickCount }, initialAxisData), axisSize);\n    const axisLabelMargin = getLabelXMargin(axisName, options);\n    return Object.assign(Object.assign({ labels,\n        viewLabels,\n        pointOnColumn,\n        labelDistance,\n        tickDistance,\n        tickCount, isLabelAxis: true }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));\n}\nfunction getValueAxisData(stateProp) {\n    var _a;\n    const { scale, axisSize, series, options, centerYAxis, initialAxisData, theme, labelOnYAxis, axisName, } = stateProp;\n    const { limit, stepSize } = scale;\n    const size = centerYAxis ? (_a = centerYAxis) === null || _a === void 0 ? void 0 : _a.xAxisHalfSize : axisSize;\n    const divergingBoxSeries = isDivergingBoxSeries(series, options);\n    const formatter = getAxisFormatter(options, axisName);\n    const zeroPosition = getZeroPosition(limit, axisSize, isLabelAxisOnYAxis(series, options), divergingBoxSeries);\n    let valueLabels = makeLabelsFromLimit(limit, stepSize);\n    if (!centerYAxis && divergingBoxSeries) {\n        valueLabels = getDivergingValues(valueLabels);\n    }\n    const labels = valueLabels.map((label, index) => formatter(label, { index, labels: valueLabels, axisName }));\n    const tickDistance = size / Math.max(valueLabels.length, 1);\n    const tickCount = valueLabels.length;\n    const pointOnColumn = false;\n    const viewLabels = getViewAxisLabels(Object.assign({ labels: labelOnYAxis ? labels : [...labels].reverse(), pointOnColumn,\n        tickDistance,\n        tickCount }, initialAxisData), size);\n    const axisLabelMargin = getLabelXMargin(axisName, options);\n    const axisData = Object.assign(Object.assign({ labels,\n        viewLabels,\n        pointOnColumn, isLabelAxis: false, tickCount,\n        tickDistance }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));\n    if (isNumber(zeroPosition)) {\n        axisData.zeroPosition = zeroPosition;\n    }\n    return axisData;\n}\nfunction getDivergingValues(valueLabels) {\n    return hasNegativeOnly(valueLabels)\n        ? valueLabels.reverse().slice(1).concat(valueLabels)\n        : valueLabels.slice(1).reverse().concat(valueLabels);\n}\nfunction makeDefaultAxisData(isLabelAxis, params) {\n    var _a, _b;\n    const axisData = getInitAxisIntervalData(isLabelAxis, params);\n    const title = makeTitleOption((_b = (_a = params) === null || _a === void 0 ? void 0 : _a.axis) === null || _b === void 0 ? void 0 : _b.title);\n    if (title) {\n        axisData.title = title;\n    }\n    return axisData;\n}\nfunction getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart) {\n    var _a, _b, _c;\n    const { yAxis, secondaryYAxis } = getYAxisOption(options);\n    const shift = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.shift;\n    return {\n        xAxis: makeDefaultAxisData(!labelOnYAxis, {\n            categories,\n            axis: (_c = options) === null || _c === void 0 ? void 0 : _c.xAxis,\n            layout,\n            shift,\n            isCoordinateTypeChart,\n        }),\n        yAxis: makeDefaultAxisData(labelOnYAxis, { axis: yAxis }),\n        secondaryYAxis: secondaryYAxis\n            ? makeDefaultAxisData(labelOnYAxis, { axis: secondaryYAxis })\n            : null,\n    };\n}\nfunction getSecondaryYAxisData({ state, labelOnYAxis, valueAxisSize, labelAxisSize, initialAxisData, isCoordinateTypeChart, }) {\n    var _a, _b;\n    const { scale, options, series, zoomRange, theme } = state;\n    const categories = state.categories;\n    const rawCategories = state.rawCategories;\n    return labelOnYAxis\n        ? getLabelAxisData({\n            scale: scale.secondaryYAxis,\n            axisSize: labelAxisSize,\n            categories: (_b = (_a = getYAxisOption(options).secondaryYAxis) === null || _a === void 0 ? void 0 : _a.categories, (_b !== null && _b !== void 0 ? _b : categories)),\n            rawCategories,\n            options,\n            series,\n            theme: getAxisTheme(theme, AxisType.SECONDARY_Y),\n            zoomRange,\n            initialAxisData,\n            isCoordinateTypeChart,\n            axisName: AxisType.SECONDARY_Y,\n        })\n        : getValueAxisData({\n            scale: scale.secondaryYAxis,\n            axisSize: valueAxisSize,\n            options,\n            series,\n            theme: getAxisTheme(theme, AxisType.SECONDARY_Y),\n            centerYAxis: null,\n            initialAxisData,\n            axisName: AxisType.SECONDARY_Y,\n        });\n}\nfunction makeXAxisData({ axisData, axisSize, centerYAxis, rotatable, labelMargin = 0 }) {\n    const { viewLabels, pointOnColumn, maxLabelWidth, maxLabelHeight } = axisData;\n    const offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;\n    const size = centerYAxis ? centerYAxis.xAxisHalfSize : axisSize;\n    const distance = size / (viewLabels.length - (pointOnColumn ? 0 : 1));\n    const rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable);\n    const { needRotateLabel, rotationHeight } = rotationData;\n    const maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;\n    return Object.assign(Object.assign(Object.assign({}, axisData), rotationData), { maxHeight,\n        offsetY });\n}\nfunction getAxisInfo(labelOnYAxis, plot, series) {\n    const { valueAxisName, labelAxisName } = getAxisName(labelOnYAxis, series);\n    const { valueSizeKey, labelSizeKey } = getSizeKey(labelOnYAxis);\n    const valueAxisSize = plot[valueSizeKey];\n    const labelAxisSize = plot[labelSizeKey];\n    return { valueAxisName, valueAxisSize, labelAxisName, labelAxisSize };\n}\nfunction getCategoriesWithTypes(categories, rawCategories) {\n    var _a, _b;\n    return {\n        categories: (_a = categories, (_a !== null && _a !== void 0 ? _a : [])),\n        rawCategories: (_b = rawCategories, (_b !== null && _b !== void 0 ? _b : [])),\n    };\n}\nconst axes = {\n    name: 'axes',\n    state: ({ series, options }) => {\n        const { secondaryYAxis } = getYAxisOption(options);\n        const axesState = {\n            xAxis: {},\n            yAxis: {},\n        };\n        if (isCenterYAxis(options, !!series.bar)) {\n            axesState.centerYAxis = {};\n        }\n        if (secondaryYAxis) {\n            axesState.secondaryYAxis = {};\n        }\n        return {\n            axes: axesState,\n        };\n    },\n    action: {\n        setAxesData({ state, initStoreState }) {\n            var _a, _b;\n            const { scale, options, series, layout, zoomRange, theme } = state;\n            const { xAxis, yAxis, plot } = layout;\n            const isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);\n            const labelOnYAxis = isLabelAxisOnYAxis(series, options);\n            const { categories, rawCategories } = getCategoriesWithTypes(state.categories, state.rawCategories);\n            const { valueAxisName, valueAxisSize, labelAxisName, labelAxisSize } = getAxisInfo(labelOnYAxis, plot, series);\n            const hasCenterYAxis = state.axes.centerYAxis;\n            const initialAxisData = getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart);\n            const valueAxisData = getValueAxisData({\n                scale: scale[valueAxisName],\n                axisSize: valueAxisSize,\n                options,\n                series,\n                theme: getAxisTheme(theme, valueAxisName),\n                centerYAxis: hasCenterYAxis\n                    ? {\n                        xAxisHalfSize: (xAxis.width - yAxis.width) / 2,\n                    }\n                    : null,\n                initialAxisData: initialAxisData[valueAxisName],\n                labelOnYAxis,\n                axisName: valueAxisName,\n            });\n            const labelAxisData = getLabelAxisData({\n                scale: scale[labelAxisName],\n                axisSize: labelAxisSize,\n                categories,\n                rawCategories,\n                options,\n                series,\n                theme: getAxisTheme(theme, labelAxisName),\n                zoomRange,\n                initialAxisData: initialAxisData[labelAxisName],\n                isCoordinateTypeChart,\n                labelOnYAxis,\n                axisName: labelAxisName,\n            });\n            let secondaryYAxis, centerYAxis;\n            if (state.axes.secondaryYAxis) {\n                secondaryYAxis = getSecondaryYAxisData({\n                    state,\n                    labelOnYAxis,\n                    valueAxisSize,\n                    labelAxisSize,\n                    labelAxisName,\n                    valueAxisName,\n                    initialAxisData: initialAxisData.secondaryYAxis,\n                    isCoordinateTypeChart,\n                });\n            }\n            if (hasCenterYAxis) {\n                const xAxisHalfSize = (xAxis.width - yAxis.width) / 2;\n                centerYAxis = deepMergedCopy(valueAxisData, {\n                    x: xAxis.x + xAxisHalfSize,\n                    xAxisHalfSize,\n                    secondStartX: (xAxis.width + yAxis.width) / 2,\n                    yAxisLabelAnchorPoint: yAxis.width / 2,\n                    yAxisHeight: yAxis.height,\n                });\n            }\n            const axesState = {\n                xAxis: makeXAxisData({\n                    axisData: labelOnYAxis ? valueAxisData : labelAxisData,\n                    axisSize: labelOnYAxis ? valueAxisSize : labelAxisSize,\n                    centerYAxis,\n                    rotatable: getRotatableOption(options),\n                    labelMargin: (_b = (_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.margin,\n                }),\n                yAxis: labelOnYAxis ? labelAxisData : valueAxisData,\n                secondaryYAxis,\n                centerYAxis,\n            };\n            if (hasAxesLayoutChanged(state.axes, axesState)) {\n                this.notify(state, 'layout');\n            }\n            state.axes = axesState;\n        },\n    },\n    computed: {},\n    observe: {\n        updateAxes() {\n            this.dispatch('setAxesData');\n        },\n    },\n};\nexport default axes;\n"]},"metadata":{},"sourceType":"module"}