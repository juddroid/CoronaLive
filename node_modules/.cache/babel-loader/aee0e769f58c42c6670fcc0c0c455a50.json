{"ast":null,"code":"import { isFunction, includes, isBoolean, isString } from \"./utils\";\nimport { getTextWidth, getTextHeight } from \"./calculator\";\nimport { getRadialAnchorPosition, makeAnchorPositionParam, calculateDegreeToRadian, getRadialLabelAlign } from \"./sector\";\nimport { getFont } from \"./style\";\nexport const RADIUS_PADDING = 30;\nconst CALLOUT_LENGTH = 20;\n\nfunction getDefaultAnchor(type, withStack = false) {\n  let anchor = 'auto';\n\n  switch (type) {\n    case 'point':\n      anchor = 'center';\n      break;\n\n    case 'rect':\n      anchor = !withStack ? 'auto' : 'center';\n      break;\n\n    case 'sector':\n    case 'treemapSeriesName':\n      anchor = 'center';\n      break;\n\n    case 'stackTotal':\n      anchor = 'auto';\n      break;\n  }\n\n  return anchor;\n}\n\nfunction getAnchor(dataLabelOptions, type, withStack = false) {\n  return type !== 'stackTotal' && includes(['center', 'start', 'end', 'auto', 'outer'], dataLabelOptions.anchor) ? dataLabelOptions.anchor : getDefaultAnchor(type, withStack);\n}\n\nexport function getDefaultDataLabelsOptions(dataLabelOptions, type, withStack = false) {\n  var _a, _b, _c;\n\n  const anchor = getAnchor(dataLabelOptions, type, withStack);\n  const {\n    offsetX = 0,\n    offsetY = 0\n  } = dataLabelOptions;\n  const formatter = isFunction(dataLabelOptions.formatter) ? dataLabelOptions.formatter : value => String(value) || '';\n  const options = {\n    anchor,\n    offsetX,\n    offsetY,\n    formatter\n  };\n\n  if (withStack) {\n    const stackTotal = dataLabelOptions.stackTotal;\n    options.stackTotal = {\n      visible: isBoolean((_a = stackTotal) === null || _a === void 0 ? void 0 : _a.visible) ? stackTotal.visible : true,\n      formatter: isFunction((_b = stackTotal) === null || _b === void 0 ? void 0 : _b.formatter) ? stackTotal.formatter : formatter\n    };\n  }\n\n  if (type === 'sector' && ((_c = dataLabelOptions.pieSeriesName) === null || _c === void 0 ? void 0 : _c.visible)) {\n    options.pieSeriesName = Object.assign({\n      anchor: 'center'\n    }, dataLabelOptions.pieSeriesName);\n  }\n\n  return options;\n}\nexport function makePointLabelInfo(point, dataLabelOptions, rect) {\n  const {\n    width,\n    height\n  } = rect;\n  const {\n    anchor,\n    offsetX = 0,\n    offsetY = 0,\n    formatter\n  } = dataLabelOptions;\n  const {\n    name,\n    theme\n  } = point;\n  let textBaseline = 'middle';\n\n  if (anchor === 'end') {\n    textBaseline = 'bottom';\n  } else if (anchor === 'start') {\n    textBaseline = 'top';\n  }\n\n  const xWithOffset = point.x + offsetX;\n  const yWithOffset = point.y + offsetY;\n  const x = xWithOffset < 0 || xWithOffset > width ? point.x : xWithOffset;\n  const y = yWithOffset < 0 || yWithOffset > height ? point.y : yWithOffset;\n  return {\n    type: 'point',\n    x,\n    y,\n    text: formatter(point.value),\n    textAlign: 'center',\n    textBaseline,\n    name,\n    theme\n  };\n}\n\nfunction isHorizontal(direction) {\n  return includes(['left', 'right'], direction);\n}\n\nfunction makeHorizontalRectPosition(rect, anchor) {\n  const {\n    x,\n    y,\n    width,\n    height,\n    direction\n  } = rect;\n  const textBaseline = 'middle';\n  const posY = y + height / 2;\n  let textAlign = 'center';\n  let posX;\n\n  if (direction === 'right') {\n    switch (anchor) {\n      case 'start':\n        textAlign = 'left';\n        posX = x;\n        break;\n\n      case 'end':\n        textAlign = 'right';\n        posX = x + width;\n        break;\n\n      case 'center':\n        textAlign = 'center';\n        posX = x + width / 2;\n        break;\n\n      default:\n        textAlign = 'left';\n        posX = x + width;\n    }\n  } else {\n    switch (anchor) {\n      case 'start':\n        textAlign = 'right';\n        posX = x + width;\n        break;\n\n      case 'end':\n        textAlign = 'left';\n        posX = x;\n        break;\n\n      case 'center':\n        textAlign = 'center';\n        posX = x + width / 2;\n        break;\n\n      default:\n        textAlign = 'right';\n        posX = x;\n    }\n  }\n\n  return {\n    x: posX,\n    y: posY,\n    textAlign,\n    textBaseline\n  };\n}\n\nfunction makeVerticalRectPosition(rect, anchor) {\n  const {\n    x,\n    y,\n    width,\n    height,\n    direction\n  } = rect;\n  const textAlign = 'center';\n  const posX = x + width / 2;\n  let textBaseline = 'middle';\n  let posY = 0;\n\n  if (direction === 'top') {\n    switch (anchor) {\n      case 'end':\n        textBaseline = 'top';\n        posY = y;\n        break;\n\n      case 'start':\n        textBaseline = 'bottom';\n        posY = y + height;\n        break;\n\n      case 'center':\n        textBaseline = 'middle';\n        posY = y + height / 2;\n        break;\n\n      default:\n        textBaseline = 'bottom';\n        posY = y;\n    }\n  } else {\n    switch (anchor) {\n      case 'end':\n        textBaseline = 'bottom';\n        posY = y + height;\n        break;\n\n      case 'start':\n        textBaseline = 'top';\n        posY = y;\n        break;\n\n      case 'center':\n        textBaseline = 'middle';\n        posY = y + height / 2;\n        break;\n\n      default:\n        textBaseline = 'top';\n        posY = y + height;\n        break;\n    }\n  }\n\n  return {\n    x: posX,\n    y: posY,\n    textAlign,\n    textBaseline\n  };\n}\n\nfunction adjustOverflowHorizontalRect(rect, dataLabelOptions, position) {\n  const {\n    width,\n    value,\n    direction,\n    plot,\n    theme\n  } = rect;\n  const {\n    formatter\n  } = dataLabelOptions;\n  const font = getFont(theme);\n  const text = isString(value) ? value : formatter(value);\n  const textWidth = getTextWidth(text, font);\n  let {\n    x,\n    textAlign\n  } = position;\n  const isOverflow = direction === 'left' && x - textWidth < 0 || x + textWidth > plot.size;\n\n  if (isOverflow) {\n    x = rect.x + width;\n    textAlign = 'right';\n\n    if (direction === 'left' && width >= textWidth) {\n      x = rect.x;\n      textAlign = 'left';\n    }\n  }\n\n  return {\n    x,\n    textAlign\n  };\n}\n\nfunction adjustOverflowVerticalRect(rect, dataLabelOptions, position) {\n  const {\n    height,\n    direction,\n    plot,\n    theme,\n    value\n  } = rect;\n  const font = getFont(theme);\n  const plotSize = plot.size;\n  const textHeight = getTextHeight(`${value}`, font); // @TODO: formatter 값해서 넘기기\n\n  let {\n    y,\n    textBaseline\n  } = position;\n  const isOverflow = !(direction === 'bottom') && y - textHeight < 0 || y + textHeight > plotSize;\n\n  if (isOverflow) {\n    y = rect.y;\n    textBaseline = 'top';\n\n    if (y + textHeight > plotSize) {\n      y = rect.y;\n      textBaseline = 'bottom';\n    }\n\n    if (direction === 'bottom') {\n      y = rect.y + height;\n      textBaseline = 'bottom';\n    }\n  }\n\n  return {\n    y,\n    textBaseline\n  };\n}\n\nfunction makeHorizontalRectLabelInfo(rect, dataLabelOptions) {\n  const {\n    anchor,\n    offsetX = 0,\n    offsetY = 0\n  } = dataLabelOptions;\n  const {\n    direction,\n    plot: {\n      x: startOffsetX = 0,\n      y: startOffsetY = 0\n    }\n  } = rect;\n  const position = makeHorizontalRectPosition(rect, anchor);\n  let {\n    x: posX,\n    y: posY,\n    textAlign\n  } = position;\n\n  if (anchor === 'auto') {\n    const adjustRect = adjustOverflowHorizontalRect(rect, dataLabelOptions, {\n      x: posX,\n      textAlign\n    });\n    posX = adjustRect.x;\n    textAlign = adjustRect.textAlign;\n  }\n\n  posY += offsetY;\n\n  if (direction === 'left') {\n    posX = posX - offsetX;\n  } else {\n    posX = posX + offsetX;\n  }\n\n  const padding = 10;\n\n  if (textAlign === 'right') {\n    posX -= padding;\n  } else if (textAlign === 'left') {\n    posX += padding;\n  }\n\n  posX -= startOffsetX;\n  posY -= startOffsetY;\n  return {\n    x: posX,\n    y: posY,\n    textAlign,\n    textBaseline: position.textBaseline\n  };\n}\n\nfunction makeVerticalRectLabelInfo(rect, dataLabelOptions) {\n  const {\n    anchor,\n    offsetX = 0,\n    offsetY = 0\n  } = dataLabelOptions;\n  const {\n    direction,\n    plot: {\n      x: startOffsetX = 0,\n      y: startOffsetY = 0\n    }\n  } = rect;\n  const position = makeVerticalRectPosition(rect, anchor);\n  let {\n    x: posX,\n    y: posY,\n    textBaseline\n  } = position;\n\n  if (anchor === 'auto') {\n    const adjustRect = adjustOverflowVerticalRect(rect, dataLabelOptions, position);\n    posY = adjustRect.y;\n    textBaseline = adjustRect.textBaseline;\n  }\n\n  posX += offsetX;\n\n  if (direction === 'top') {\n    posY = posY + offsetY;\n  } else if (direction === 'bottom') {\n    posY = posY - offsetY;\n  }\n\n  const padding = 5;\n\n  if (textBaseline === 'bottom') {\n    posY -= padding;\n  } else if (textBaseline === 'top') {\n    posY += padding;\n  }\n\n  posX -= startOffsetX;\n  posY -= startOffsetY;\n  return {\n    x: posX,\n    y: posY,\n    textAlign: position.textAlign,\n    textBaseline\n  };\n}\n\nexport function makeRectLabelInfo(rect, dataLabelOptions) {\n  const {\n    type,\n    value,\n    direction,\n    name,\n    theme\n  } = rect;\n  const horizontal = isHorizontal(direction);\n  const labelPosition = horizontal ? makeHorizontalRectLabelInfo(rect, dataLabelOptions) : makeVerticalRectLabelInfo(rect, dataLabelOptions);\n  const formatter = type === 'stackTotal' ? dataLabelOptions.stackTotal.formatter : dataLabelOptions.formatter;\n  return Object.assign(Object.assign({\n    type\n  }, labelPosition), {\n    text: isString(value) ? value : formatter(value),\n    name,\n    seriesColor: rect.color,\n    theme\n  });\n}\nexport function makeSectorLabelPosition(model, dataLabelOptions) {\n  const anchor = dataLabelOptions.anchor;\n  const position = getRadialAnchorPosition(makeAnchorPositionParam(anchor, Object.assign(Object.assign({}, model), {\n    radius: Object.assign(Object.assign({}, model.radius), {\n      outer: anchor === 'outer' ? model.radius.outer + RADIUS_PADDING : model.radius.outer\n    })\n  })));\n  const textAlign = getRadialLabelAlign(model, anchor);\n  return Object.assign(Object.assign({}, position), {\n    textAlign,\n    textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'bottom' : 'middle'\n  });\n}\n\nfunction makeSectorBarLabelPosition(model, dataLabelOptions) {\n  const {\n    anchor\n  } = dataLabelOptions;\n  const {\n    clockwise,\n    degree: {\n      start,\n      end\n    },\n    radius: {\n      inner,\n      outer\n    }\n  } = model;\n  let startAngle = start;\n  let endAngle = end;\n  let textAlign = 'center';\n  let rotationDegree = (start + end) / 2;\n\n  if (anchor === 'start') {\n    textAlign = clockwise ? 'left' : 'right';\n    endAngle = startAngle;\n    rotationDegree = start;\n  } else if (anchor === 'end') {\n    textAlign = clockwise ? 'right' : 'left';\n    startAngle = endAngle;\n    rotationDegree = end;\n  }\n\n  const {\n    x,\n    y\n  } = getRadialAnchorPosition(makeAnchorPositionParam(anchor, Object.assign(Object.assign({}, model), {\n    degree: {\n      start: startAngle,\n      end: endAngle\n    },\n    radius: {\n      inner: inner,\n      outer: outer\n    }\n  })));\n  return {\n    x,\n    y,\n    textAlign,\n    textBaseline: 'middle',\n    radian: calculateDegreeToRadian(rotationDegree, 0)\n  };\n}\n\nexport function makeSectorBarLabelInfo(model, dataLabelOptions) {\n  const {\n    formatter\n  } = dataLabelOptions;\n  const labelPosition = makeSectorBarLabelPosition(model, dataLabelOptions);\n  const {\n    value,\n    name,\n    theme: dataLabelTheme\n  } = model;\n  const theme = Object.assign(Object.assign({}, dataLabelTheme), {\n    color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color\n  });\n  return Object.assign(Object.assign({\n    type: 'sector'\n  }, labelPosition), {\n    text: formatter(value),\n    name,\n    theme\n  });\n}\nexport function makeSectorLabelInfo(model, dataLabelOptions) {\n  const {\n    formatter\n  } = dataLabelOptions;\n  const labelPosition = makeSectorLabelPosition(model, dataLabelOptions);\n  const {\n    value,\n    name,\n    theme: dataLabelTheme\n  } = model;\n  const anchor = dataLabelOptions.anchor;\n  const theme = Object.assign(Object.assign({}, dataLabelTheme), {\n    color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color\n  });\n  return Object.assign(Object.assign({\n    type: 'sector'\n  }, labelPosition), {\n    text: formatter(value),\n    name,\n    callout: hasSectorCallout(dataLabelOptions) ? getPieDataLabelCallout(model, anchor) : null,\n    theme\n  });\n}\nexport function makePieSeriesNameLabelInfo(model, dataLabelOptions) {\n  var _a;\n\n  const seriesNameAnchor = (_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor;\n  const hasOuterAnchor = seriesNameAnchor === 'outer';\n  const position = getRadialAnchorPosition(makeAnchorPositionParam(seriesNameAnchor, Object.assign(Object.assign({}, model), {\n    radius: Object.assign(Object.assign({}, model.radius), {\n      outer: hasOuterAnchor ? model.radius.outer + RADIUS_PADDING : model.radius.outer\n    })\n  })));\n  const textAlign = getRadialLabelAlign(model, seriesNameAnchor);\n  const pieSeriesNameTheme = model.theme.pieSeriesName;\n  const theme = Object.assign(Object.assign({}, pieSeriesNameTheme), {\n    color: pieSeriesNameTheme.useSeriesColor ? model.color : pieSeriesNameTheme.color\n  });\n  return Object.assign(Object.assign({\n    type: 'pieSeriesName'\n  }, position), {\n    text: model.name,\n    callout: hasPieSeriesNameCallout(dataLabelOptions) ? getPieDataLabelCallout(model, seriesNameAnchor) : null,\n    textAlign,\n    textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'top' : 'middle',\n    theme\n  });\n}\nexport function getDataLabelsOptions(options, name) {\n  var _a, _b, _c, _d, _e;\n\n  return ((_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b[name]) === null || _c === void 0 ? void 0 : _c.dataLabels) || ((_e = (_d = options) === null || _d === void 0 ? void 0 : _d.series) === null || _e === void 0 ? void 0 : _e.dataLabels) || {};\n}\nexport function makeLineLabelInfo(model, dataLabelOptions) {\n  const {\n    value,\n    textAlign,\n    textBaseline\n  } = model;\n  const {\n    formatter\n  } = dataLabelOptions;\n  return Object.assign(Object.assign({}, model), {\n    x: model.x,\n    y: (model.y + model.y2) / 2,\n    textAlign: textAlign !== null && textAlign !== void 0 ? textAlign : 'center',\n    textBaseline: textBaseline !== null && textBaseline !== void 0 ? textBaseline : 'middle',\n    text: isString(value) ? value : formatter(value)\n  });\n}\n\nfunction hasSameAnchorPieDataLabel(dataLabelOptions) {\n  var _a;\n\n  return dataLabelOptions.anchor === ((_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor);\n}\n\nfunction hasSectorCallout(dataLabelOptions) {\n  var _a;\n\n  return dataLabelOptions.anchor === 'outer' || ((_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor) !== 'outer';\n}\n\nfunction hasPieSeriesNameCallout(dataLabelOptions) {\n  var _a;\n\n  return dataLabelOptions.anchor !== 'outer' || ((_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor) === 'outer';\n}\n\nfunction getPieDataLabelCallout(model, anchor) {\n  if (anchor !== 'outer') {\n    return null;\n  }\n\n  const {\n    x,\n    y\n  } = getRadialAnchorPosition(makeAnchorPositionParam('outer', Object.assign(Object.assign({}, model), {\n    radius: Object.assign(Object.assign({}, model.radius), {\n      outer: model.radius.outer + CALLOUT_LENGTH\n    })\n  })));\n  const {\n    x: x2,\n    y: y2\n  } = getRadialAnchorPosition(makeAnchorPositionParam('outer', Object.assign({}, model)));\n  const {\n    callout\n  } = model.theme;\n  const theme = Object.assign(Object.assign({}, callout), {\n    lineColor: callout.useSeriesColor ? model.color : callout.lineColor\n  });\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    theme\n  };\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js"],"names":["isFunction","includes","isBoolean","isString","getTextWidth","getTextHeight","getRadialAnchorPosition","makeAnchorPositionParam","calculateDegreeToRadian","getRadialLabelAlign","getFont","RADIUS_PADDING","CALLOUT_LENGTH","getDefaultAnchor","type","withStack","anchor","getAnchor","dataLabelOptions","getDefaultDataLabelsOptions","_a","_b","_c","offsetX","offsetY","formatter","value","String","options","stackTotal","visible","pieSeriesName","Object","assign","makePointLabelInfo","point","rect","width","height","name","theme","textBaseline","xWithOffset","x","yWithOffset","y","text","textAlign","isHorizontal","direction","makeHorizontalRectPosition","posY","posX","makeVerticalRectPosition","adjustOverflowHorizontalRect","position","plot","font","textWidth","isOverflow","size","adjustOverflowVerticalRect","plotSize","textHeight","makeHorizontalRectLabelInfo","startOffsetX","startOffsetY","adjustRect","padding","makeVerticalRectLabelInfo","makeRectLabelInfo","horizontal","labelPosition","seriesColor","color","makeSectorLabelPosition","model","radius","outer","hasSameAnchorPieDataLabel","makeSectorBarLabelPosition","clockwise","degree","start","end","inner","startAngle","endAngle","rotationDegree","radian","makeSectorBarLabelInfo","dataLabelTheme","useSeriesColor","makeSectorLabelInfo","callout","hasSectorCallout","getPieDataLabelCallout","makePieSeriesNameLabelInfo","seriesNameAnchor","hasOuterAnchor","pieSeriesNameTheme","hasPieSeriesNameCallout","getDataLabelsOptions","_d","_e","series","dataLabels","makeLineLabelInfo","y2","x2","lineColor"],"mappings":"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","sourcesContent":["import { isFunction, includes, isBoolean, isString } from \"./utils\";\nimport { getTextWidth, getTextHeight } from \"./calculator\";\nimport { getRadialAnchorPosition, makeAnchorPositionParam, calculateDegreeToRadian, getRadialLabelAlign, } from \"./sector\";\nimport { getFont } from \"./style\";\nexport const RADIUS_PADDING = 30;\nconst CALLOUT_LENGTH = 20;\nfunction getDefaultAnchor(type, withStack = false) {\n    let anchor = 'auto';\n    switch (type) {\n        case 'point':\n            anchor = 'center';\n            break;\n        case 'rect':\n            anchor = !withStack ? 'auto' : 'center';\n            break;\n        case 'sector':\n        case 'treemapSeriesName':\n            anchor = 'center';\n            break;\n        case 'stackTotal':\n            anchor = 'auto';\n            break;\n    }\n    return anchor;\n}\nfunction getAnchor(dataLabelOptions, type, withStack = false) {\n    return type !== 'stackTotal' &&\n        includes(['center', 'start', 'end', 'auto', 'outer'], dataLabelOptions.anchor)\n        ? dataLabelOptions.anchor\n        : getDefaultAnchor(type, withStack);\n}\nexport function getDefaultDataLabelsOptions(dataLabelOptions, type, withStack = false) {\n    var _a, _b, _c;\n    const anchor = getAnchor(dataLabelOptions, type, withStack);\n    const { offsetX = 0, offsetY = 0 } = dataLabelOptions;\n    const formatter = isFunction(dataLabelOptions.formatter)\n        ? dataLabelOptions.formatter\n        : (value) => String(value) || '';\n    const options = {\n        anchor,\n        offsetX,\n        offsetY,\n        formatter,\n    };\n    if (withStack) {\n        const stackTotal = dataLabelOptions.stackTotal;\n        options.stackTotal = {\n            visible: isBoolean((_a = stackTotal) === null || _a === void 0 ? void 0 : _a.visible) ? stackTotal.visible : true,\n            formatter: isFunction((_b = stackTotal) === null || _b === void 0 ? void 0 : _b.formatter) ? stackTotal.formatter : formatter,\n        };\n    }\n    if (type === 'sector' && ((_c = dataLabelOptions.pieSeriesName) === null || _c === void 0 ? void 0 : _c.visible)) {\n        options.pieSeriesName = Object.assign({ anchor: 'center' }, dataLabelOptions.pieSeriesName);\n    }\n    return options;\n}\nexport function makePointLabelInfo(point, dataLabelOptions, rect) {\n    const { width, height } = rect;\n    const { anchor, offsetX = 0, offsetY = 0, formatter } = dataLabelOptions;\n    const { name, theme } = point;\n    let textBaseline = 'middle';\n    if (anchor === 'end') {\n        textBaseline = 'bottom';\n    }\n    else if (anchor === 'start') {\n        textBaseline = 'top';\n    }\n    const xWithOffset = point.x + offsetX;\n    const yWithOffset = point.y + offsetY;\n    const x = xWithOffset < 0 || xWithOffset > width ? point.x : xWithOffset;\n    const y = yWithOffset < 0 || yWithOffset > height ? point.y : yWithOffset;\n    return {\n        type: 'point',\n        x,\n        y,\n        text: formatter(point.value),\n        textAlign: 'center',\n        textBaseline,\n        name,\n        theme,\n    };\n}\nfunction isHorizontal(direction) {\n    return includes(['left', 'right'], direction);\n}\nfunction makeHorizontalRectPosition(rect, anchor) {\n    const { x, y, width, height, direction } = rect;\n    const textBaseline = 'middle';\n    const posY = y + height / 2;\n    let textAlign = 'center';\n    let posX;\n    if (direction === 'right') {\n        switch (anchor) {\n            case 'start':\n                textAlign = 'left';\n                posX = x;\n                break;\n            case 'end':\n                textAlign = 'right';\n                posX = x + width;\n                break;\n            case 'center':\n                textAlign = 'center';\n                posX = x + width / 2;\n                break;\n            default:\n                textAlign = 'left';\n                posX = x + width;\n        }\n    }\n    else {\n        switch (anchor) {\n            case 'start':\n                textAlign = 'right';\n                posX = x + width;\n                break;\n            case 'end':\n                textAlign = 'left';\n                posX = x;\n                break;\n            case 'center':\n                textAlign = 'center';\n                posX = x + width / 2;\n                break;\n            default:\n                textAlign = 'right';\n                posX = x;\n        }\n    }\n    return {\n        x: posX,\n        y: posY,\n        textAlign,\n        textBaseline,\n    };\n}\nfunction makeVerticalRectPosition(rect, anchor) {\n    const { x, y, width, height, direction } = rect;\n    const textAlign = 'center';\n    const posX = x + width / 2;\n    let textBaseline = 'middle';\n    let posY = 0;\n    if (direction === 'top') {\n        switch (anchor) {\n            case 'end':\n                textBaseline = 'top';\n                posY = y;\n                break;\n            case 'start':\n                textBaseline = 'bottom';\n                posY = y + height;\n                break;\n            case 'center':\n                textBaseline = 'middle';\n                posY = y + height / 2;\n                break;\n            default:\n                textBaseline = 'bottom';\n                posY = y;\n        }\n    }\n    else {\n        switch (anchor) {\n            case 'end':\n                textBaseline = 'bottom';\n                posY = y + height;\n                break;\n            case 'start':\n                textBaseline = 'top';\n                posY = y;\n                break;\n            case 'center':\n                textBaseline = 'middle';\n                posY = y + height / 2;\n                break;\n            default:\n                textBaseline = 'top';\n                posY = y + height;\n                break;\n        }\n    }\n    return {\n        x: posX,\n        y: posY,\n        textAlign,\n        textBaseline,\n    };\n}\nfunction adjustOverflowHorizontalRect(rect, dataLabelOptions, position) {\n    const { width, value, direction, plot, theme } = rect;\n    const { formatter } = dataLabelOptions;\n    const font = getFont(theme);\n    const text = isString(value) ? value : formatter(value);\n    const textWidth = getTextWidth(text, font);\n    let { x, textAlign } = position;\n    const isOverflow = (direction === 'left' && x - textWidth < 0) || x + textWidth > plot.size;\n    if (isOverflow) {\n        x = rect.x + width;\n        textAlign = 'right';\n        if (direction === 'left' && width >= textWidth) {\n            x = rect.x;\n            textAlign = 'left';\n        }\n    }\n    return {\n        x,\n        textAlign,\n    };\n}\nfunction adjustOverflowVerticalRect(rect, dataLabelOptions, position) {\n    const { height, direction, plot, theme, value } = rect;\n    const font = getFont(theme);\n    const plotSize = plot.size;\n    const textHeight = getTextHeight(`${value}`, font); // @TODO: formatter 값해서 넘기기\n    let { y, textBaseline } = position;\n    const isOverflow = (!(direction === 'bottom') && y - textHeight < 0) || y + textHeight > plotSize;\n    if (isOverflow) {\n        y = rect.y;\n        textBaseline = 'top';\n        if (y + textHeight > plotSize) {\n            y = rect.y;\n            textBaseline = 'bottom';\n        }\n        if (direction === 'bottom') {\n            y = rect.y + height;\n            textBaseline = 'bottom';\n        }\n    }\n    return {\n        y,\n        textBaseline,\n    };\n}\nfunction makeHorizontalRectLabelInfo(rect, dataLabelOptions) {\n    const { anchor, offsetX = 0, offsetY = 0 } = dataLabelOptions;\n    const { direction, plot: { x: startOffsetX = 0, y: startOffsetY = 0 }, } = rect;\n    const position = makeHorizontalRectPosition(rect, anchor);\n    let { x: posX, y: posY, textAlign } = position;\n    if (anchor === 'auto') {\n        const adjustRect = adjustOverflowHorizontalRect(rect, dataLabelOptions, { x: posX, textAlign });\n        posX = adjustRect.x;\n        textAlign = adjustRect.textAlign;\n    }\n    posY += offsetY;\n    if (direction === 'left') {\n        posX = posX - offsetX;\n    }\n    else {\n        posX = posX + offsetX;\n    }\n    const padding = 10;\n    if (textAlign === 'right') {\n        posX -= padding;\n    }\n    else if (textAlign === 'left') {\n        posX += padding;\n    }\n    posX -= startOffsetX;\n    posY -= startOffsetY;\n    return {\n        x: posX,\n        y: posY,\n        textAlign,\n        textBaseline: position.textBaseline,\n    };\n}\nfunction makeVerticalRectLabelInfo(rect, dataLabelOptions) {\n    const { anchor, offsetX = 0, offsetY = 0 } = dataLabelOptions;\n    const { direction, plot: { x: startOffsetX = 0, y: startOffsetY = 0 }, } = rect;\n    const position = makeVerticalRectPosition(rect, anchor);\n    let { x: posX, y: posY, textBaseline } = position;\n    if (anchor === 'auto') {\n        const adjustRect = adjustOverflowVerticalRect(rect, dataLabelOptions, position);\n        posY = adjustRect.y;\n        textBaseline = adjustRect.textBaseline;\n    }\n    posX += offsetX;\n    if (direction === 'top') {\n        posY = posY + offsetY;\n    }\n    else if (direction === 'bottom') {\n        posY = posY - offsetY;\n    }\n    const padding = 5;\n    if (textBaseline === 'bottom') {\n        posY -= padding;\n    }\n    else if (textBaseline === 'top') {\n        posY += padding;\n    }\n    posX -= startOffsetX;\n    posY -= startOffsetY;\n    return {\n        x: posX,\n        y: posY,\n        textAlign: position.textAlign,\n        textBaseline,\n    };\n}\nexport function makeRectLabelInfo(rect, dataLabelOptions) {\n    const { type, value, direction, name, theme } = rect;\n    const horizontal = isHorizontal(direction);\n    const labelPosition = horizontal\n        ? makeHorizontalRectLabelInfo(rect, dataLabelOptions)\n        : makeVerticalRectLabelInfo(rect, dataLabelOptions);\n    const formatter = type === 'stackTotal' ? dataLabelOptions.stackTotal.formatter : dataLabelOptions.formatter;\n    return Object.assign(Object.assign({ type }, labelPosition), { text: isString(value) ? value : formatter(value), name, seriesColor: rect.color, theme });\n}\nexport function makeSectorLabelPosition(model, dataLabelOptions) {\n    const anchor = dataLabelOptions.anchor;\n    const position = getRadialAnchorPosition(makeAnchorPositionParam(anchor, Object.assign(Object.assign({}, model), { radius: Object.assign(Object.assign({}, model.radius), { outer: anchor === 'outer' ? model.radius.outer + RADIUS_PADDING : model.radius.outer }) })));\n    const textAlign = getRadialLabelAlign(model, anchor);\n    return Object.assign(Object.assign({}, position), { textAlign, textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'bottom' : 'middle' });\n}\nfunction makeSectorBarLabelPosition(model, dataLabelOptions) {\n    const { anchor } = dataLabelOptions;\n    const { clockwise, degree: { start, end }, radius: { inner, outer }, } = model;\n    let startAngle = start;\n    let endAngle = end;\n    let textAlign = 'center';\n    let rotationDegree = (start + end) / 2;\n    if (anchor === 'start') {\n        textAlign = clockwise ? 'left' : 'right';\n        endAngle = startAngle;\n        rotationDegree = start;\n    }\n    else if (anchor === 'end') {\n        textAlign = clockwise ? 'right' : 'left';\n        startAngle = endAngle;\n        rotationDegree = end;\n    }\n    const { x, y } = getRadialAnchorPosition(makeAnchorPositionParam(anchor, Object.assign(Object.assign({}, model), { degree: {\n            start: startAngle,\n            end: endAngle,\n        }, radius: {\n            inner: inner,\n            outer: outer,\n        } })));\n    return {\n        x,\n        y,\n        textAlign,\n        textBaseline: 'middle',\n        radian: calculateDegreeToRadian(rotationDegree, 0),\n    };\n}\nexport function makeSectorBarLabelInfo(model, dataLabelOptions) {\n    const { formatter } = dataLabelOptions;\n    const labelPosition = makeSectorBarLabelPosition(model, dataLabelOptions);\n    const { value, name, theme: dataLabelTheme } = model;\n    const theme = Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color });\n    return Object.assign(Object.assign({ type: 'sector' }, labelPosition), { text: formatter(value), name,\n        theme });\n}\nexport function makeSectorLabelInfo(model, dataLabelOptions) {\n    const { formatter } = dataLabelOptions;\n    const labelPosition = makeSectorLabelPosition(model, dataLabelOptions);\n    const { value, name, theme: dataLabelTheme } = model;\n    const anchor = dataLabelOptions.anchor;\n    const theme = Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color });\n    return Object.assign(Object.assign({ type: 'sector' }, labelPosition), { text: formatter(value), name, callout: hasSectorCallout(dataLabelOptions) ? getPieDataLabelCallout(model, anchor) : null, theme });\n}\nexport function makePieSeriesNameLabelInfo(model, dataLabelOptions) {\n    var _a;\n    const seriesNameAnchor = (_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor;\n    const hasOuterAnchor = seriesNameAnchor === 'outer';\n    const position = getRadialAnchorPosition(makeAnchorPositionParam(seriesNameAnchor, Object.assign(Object.assign({}, model), { radius: Object.assign(Object.assign({}, model.radius), { outer: hasOuterAnchor ? model.radius.outer + RADIUS_PADDING : model.radius.outer }) })));\n    const textAlign = getRadialLabelAlign(model, seriesNameAnchor);\n    const pieSeriesNameTheme = model.theme.pieSeriesName;\n    const theme = Object.assign(Object.assign({}, pieSeriesNameTheme), { color: pieSeriesNameTheme.useSeriesColor ? model.color : pieSeriesNameTheme.color });\n    return Object.assign(Object.assign({ type: 'pieSeriesName' }, position), { text: model.name, callout: hasPieSeriesNameCallout(dataLabelOptions)\n            ? getPieDataLabelCallout(model, seriesNameAnchor)\n            : null, textAlign, textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'top' : 'middle', theme });\n}\nexport function getDataLabelsOptions(options, name) {\n    var _a, _b, _c, _d, _e;\n    return ((_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b[name]) === null || _c === void 0 ? void 0 : _c.dataLabels) || ((_e = (_d = options) === null || _d === void 0 ? void 0 : _d.series) === null || _e === void 0 ? void 0 : _e.dataLabels) || {};\n}\nexport function makeLineLabelInfo(model, dataLabelOptions) {\n    const { value, textAlign, textBaseline } = model;\n    const { formatter } = dataLabelOptions;\n    return Object.assign(Object.assign({}, model), { x: model.x, y: (model.y + model.y2) / 2, textAlign: (textAlign !== null && textAlign !== void 0 ? textAlign : 'center'), textBaseline: (textBaseline !== null && textBaseline !== void 0 ? textBaseline : 'middle'), text: isString(value) ? value : formatter(value) });\n}\nfunction hasSameAnchorPieDataLabel(dataLabelOptions) {\n    var _a;\n    return dataLabelOptions.anchor === ((_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor);\n}\nfunction hasSectorCallout(dataLabelOptions) {\n    var _a;\n    return dataLabelOptions.anchor === 'outer' || ((_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor) !== 'outer';\n}\nfunction hasPieSeriesNameCallout(dataLabelOptions) {\n    var _a;\n    return dataLabelOptions.anchor !== 'outer' || ((_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor) === 'outer';\n}\nfunction getPieDataLabelCallout(model, anchor) {\n    if (anchor !== 'outer') {\n        return null;\n    }\n    const { x, y } = getRadialAnchorPosition(makeAnchorPositionParam('outer', Object.assign(Object.assign({}, model), { radius: Object.assign(Object.assign({}, model.radius), { outer: model.radius.outer + CALLOUT_LENGTH }) })));\n    const { x: x2, y: y2 } = getRadialAnchorPosition(makeAnchorPositionParam('outer', Object.assign({}, model)));\n    const { callout } = model.theme;\n    const theme = Object.assign(Object.assign({}, callout), { lineColor: callout.useSeriesColor ? model.color : callout.lineColor });\n    return { x, y, x2, y2, theme };\n}\n"]},"metadata":{},"sourceType":"module"}