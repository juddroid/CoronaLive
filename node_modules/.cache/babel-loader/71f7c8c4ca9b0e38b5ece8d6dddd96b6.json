{"ast":null,"code":"import Component from \"./component\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getBoxTypeSeriesPadding } from \"../helpers/style\";\nimport { isNumber, calculateSizeWithPercentString, isNull } from \"../helpers/utils\";\nimport { crispPixel } from \"../helpers/calculator\";\nimport { message } from \"../message\";\nconst MIN_BAR_WIDTH = 5;\n\nfunction getPadding(tickDistance, barWidth, seriesLength) {\n  return (tickDistance - barWidth * seriesLength) / (seriesLength + 1);\n}\n\nfunction getDefaultColor(defaultColor, color) {\n  return color !== null && color !== void 0 ? color : defaultColor;\n}\n\nexport default class BoxPlotSeries extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      rect: [],\n      line: [],\n      circle: []\n    };\n    this.activatedResponders = [];\n    this.eventDetectType = 'point';\n\n    this.onMouseoutComponent = () => {\n      this.eventBus.emit('seriesPointHovered', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('renderHoveredSeries', {\n        models: [],\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.selectSeries = ({\n      index,\n      seriesIndex,\n      state\n    }) => {\n      if (!isNumber(index) || !isNumber(seriesIndex)) {\n        return;\n      }\n\n      const {\n        name\n      } = state.series.boxPlot[seriesIndex];\n      const models = this.getRespondersWithTheme(this.tooltipRectMap[`${name}-${index}`], 'select');\n      this.eventBus.emit('renderSelectedSeries', {\n        models,\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.showTooltip = ({\n      index,\n      seriesIndex,\n      state\n    }) => {\n      if (!isNumber(index) || !isNumber(seriesIndex)) {\n        return;\n      }\n\n      const {\n        name\n      } = state.series.boxPlot[seriesIndex];\n      const models = this.getRespondersWithTheme(this.tooltipRectMap[`${name}-${index}`], 'hover');\n      this.eventBus.emit('renderHoveredSeries', {\n        models,\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.activatedResponders = models;\n      this.eventBus.emit('seriesPointHovered', {\n        models: this.activatedResponders,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  initialize() {\n    this.type = 'series';\n    this.name = 'boxPlot';\n    this.eventBus.on('selectSeries', this.selectSeries);\n    this.eventBus.on('showTooltip', this.showTooltip);\n    this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n  }\n\n  render(state) {\n    var _a, _b;\n\n    const {\n      layout,\n      axes,\n      series,\n      scale,\n      legend,\n      options,\n      theme\n    } = state;\n\n    if (!series.boxPlot) {\n      throw new Error(message.noDataError(this.name));\n    }\n\n    if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n      this.eventDetectType = options.series.eventDetectType;\n    }\n\n    this.theme = theme.series.boxPlot;\n    this.rect = layout.plot;\n    this.activeSeriesMap = getActiveSeriesMap(legend);\n    this.selectable = this.getSelectableOption(options);\n    const categories = state.categories;\n    const {\n      tickDistance\n    } = axes.xAxis;\n    const {\n      min,\n      max\n    } = scale.yAxis.limit;\n    const boxPlotData = series.boxPlot.data;\n    const seriesLength = boxPlotData.length;\n    const renderOptions = Object.assign({\n      ratio: this.rect.height / (max - min),\n      tickDistance\n    }, this.getBarWidths(tickDistance, seriesLength));\n    const boxPlotModelData = this.makeBoxPlots(boxPlotData, renderOptions);\n    const seriesModels = this.renderSeriesModels(boxPlotModelData);\n    this.models = seriesModels;\n\n    if (!this.drawModels) {\n      this.drawModels = {\n        rect: seriesModels.rect.map(m => Object.assign(Object.assign({}, m), {\n          y: m.y + m.height,\n          height: 0\n        })),\n        line: seriesModels.line,\n        circle: seriesModels.circle\n      };\n    }\n\n    const tooltipData = this.makeTooltipModel(boxPlotData, categories);\n    this.tooltipRectMap = this.makeTooltipRectMap(boxPlotModelData, tooltipData);\n    this.responders = this.eventDetectType === 'grouped' ? this.makeGroupedResponderModel(boxPlotModelData) : this.makeDefaultResponderModel(boxPlotModelData, tooltipData);\n  }\n\n  makeTooltipRectMap(boxPlotModelData, tooltipData) {\n    const result = {};\n    boxPlotModelData.forEach((m, tooltipIndex) => {\n      if (!isNull(m)) {\n        const propName = `${m.name}-${m.index}`;\n\n        if (!result[propName]) {\n          result[propName] = [];\n        }\n\n        result[propName].push(Object.assign(Object.assign({}, this.makeHoveredModel(m)), {\n          data: tooltipData[tooltipIndex]\n        }));\n      }\n    });\n    return result;\n  }\n\n  makeGroupedResponderModel(boxPlotModelData) {\n    const result = [];\n    boxPlotModelData.forEach(m => {\n      const {\n        type,\n        index,\n        name\n      } = m;\n      const propName = `${name}-${index}`;\n\n      if (type === 'boxPlot' && !result[propName]) {\n        const {\n          boxPlotDetection\n        } = m;\n        result.push(Object.assign(Object.assign({\n          type: 'rect',\n          name: propName\n        }, boxPlotDetection), {\n          y: 0,\n          height: this.rect.height\n        }));\n      }\n    });\n    return result;\n  }\n\n  makeDefaultResponderModel(boxPlotModelData, tooltipDataArr) {\n    return boxPlotModelData.map((m, index) => Object.assign(Object.assign({}, this.makeHoveredModel(m)), {\n      data: tooltipDataArr[index],\n      color: getRGBA(m.color, 1)\n    }));\n  }\n\n  makeHoveredModel(model) {\n    const point = model.type === 'boxPlot' && model.rect ? {\n      x: model.rect.x,\n      y: model.rect.y\n    } : {\n      x: model.x,\n      y: model.y\n    };\n    const hoveredModel = Object.assign({}, model);\n\n    if (model.type === 'boxPlot') {\n      ['lowerWhisker', 'upperWhisker', 'maximum', 'minimum', 'median'].forEach(prop => {\n        if (model[prop]) {\n          model[prop].detectionSize = 3;\n        }\n      });\n      model.color = getRGBA(hoveredModel.color, 1);\n    }\n\n    return Object.assign(Object.assign({}, hoveredModel), point);\n  }\n\n  getResponderModelFromMap(responders) {\n    if (!responders.length) {\n      return [];\n    }\n\n    const propName = responders[0].name;\n    return this.tooltipRectMap[propName];\n  }\n\n  onMousemove({\n    responders\n  }) {\n    if (this.eventDetectType === 'grouped') {\n      const models = this.getResponderModelFromMap(responders);\n      this.eventBus.emit('renderHoveredSeries', {\n        models: this.getRespondersWithTheme(models, 'select'),\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.activatedResponders = models;\n    } else {\n      this.eventBus.emit('renderHoveredSeries', {\n        models: this.getRespondersWithTheme(responders, 'hover'),\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.activatedResponders = responders;\n    }\n\n    this.eventBus.emit('seriesPointHovered', {\n      models: this.activatedResponders,\n      name: this.name\n    });\n    this.eventBus.emit('needDraw');\n  }\n\n  onClick({\n    responders\n  }) {\n    if (this.selectable) {\n      let models;\n\n      if (this.eventDetectType === 'grouped') {\n        models = this.getRespondersWithTheme(this.getResponderModelFromMap(responders), 'select');\n      } else {\n        models = this.getRespondersWithTheme(responders, 'select');\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models,\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    }\n  }\n\n  renderSeriesModels(boxPlots) {\n    return boxPlots.reduce((acc, cur) => {\n      const {\n        type,\n        name\n      } = cur;\n\n      if (type === 'boxPlot') {\n        acc.rect.push(Object.assign({\n          name\n        }, cur.rect));\n        ['maximum', 'minimum', 'median', 'upperWhisker', 'lowerWhisker'].forEach(prop => {\n          acc.line.push(Object.assign({\n            name\n          }, cur[prop]));\n        });\n      } else {\n        acc.circle.push(Object.assign({}, cur));\n      }\n\n      return acc;\n    }, {\n      rect: [],\n      line: [],\n      circle: []\n    });\n  }\n\n  makeBoxPlots(seriesData, renderOptions) {\n    const {\n      ratio,\n      barWidth\n    } = renderOptions;\n    const boxPlotModels = [];\n    const seriesLength = seriesData.length;\n    const {\n      dot\n    } = this.theme;\n    seriesData.forEach(({\n      outliers,\n      data,\n      name,\n      color\n    }, seriesIndex) => {\n      const seriesColor = this.getSeriesColor(name, color);\n      (data !== null && data !== void 0 ? data : []).forEach((datum, dataIndex) => {\n        if (!isNull(datum)) {\n          const startX = this.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);\n          const rect = this.getRect(datum, startX, seriesColor, renderOptions);\n          boxPlotModels.push(Object.assign(Object.assign({\n            type: 'boxPlot',\n            color: seriesColor,\n            name,\n            rect,\n            median: this.getMedian(datum, startX, seriesColor, renderOptions),\n            minimum: this.getMinimum(datum, startX, seriesColor, renderOptions),\n            maximum: this.getMaximum(datum, startX, seriesColor, renderOptions)\n          }, this.getWhisker(datum, startX, seriesColor, renderOptions, rect)), {\n            index: dataIndex,\n            boxPlotDetection: {\n              x: startX,\n              width: barWidth\n            }\n          }));\n        }\n      });\n      const {\n        color: dotColor,\n        radius,\n        borderColor,\n        borderWidth,\n        useSeriesColor\n      } = dot;\n      (outliers !== null && outliers !== void 0 ? outliers : []).forEach(datum => {\n        const [dataIndex, value] = datum;\n        const startX = this.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);\n        boxPlotModels.push({\n          type: 'circle',\n          name,\n          x: startX + barWidth / 2,\n          y: this.getYPos(value, ratio),\n          radius: radius,\n          style: [{\n            strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : seriesColor,\n            lineWidth: borderWidth\n          }],\n          color: useSeriesColor ? seriesColor : dotColor,\n          index: dataIndex\n        });\n      });\n    });\n    return boxPlotModels;\n  }\n\n  makeTooltipModel(seriesData, categories) {\n    const tooltipData = [];\n    seriesData.forEach(({\n      outliers,\n      data,\n      name,\n      color\n    }) => {\n      (data !== null && data !== void 0 ? data : []).forEach((datum, dataIndex) => {\n        if (!isNull(datum)) {\n          const boxPlotData = [...datum].reverse();\n          tooltipData.push({\n            label: name,\n            color: color,\n            value: ['Maximum', 'Upper Quartile', 'Median', 'Lower Quartile', 'Minimum'].reduce((acc, title, index) => {\n              const value = boxPlotData[index];\n              return isNull(value) ? acc : [...acc, {\n                title,\n                value\n              }];\n            }, []),\n            category: categories[dataIndex],\n            templateType: 'boxPlot'\n          });\n        }\n      });\n      (outliers !== null && outliers !== void 0 ? outliers : []).forEach(datum => {\n        if (!isNull(datum)) {\n          const [dataIndex, dataValue] = datum;\n          tooltipData.push({\n            label: name,\n            color: color,\n            value: [{\n              title: 'Outlier',\n              value: dataValue\n            }],\n            category: categories[dataIndex],\n            templateType: 'boxPlot'\n          });\n        }\n      });\n    });\n    return tooltipData;\n  }\n\n  getStartX(seriesIndex, dataIndex, renderOptions, seriesLength) {\n    const {\n      tickDistance,\n      barWidth\n    } = renderOptions;\n    const padding = getPadding(tickDistance, barWidth, seriesLength);\n    return dataIndex * tickDistance + (seriesIndex + 1) * padding + barWidth * seriesIndex;\n  }\n\n  getYPos(value, ratio, lineWidth) {\n    return isNumber(lineWidth) ? crispPixel(this.rect.height - value * ratio, lineWidth) : this.rect.height - value * ratio;\n  }\n\n  getBarWidths(tickDistance, seriesLength) {\n    const {\n      barWidth: barThemeWidth,\n      barWidthRatios\n    } = this.theme;\n    const {\n      barRatio,\n      minMaxBarRatio\n    } = barWidthRatios;\n    const defaultBarWidth = Math.max((tickDistance - getBoxTypeSeriesPadding(tickDistance) * (2 + (seriesLength - 1))) / seriesLength, MIN_BAR_WIDTH);\n    const barWidth = barThemeWidth ? calculateSizeWithPercentString(tickDistance / seriesLength, barThemeWidth) : defaultBarWidth;\n    return {\n      barWidth: barWidth * barRatio,\n      minMaxBarWidth: barWidth * minMaxBarRatio\n    };\n  }\n\n  getRespondersWithTheme(responders, type) {\n    const {\n      color,\n      rect,\n      dot,\n      line,\n      shadowColor,\n      shadowOffsetX,\n      shadowOffsetY,\n      shadowBlur\n    } = this.theme[type];\n    const {\n      whisker,\n      median,\n      maximum,\n      minimum\n    } = line;\n    const {\n      color: dotColor,\n      radius,\n      borderColor,\n      borderWidth,\n      useSeriesColor\n    } = dot;\n    return responders.map(m => {\n      const {\n        type: modelType,\n        data\n      } = m;\n      let seriesColor = m.color;\n      let model;\n\n      if (modelType === 'circle') {\n        seriesColor = data.color;\n        model = Object.assign(Object.assign({}, m), {\n          radius,\n          color: useSeriesColor ? seriesColor : dotColor,\n          style: [{\n            strokeStyle: getDefaultColor(seriesColor, borderColor),\n            lineWidth: borderWidth\n          }]\n        });\n      } else {\n        const {\n          rect: seriesRect,\n          upperWhisker,\n          lowerWhisker,\n          median: seriesMedian,\n          maximum: seriesMaximum,\n          minimum: seriesMinimum\n        } = m;\n        model = Object.assign(Object.assign({}, m), {\n          rect: Object.assign(Object.assign({}, seriesRect), {\n            color: color !== null && color !== void 0 ? color : getRGBA(seriesColor, 1),\n            thickness: rect.borderWidth,\n            borderColor: rect.borderColor,\n            style: [{\n              shadowColor,\n              shadowOffsetX,\n              shadowOffsetY,\n              shadowBlur\n            }]\n          }),\n          upperWhisker: Object.assign(Object.assign({}, upperWhisker), {\n            strokeStyle: getDefaultColor(seriesColor, whisker.color),\n            lineWidth: whisker.lineWidth\n          }),\n          lowerWhisker: Object.assign(Object.assign({}, lowerWhisker), {\n            strokeStyle: getDefaultColor(seriesColor, whisker.color),\n            lineWidth: whisker.lineWidth\n          }),\n          median: Object.assign(Object.assign({}, seriesMedian), {\n            strokeStyle: getDefaultColor(seriesColor, median.color),\n            lineWidth: median.lineWidth\n          }),\n          maximum: Object.assign(Object.assign({}, seriesMaximum), {\n            strokeStyle: getDefaultColor(seriesColor, maximum.color),\n            lineWidth: maximum.lineWidth\n          }),\n          minimum: Object.assign(Object.assign({}, seriesMinimum), {\n            strokeStyle: getDefaultColor(seriesColor, minimum.color),\n            lineWidth: minimum.lineWidth\n          })\n        });\n      }\n\n      return model;\n    });\n  }\n\n  getRect(datum, startX, seriesColor, {\n    barWidth,\n    ratio\n  }) {\n    const {\n      rect\n    } = this.theme;\n    const [, lowerQuartile,, highQuartile] = datum;\n    return {\n      type: 'rect',\n      x: startX,\n      y: this.getYPos(highQuartile, ratio),\n      width: barWidth,\n      height: (highQuartile - lowerQuartile) * ratio,\n      thickness: rect.borderWidth,\n      borderColor: rect.borderColor,\n      color: seriesColor\n    };\n  }\n\n  getWhisker(datum, startX, seriesColor, {\n    barWidth,\n    ratio\n  }, rect) {\n    const [minimum,,,, maximum] = datum;\n    const {\n      lineWidth,\n      color\n    } = this.theme.line.whisker;\n    const x = crispPixel(startX + barWidth / 2, lineWidth);\n    return {\n      upperWhisker: {\n        type: 'line',\n        x,\n        y: this.getYPos(maximum, ratio, lineWidth),\n        x2: x,\n        y2: rect.y,\n        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,\n        lineWidth\n      },\n      lowerWhisker: {\n        type: 'line',\n        x,\n        y: this.getYPos(minimum, ratio, lineWidth),\n        x2: x,\n        y2: crispPixel(rect.y + rect.height, lineWidth),\n        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,\n        lineWidth\n      }\n    };\n  }\n\n  getMedian(datum, startX, seriesColor, {\n    barWidth,\n    ratio\n  }) {\n    const median = datum[2];\n    const {\n      lineWidth,\n      color\n    } = this.theme.line.median;\n    return {\n      type: 'line',\n      x: crispPixel(startX, lineWidth),\n      y: this.getYPos(median, ratio, lineWidth),\n      x2: crispPixel(startX + barWidth, lineWidth),\n      y2: this.getYPos(median, ratio, lineWidth),\n      strokeStyle: color !== null && color !== void 0 ? color : seriesColor,\n      lineWidth: lineWidth\n    };\n  }\n\n  getMinimum(datum, startX, seriesColor, {\n    barWidth,\n    ratio,\n    minMaxBarWidth\n  }) {\n    const minimum = datum[0];\n    const {\n      lineWidth,\n      color\n    } = this.theme.line.minimum;\n    return {\n      type: 'line',\n      x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),\n      y: this.getYPos(minimum, ratio, lineWidth),\n      x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),\n      y2: this.getYPos(minimum, ratio, lineWidth),\n      strokeStyle: color !== null && color !== void 0 ? color : seriesColor,\n      lineWidth: lineWidth\n    };\n  }\n\n  getMaximum(datum, startX, seriesColor, {\n    barWidth,\n    ratio,\n    minMaxBarWidth\n  }) {\n    const maximum = datum[4];\n    const {\n      lineWidth,\n      color\n    } = this.theme.line.maximum;\n    return {\n      type: 'line',\n      x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),\n      y: this.getYPos(maximum, ratio, lineWidth),\n      x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),\n      y2: this.getYPos(maximum, ratio, lineWidth),\n      strokeStyle: color !== null && color !== void 0 ? color : seriesColor,\n      lineWidth: lineWidth\n    };\n  }\n\n  getSeriesColor(seriesName, seriesColor) {\n    const {\n      select,\n      areaOpacity\n    } = this.theme;\n    const active = this.activeSeriesMap[seriesName];\n    const selected = Object.values(this.activeSeriesMap).some(elem => !elem);\n    const selectedOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;\n    const opacity = selected ? selectedOpacity : areaOpacity;\n    return getRGBA(seriesColor, opacity);\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/boxPlotSeries.js"],"names":["Component","getActiveSeriesMap","getRGBA","getBoxTypeSeriesPadding","isNumber","calculateSizeWithPercentString","isNull","crispPixel","message","MIN_BAR_WIDTH","getPadding","tickDistance","barWidth","seriesLength","getDefaultColor","defaultColor","color","BoxPlotSeries","constructor","arguments","models","rect","line","circle","activatedResponders","eventDetectType","onMouseoutComponent","eventBus","emit","name","selectSeries","index","seriesIndex","state","series","boxPlot","getRespondersWithTheme","tooltipRectMap","showTooltip","initialize","type","on","render","_a","_b","layout","axes","scale","legend","options","theme","Error","noDataError","plot","activeSeriesMap","selectable","getSelectableOption","categories","xAxis","min","max","yAxis","limit","boxPlotData","data","length","renderOptions","Object","assign","ratio","height","getBarWidths","boxPlotModelData","makeBoxPlots","seriesModels","renderSeriesModels","drawModels","map","m","y","tooltipData","makeTooltipModel","makeTooltipRectMap","responders","makeGroupedResponderModel","makeDefaultResponderModel","result","forEach","tooltipIndex","propName","push","makeHoveredModel","boxPlotDetection","tooltipDataArr","model","point","x","hoveredModel","prop","detectionSize","getResponderModelFromMap","onMousemove","onClick","boxPlots","reduce","acc","cur","seriesData","boxPlotModels","dot","outliers","seriesColor","getSeriesColor","datum","dataIndex","startX","getStartX","getRect","median","getMedian","minimum","getMinimum","maximum","getMaximum","getWhisker","width","dotColor","radius","borderColor","borderWidth","useSeriesColor","value","getYPos","style","strokeStyle","lineWidth","reverse","label","title","category","templateType","dataValue","padding","barThemeWidth","barWidthRatios","barRatio","minMaxBarRatio","defaultBarWidth","Math","minMaxBarWidth","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","whisker","modelType","seriesRect","upperWhisker","lowerWhisker","seriesMedian","seriesMaximum","seriesMinimum","thickness","lowerQuartile","highQuartile","x2","y2","seriesName","select","areaOpacity","active","selected","values","some","elem","selectedOpacity","restSeries","opacity"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getBoxTypeSeriesPadding } from \"../helpers/style\";\nimport { isNumber, calculateSizeWithPercentString, isNull } from \"../helpers/utils\";\nimport { crispPixel } from \"../helpers/calculator\";\nimport { message } from \"../message\";\nconst MIN_BAR_WIDTH = 5;\nfunction getPadding(tickDistance, barWidth, seriesLength) {\n    return (tickDistance - barWidth * seriesLength) / (seriesLength + 1);\n}\nfunction getDefaultColor(defaultColor, color) {\n    return (color !== null && color !== void 0 ? color : defaultColor);\n}\nexport default class BoxPlotSeries extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { rect: [], line: [], circle: [] };\n        this.activatedResponders = [];\n        this.eventDetectType = 'point';\n        this.onMouseoutComponent = () => {\n            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });\n            this.eventBus.emit('renderHoveredSeries', {\n                models: [],\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.selectSeries = ({ index, seriesIndex, state, }) => {\n            if (!isNumber(index) || !isNumber(seriesIndex)) {\n                return;\n            }\n            const { name } = state.series.boxPlot[seriesIndex];\n            const models = this.getRespondersWithTheme(this.tooltipRectMap[`${name}-${index}`], 'select');\n            this.eventBus.emit('renderSelectedSeries', {\n                models,\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.showTooltip = ({ index, seriesIndex, state }) => {\n            if (!isNumber(index) || !isNumber(seriesIndex)) {\n                return;\n            }\n            const { name } = state.series.boxPlot[seriesIndex];\n            const models = this.getRespondersWithTheme(this.tooltipRectMap[`${name}-${index}`], 'hover');\n            this.eventBus.emit('renderHoveredSeries', {\n                models,\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.activatedResponders = models;\n            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n    }\n    initialize() {\n        this.type = 'series';\n        this.name = 'boxPlot';\n        this.eventBus.on('selectSeries', this.selectSeries);\n        this.eventBus.on('showTooltip', this.showTooltip);\n        this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n    }\n    render(state) {\n        var _a, _b;\n        const { layout, axes, series, scale, legend, options, theme } = state;\n        if (!series.boxPlot) {\n            throw new Error(message.noDataError(this.name));\n        }\n        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n            this.eventDetectType = options.series.eventDetectType;\n        }\n        this.theme = theme.series.boxPlot;\n        this.rect = layout.plot;\n        this.activeSeriesMap = getActiveSeriesMap(legend);\n        this.selectable = this.getSelectableOption(options);\n        const categories = state.categories;\n        const { tickDistance } = axes.xAxis;\n        const { min, max } = scale.yAxis.limit;\n        const boxPlotData = series.boxPlot.data;\n        const seriesLength = boxPlotData.length;\n        const renderOptions = Object.assign({ ratio: this.rect.height / (max - min), tickDistance }, this.getBarWidths(tickDistance, seriesLength));\n        const boxPlotModelData = this.makeBoxPlots(boxPlotData, renderOptions);\n        const seriesModels = this.renderSeriesModels(boxPlotModelData);\n        this.models = seriesModels;\n        if (!this.drawModels) {\n            this.drawModels = {\n                rect: seriesModels.rect.map((m) => (Object.assign(Object.assign({}, m), { y: m.y + m.height, height: 0 }))),\n                line: seriesModels.line,\n                circle: seriesModels.circle,\n            };\n        }\n        const tooltipData = this.makeTooltipModel(boxPlotData, categories);\n        this.tooltipRectMap = this.makeTooltipRectMap(boxPlotModelData, tooltipData);\n        this.responders =\n            this.eventDetectType === 'grouped'\n                ? this.makeGroupedResponderModel(boxPlotModelData)\n                : this.makeDefaultResponderModel(boxPlotModelData, tooltipData);\n    }\n    makeTooltipRectMap(boxPlotModelData, tooltipData) {\n        const result = {};\n        boxPlotModelData.forEach((m, tooltipIndex) => {\n            if (!isNull(m)) {\n                const propName = `${m.name}-${m.index}`;\n                if (!result[propName]) {\n                    result[propName] = [];\n                }\n                result[propName].push(Object.assign(Object.assign({}, this.makeHoveredModel(m)), { data: tooltipData[tooltipIndex] }));\n            }\n        });\n        return result;\n    }\n    makeGroupedResponderModel(boxPlotModelData) {\n        const result = [];\n        boxPlotModelData.forEach((m) => {\n            const { type, index, name } = m;\n            const propName = `${name}-${index}`;\n            if (type === 'boxPlot' && !result[propName]) {\n                const { boxPlotDetection } = m;\n                result.push(Object.assign(Object.assign({ type: 'rect', name: propName }, boxPlotDetection), { y: 0, height: this.rect.height }));\n            }\n        });\n        return result;\n    }\n    makeDefaultResponderModel(boxPlotModelData, tooltipDataArr) {\n        return boxPlotModelData.map((m, index) => (Object.assign(Object.assign({}, this.makeHoveredModel(m)), { data: tooltipDataArr[index], color: getRGBA(m.color, 1) })));\n    }\n    makeHoveredModel(model) {\n        const point = model.type === 'boxPlot' && model.rect\n            ? { x: model.rect.x, y: model.rect.y }\n            : { x: model.x, y: model.y };\n        const hoveredModel = Object.assign({}, model);\n        if (model.type === 'boxPlot') {\n            ['lowerWhisker', 'upperWhisker', 'maximum', 'minimum', 'median'].forEach((prop) => {\n                if (model[prop]) {\n                    model[prop].detectionSize = 3;\n                }\n            });\n            model.color = getRGBA(hoveredModel.color, 1);\n        }\n        return Object.assign(Object.assign({}, hoveredModel), point);\n    }\n    getResponderModelFromMap(responders) {\n        if (!responders.length) {\n            return [];\n        }\n        const propName = responders[0].name;\n        return this.tooltipRectMap[propName];\n    }\n    onMousemove({ responders }) {\n        if (this.eventDetectType === 'grouped') {\n            const models = this.getResponderModelFromMap(responders);\n            this.eventBus.emit('renderHoveredSeries', {\n                models: this.getRespondersWithTheme(models, 'select'),\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.activatedResponders = models;\n        }\n        else {\n            this.eventBus.emit('renderHoveredSeries', {\n                models: this.getRespondersWithTheme(responders, 'hover'),\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.activatedResponders = responders;\n        }\n        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n        this.eventBus.emit('needDraw');\n    }\n    onClick({ responders }) {\n        if (this.selectable) {\n            let models;\n            if (this.eventDetectType === 'grouped') {\n                models = this.getRespondersWithTheme(this.getResponderModelFromMap(responders), 'select');\n            }\n            else {\n                models = this.getRespondersWithTheme(responders, 'select');\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models,\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        }\n    }\n    renderSeriesModels(boxPlots) {\n        return boxPlots.reduce((acc, cur) => {\n            const { type, name } = cur;\n            if (type === 'boxPlot') {\n                acc.rect.push(Object.assign({ name }, cur.rect));\n                ['maximum', 'minimum', 'median', 'upperWhisker', 'lowerWhisker'].forEach((prop) => {\n                    acc.line.push(Object.assign({ name }, cur[prop]));\n                });\n            }\n            else {\n                acc.circle.push(Object.assign({}, cur));\n            }\n            return acc;\n        }, { rect: [], line: [], circle: [] });\n    }\n    makeBoxPlots(seriesData, renderOptions) {\n        const { ratio, barWidth } = renderOptions;\n        const boxPlotModels = [];\n        const seriesLength = seriesData.length;\n        const { dot } = this.theme;\n        seriesData.forEach(({ outliers, data, name, color }, seriesIndex) => {\n            const seriesColor = this.getSeriesColor(name, color);\n            ((data !== null && data !== void 0 ? data : [])).forEach((datum, dataIndex) => {\n                if (!isNull(datum)) {\n                    const startX = this.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);\n                    const rect = this.getRect(datum, startX, seriesColor, renderOptions);\n                    boxPlotModels.push(Object.assign(Object.assign({ type: 'boxPlot', color: seriesColor, name,\n                        rect, median: this.getMedian(datum, startX, seriesColor, renderOptions), minimum: this.getMinimum(datum, startX, seriesColor, renderOptions), maximum: this.getMaximum(datum, startX, seriesColor, renderOptions) }, this.getWhisker(datum, startX, seriesColor, renderOptions, rect)), { index: dataIndex, boxPlotDetection: {\n                            x: startX,\n                            width: barWidth,\n                        } }));\n                }\n            });\n            const { color: dotColor, radius, borderColor, borderWidth, useSeriesColor, } = dot;\n            ((outliers !== null && outliers !== void 0 ? outliers : [])).forEach((datum) => {\n                const [dataIndex, value] = datum;\n                const startX = this.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);\n                boxPlotModels.push({\n                    type: 'circle',\n                    name,\n                    x: startX + barWidth / 2,\n                    y: this.getYPos(value, ratio),\n                    radius: radius,\n                    style: [{ strokeStyle: (borderColor !== null && borderColor !== void 0 ? borderColor : seriesColor), lineWidth: borderWidth }],\n                    color: useSeriesColor ? seriesColor : dotColor,\n                    index: dataIndex,\n                });\n            });\n        });\n        return boxPlotModels;\n    }\n    makeTooltipModel(seriesData, categories) {\n        const tooltipData = [];\n        seriesData.forEach(({ outliers, data, name, color }) => {\n            ((data !== null && data !== void 0 ? data : [])).forEach((datum, dataIndex) => {\n                if (!isNull(datum)) {\n                    const boxPlotData = [...datum].reverse();\n                    tooltipData.push({\n                        label: name,\n                        color: color,\n                        value: [\n                            'Maximum',\n                            'Upper Quartile',\n                            'Median',\n                            'Lower Quartile',\n                            'Minimum',\n                        ].reduce((acc, title, index) => {\n                            const value = boxPlotData[index];\n                            return isNull(value) ? acc : [...acc, { title, value }];\n                        }, []),\n                        category: categories[dataIndex],\n                        templateType: 'boxPlot',\n                    });\n                }\n            });\n            ((outliers !== null && outliers !== void 0 ? outliers : [])).forEach((datum) => {\n                if (!isNull(datum)) {\n                    const [dataIndex, dataValue] = datum;\n                    tooltipData.push({\n                        label: name,\n                        color: color,\n                        value: [{ title: 'Outlier', value: dataValue }],\n                        category: categories[dataIndex],\n                        templateType: 'boxPlot',\n                    });\n                }\n            });\n        });\n        return tooltipData;\n    }\n    getStartX(seriesIndex, dataIndex, renderOptions, seriesLength) {\n        const { tickDistance, barWidth } = renderOptions;\n        const padding = getPadding(tickDistance, barWidth, seriesLength);\n        return dataIndex * tickDistance + (seriesIndex + 1) * padding + barWidth * seriesIndex;\n    }\n    getYPos(value, ratio, lineWidth) {\n        return isNumber(lineWidth)\n            ? crispPixel(this.rect.height - value * ratio, lineWidth)\n            : this.rect.height - value * ratio;\n    }\n    getBarWidths(tickDistance, seriesLength) {\n        const { barWidth: barThemeWidth, barWidthRatios } = this.theme;\n        const { barRatio, minMaxBarRatio } = barWidthRatios;\n        const defaultBarWidth = Math.max((tickDistance - getBoxTypeSeriesPadding(tickDistance) * (2 + (seriesLength - 1))) /\n            seriesLength, MIN_BAR_WIDTH);\n        const barWidth = barThemeWidth\n            ? calculateSizeWithPercentString(tickDistance / seriesLength, barThemeWidth)\n            : defaultBarWidth;\n        return {\n            barWidth: barWidth * barRatio,\n            minMaxBarWidth: barWidth * minMaxBarRatio,\n        };\n    }\n    getRespondersWithTheme(responders, type) {\n        const { color, rect, dot, line, shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur, } = this.theme[type];\n        const { whisker, median, maximum, minimum } = line;\n        const { color: dotColor, radius, borderColor, borderWidth, useSeriesColor, } = dot;\n        return responders.map((m) => {\n            const { type: modelType, data } = m;\n            let seriesColor = m.color;\n            let model;\n            if (modelType === 'circle') {\n                seriesColor = data.color;\n                model = Object.assign(Object.assign({}, m), { radius, color: useSeriesColor ? seriesColor : dotColor, style: [\n                        { strokeStyle: getDefaultColor(seriesColor, borderColor), lineWidth: borderWidth },\n                    ] });\n            }\n            else {\n                const { rect: seriesRect, upperWhisker, lowerWhisker, median: seriesMedian, maximum: seriesMaximum, minimum: seriesMinimum, } = m;\n                model = Object.assign(Object.assign({}, m), { rect: Object.assign(Object.assign({}, seriesRect), { color: (color !== null && color !== void 0 ? color : getRGBA(seriesColor, 1)), thickness: rect.borderWidth, borderColor: rect.borderColor, style: [{ shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur }] }), upperWhisker: Object.assign(Object.assign({}, upperWhisker), { strokeStyle: getDefaultColor(seriesColor, whisker.color), lineWidth: whisker.lineWidth }), lowerWhisker: Object.assign(Object.assign({}, lowerWhisker), { strokeStyle: getDefaultColor(seriesColor, whisker.color), lineWidth: whisker.lineWidth }), median: Object.assign(Object.assign({}, seriesMedian), { strokeStyle: getDefaultColor(seriesColor, median.color), lineWidth: median.lineWidth }), maximum: Object.assign(Object.assign({}, seriesMaximum), { strokeStyle: getDefaultColor(seriesColor, maximum.color), lineWidth: maximum.lineWidth }), minimum: Object.assign(Object.assign({}, seriesMinimum), { strokeStyle: getDefaultColor(seriesColor, minimum.color), lineWidth: minimum.lineWidth }) });\n            }\n            return model;\n        });\n    }\n    getRect(datum, startX, seriesColor, { barWidth, ratio }) {\n        const { rect } = this.theme;\n        const [, lowerQuartile, , highQuartile] = datum;\n        return {\n            type: 'rect',\n            x: startX,\n            y: this.getYPos(highQuartile, ratio),\n            width: barWidth,\n            height: (highQuartile - lowerQuartile) * ratio,\n            thickness: rect.borderWidth,\n            borderColor: rect.borderColor,\n            color: seriesColor,\n        };\n    }\n    getWhisker(datum, startX, seriesColor, { barWidth, ratio }, rect) {\n        const [minimum, , , , maximum] = datum;\n        const { lineWidth, color } = this.theme.line.whisker;\n        const x = crispPixel(startX + barWidth / 2, lineWidth);\n        return {\n            upperWhisker: {\n                type: 'line',\n                x,\n                y: this.getYPos(maximum, ratio, lineWidth),\n                x2: x,\n                y2: rect.y,\n                strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),\n                lineWidth,\n            },\n            lowerWhisker: {\n                type: 'line',\n                x,\n                y: this.getYPos(minimum, ratio, lineWidth),\n                x2: x,\n                y2: crispPixel(rect.y + rect.height, lineWidth),\n                strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),\n                lineWidth,\n            },\n        };\n    }\n    getMedian(datum, startX, seriesColor, { barWidth, ratio }) {\n        const median = datum[2];\n        const { lineWidth, color } = this.theme.line.median;\n        return {\n            type: 'line',\n            x: crispPixel(startX, lineWidth),\n            y: this.getYPos(median, ratio, lineWidth),\n            x2: crispPixel(startX + barWidth, lineWidth),\n            y2: this.getYPos(median, ratio, lineWidth),\n            strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),\n            lineWidth: lineWidth,\n        };\n    }\n    getMinimum(datum, startX, seriesColor, { barWidth, ratio, minMaxBarWidth }) {\n        const minimum = datum[0];\n        const { lineWidth, color } = this.theme.line.minimum;\n        return {\n            type: 'line',\n            x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),\n            y: this.getYPos(minimum, ratio, lineWidth),\n            x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),\n            y2: this.getYPos(minimum, ratio, lineWidth),\n            strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),\n            lineWidth: lineWidth,\n        };\n    }\n    getMaximum(datum, startX, seriesColor, { barWidth, ratio, minMaxBarWidth }) {\n        const maximum = datum[4];\n        const { lineWidth, color } = this.theme.line.maximum;\n        return {\n            type: 'line',\n            x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),\n            y: this.getYPos(maximum, ratio, lineWidth),\n            x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),\n            y2: this.getYPos(maximum, ratio, lineWidth),\n            strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),\n            lineWidth: lineWidth,\n        };\n    }\n    getSeriesColor(seriesName, seriesColor) {\n        const { select, areaOpacity } = this.theme;\n        const active = this.activeSeriesMap[seriesName];\n        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);\n        const selectedOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;\n        const opacity = selected ? selectedOpacity : areaOpacity;\n        return getRGBA(seriesColor, opacity);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}