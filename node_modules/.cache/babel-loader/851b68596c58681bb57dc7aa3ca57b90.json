{"ast":null,"code":"import { sum } from \"./calculator\";\nimport { pluck } from \"./arrayUtil\";\n\nfunction calculateScale(values, width, height) {\n  return width * height / sum(values);\n}\n\nfunction isVerticalStack({\n  height,\n  width\n}) {\n  return height < width;\n}\n\nfunction selectBaseSize(baseBound) {\n  return isVerticalStack(baseBound) ? baseBound.height : baseBound.width;\n}\n\nfunction makeBaseData(seriesItems, baseBound) {\n  const {\n    width,\n    height\n  } = baseBound;\n  const scale = calculateScale(pluck(seriesItems, 'data'), width, height);\n  return seriesItems.map(seriesItem => ({\n    id: seriesItem.id,\n    weight: seriesItem.data * scale\n  })).sort((a, b) => b.weight - a.weight);\n}\n/**\n * Calculate worst aspect ratio.\n * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf\n */\n\n\nfunction worst(total, min, max, baseSize) {\n  const sumSquare = total * total;\n  const sizeSquare = baseSize * baseSize;\n  return Math.max(sizeSquare * max / sumSquare, sumSquare / (sizeSquare * min));\n}\n\nfunction changedStackDirection(total, weights, baseSize, newWeight) {\n  const minWeight = Math.min(...weights);\n  const maxWeight = Math.max(...weights);\n  const beforeWorst = worst(total, minWeight, maxWeight, baseSize);\n  const newWorst = worst(total + newWeight, Math.min(minWeight, newWeight), Math.max(maxWeight, newWeight), baseSize);\n  return newWorst >= beforeWorst;\n}\n\nfunction calculateFixedSize(baseSize, total, rows) {\n  if (!total) {\n    const weights = pluck(rows, 'weight');\n    total = sum(weights);\n  }\n\n  return total / baseSize;\n}\n\nfunction addBounds(startPosition, rows, fixedSize, callback) {\n  rows.reduce((storedPosition, rowDatum) => {\n    const dynamicSize = rowDatum.weight / fixedSize;\n    callback(dynamicSize, storedPosition, rowDatum.id);\n    return storedPosition + dynamicSize;\n  }, startPosition);\n}\n\nfunction addBound(boundMap, id, rect) {\n  boundMap[id] = rect;\n}\n\nfunction addBoundsForVerticalStack(boundMap, rows, baseBound, baseSize, total) {\n  const fixedWidth = calculateFixedSize(baseSize, total, rows);\n  addBounds(baseBound.y, rows, fixedWidth, (dynamicHeight, storedTop, id) => {\n    addBound(boundMap, id, {\n      x: baseBound.x,\n      y: storedTop,\n      width: fixedWidth,\n      height: dynamicHeight\n    });\n  });\n  baseBound.x += fixedWidth;\n  baseBound.width -= fixedWidth;\n}\n\nfunction addBoundsForHorizontalStack(boundMap, rows, baseBound, baseSize, total) {\n  const fixedHeight = calculateFixedSize(baseSize, total, rows);\n  addBounds(baseBound.x, rows, fixedHeight, (dynamicWidth, storedLeft, id) => {\n    addBound(boundMap, id, {\n      x: storedLeft,\n      y: baseBound.y,\n      width: dynamicWidth,\n      height: fixedHeight\n    });\n  });\n  baseBound.y += fixedHeight;\n  baseBound.height -= fixedHeight;\n}\n\nfunction getAddingBoundsFunction(baseBound) {\n  if (isVerticalStack(baseBound)) {\n    return addBoundsForVerticalStack;\n  }\n\n  return addBoundsForHorizontalStack;\n}\n\nexport function squarify(layout, seriesItems) {\n  const baseBound = layout;\n  const baseData = makeBaseData(seriesItems, baseBound);\n  let row = [];\n  let baseSize, addBoundsFunc;\n  const boundMap = {};\n  baseData.forEach(datum => {\n    const weights = pluck(row, 'weight');\n    const totalWeight = sum(weights);\n\n    if (row.length && changedStackDirection(totalWeight, weights, baseSize, datum.weight)) {\n      addBoundsFunc(boundMap, row, baseBound, baseSize, totalWeight);\n      row = [];\n    }\n\n    if (!row.length) {\n      baseSize = selectBaseSize(baseBound);\n      addBoundsFunc = getAddingBoundsFunction(baseBound);\n    }\n\n    row.push(datum);\n  });\n\n  if (row.length) {\n    addBoundsFunc(boundMap, row, baseBound, baseSize);\n  }\n\n  return boundMap;\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/helpers/squarifier.js"],"names":["sum","pluck","calculateScale","values","width","height","isVerticalStack","selectBaseSize","baseBound","makeBaseData","seriesItems","scale","map","seriesItem","id","weight","data","sort","a","b","worst","total","min","max","baseSize","sumSquare","sizeSquare","Math","changedStackDirection","weights","newWeight","minWeight","maxWeight","beforeWorst","newWorst","calculateFixedSize","rows","addBounds","startPosition","fixedSize","callback","reduce","storedPosition","rowDatum","dynamicSize","addBound","boundMap","rect","addBoundsForVerticalStack","fixedWidth","y","dynamicHeight","storedTop","x","addBoundsForHorizontalStack","fixedHeight","dynamicWidth","storedLeft","getAddingBoundsFunction","squarify","layout","baseData","row","addBoundsFunc","forEach","datum","totalWeight","length","push"],"mappings":"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","sourcesContent":["import { sum } from \"./calculator\";\nimport { pluck } from \"./arrayUtil\";\nfunction calculateScale(values, width, height) {\n    return (width * height) / sum(values);\n}\nfunction isVerticalStack({ height, width }) {\n    return height < width;\n}\nfunction selectBaseSize(baseBound) {\n    return isVerticalStack(baseBound) ? baseBound.height : baseBound.width;\n}\nfunction makeBaseData(seriesItems, baseBound) {\n    const { width, height } = baseBound;\n    const scale = calculateScale(pluck(seriesItems, 'data'), width, height);\n    return seriesItems\n        .map((seriesItem) => ({\n        id: seriesItem.id,\n        weight: seriesItem.data * scale,\n    }))\n        .sort((a, b) => b.weight - a.weight);\n}\n/**\n * Calculate worst aspect ratio.\n * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf\n */\nfunction worst(total, min, max, baseSize) {\n    const sumSquare = total * total;\n    const sizeSquare = baseSize * baseSize;\n    return Math.max((sizeSquare * max) / sumSquare, sumSquare / (sizeSquare * min));\n}\nfunction changedStackDirection(total, weights, baseSize, newWeight) {\n    const minWeight = Math.min(...weights);\n    const maxWeight = Math.max(...weights);\n    const beforeWorst = worst(total, minWeight, maxWeight, baseSize);\n    const newWorst = worst(total + newWeight, Math.min(minWeight, newWeight), Math.max(maxWeight, newWeight), baseSize);\n    return newWorst >= beforeWorst;\n}\nfunction calculateFixedSize(baseSize, total, rows) {\n    if (!total) {\n        const weights = pluck(rows, 'weight');\n        total = sum(weights);\n    }\n    return total / baseSize;\n}\nfunction addBounds(startPosition, rows, fixedSize, callback) {\n    rows.reduce((storedPosition, rowDatum) => {\n        const dynamicSize = rowDatum.weight / fixedSize;\n        callback(dynamicSize, storedPosition, rowDatum.id);\n        return storedPosition + dynamicSize;\n    }, startPosition);\n}\nfunction addBound(boundMap, id, rect) {\n    boundMap[id] = rect;\n}\nfunction addBoundsForVerticalStack(boundMap, rows, baseBound, baseSize, total) {\n    const fixedWidth = calculateFixedSize(baseSize, total, rows);\n    addBounds(baseBound.y, rows, fixedWidth, (dynamicHeight, storedTop, id) => {\n        addBound(boundMap, id, {\n            x: baseBound.x,\n            y: storedTop,\n            width: fixedWidth,\n            height: dynamicHeight,\n        });\n    });\n    baseBound.x += fixedWidth;\n    baseBound.width -= fixedWidth;\n}\nfunction addBoundsForHorizontalStack(boundMap, rows, baseBound, baseSize, total) {\n    const fixedHeight = calculateFixedSize(baseSize, total, rows);\n    addBounds(baseBound.x, rows, fixedHeight, (dynamicWidth, storedLeft, id) => {\n        addBound(boundMap, id, {\n            x: storedLeft,\n            y: baseBound.y,\n            width: dynamicWidth,\n            height: fixedHeight,\n        });\n    });\n    baseBound.y += fixedHeight;\n    baseBound.height -= fixedHeight;\n}\nfunction getAddingBoundsFunction(baseBound) {\n    if (isVerticalStack(baseBound)) {\n        return addBoundsForVerticalStack;\n    }\n    return addBoundsForHorizontalStack;\n}\nexport function squarify(layout, seriesItems) {\n    const baseBound = layout;\n    const baseData = makeBaseData(seriesItems, baseBound);\n    let row = [];\n    let baseSize, addBoundsFunc;\n    const boundMap = {};\n    baseData.forEach((datum) => {\n        const weights = pluck(row, 'weight');\n        const totalWeight = sum(weights);\n        if (row.length && changedStackDirection(totalWeight, weights, baseSize, datum.weight)) {\n            addBoundsFunc(boundMap, row, baseBound, baseSize, totalWeight);\n            row = [];\n        }\n        if (!row.length) {\n            baseSize = selectBaseSize(baseBound);\n            addBoundsFunc = getAddingBoundsFunction(baseBound);\n        }\n        row.push(datum);\n    });\n    if (row.length) {\n        addBoundsFunc(boundMap, row, baseBound, baseSize);\n    }\n    return boundMap;\n}\n"]},"metadata":{},"sourceType":"module"}