{"ast":null,"code":"import Component from \"./component\";\nimport { getLegendItemHeight, LEGEND_CHECKBOX_SIZE, LEGEND_ICON_SIZE, LEGEND_ITEM_MARGIN_X, LEGEND_MARGIN_X } from \"../brushes/legend\";\nimport { getTextWidth } from \"../helpers/calculator\";\nimport { isVerticalAlign, padding } from \"../store/layout\";\nimport { isUndefined } from \"../helpers/utils\";\nimport { getTitleFontString } from \"../helpers/style\";\nimport { makeObservableObjectToNormal } from \"../store/reactive\";\nexport default class Legend extends Component {\n  constructor() {\n    super(...arguments);\n    this.activatedResponders = [];\n    this.seriesColorMap = {};\n    this.seriesIconTypeMap = {};\n\n    this.onClickCheckbox = responders => {\n      const {\n        label,\n        checked\n      } = responders[0];\n      this.store.dispatch('setAllLegendActiveState', true);\n      this.store.dispatch('setLegendCheckedState', {\n        name: label,\n        checked: !checked\n      });\n\n      if (checked) {\n        this.store.dispatch('disableSeries', label);\n      } else {\n        this.store.dispatch('enableSeries', label);\n      }\n\n      this.eventBus.emit('needDraw');\n    };\n\n    this.onClickLabel = responders => {\n      const {\n        label\n      } = responders[0];\n      this.eventBus.emit('resetSelectedSeries');\n\n      if (this.activatedResponders.length && this.activatedResponders[0].label === label) {\n        this.store.dispatch('setAllLegendActiveState', true);\n        this.activatedResponders = [];\n      } else {\n        this.store.dispatch('setAllLegendActiveState', false);\n        this.store.dispatch('setLegendActiveState', {\n          name: label,\n          active: true\n        });\n        this.activatedResponders = responders;\n      }\n\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  onClick({\n    responders\n  }) {\n    var _a;\n\n    if (responders.length) {\n      const {\n        data\n      } = responders[0];\n\n      if (((_a = data) === null || _a === void 0 ? void 0 : _a.name) === 'checkbox') {\n        this.eventBus.emit('clickLegendCheckbox', makeObservableObjectToNormal(responders));\n      } else {\n        this.eventBus.emit('clickLegendLabel', makeObservableObjectToNormal(responders));\n      }\n    }\n  }\n\n  initialize() {\n    this.type = 'legend';\n    this.name = 'legend';\n    this.eventBus.on('clickLegendCheckbox', this.onClickCheckbox);\n    this.eventBus.on('clickLegendLabel', this.onClickLabel);\n  }\n\n  initColorAndIconTypeMap(legendData) {\n    this.seriesColorMap = {};\n    this.seriesIconTypeMap = {};\n    legendData.forEach(({\n      label,\n      color,\n      iconType\n    }) => {\n      this.seriesColorMap[label] = color;\n      this.seriesIconTypeMap[label] = iconType;\n    });\n  }\n\n  getXPositionWhenVerticalAlign(data) {\n    const {\n      offset,\n      rowWidths\n    } = data.reduce((acc, datum) => {\n      const {\n        rowIndex,\n        columnIndex,\n        width\n      } = datum;\n\n      if (isUndefined(acc.rowWidths[rowIndex])) {\n        acc.rowWidths[rowIndex] = 0;\n        acc.offset[rowIndex] = [0];\n      }\n\n      acc.rowWidths[rowIndex] += width + (columnIndex ? LEGEND_ITEM_MARGIN_X : 0);\n      acc.offset[rowIndex][columnIndex + 1] = acc.offset[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + width;\n      return acc;\n    }, {\n      offset: [],\n      rowWidths: []\n    });\n    const {\n      width\n    } = this.rect;\n    rowWidths.forEach((rowWidth, rowIndex) => {\n      const xMargin = (width - rowWidth) / 2;\n      offset[rowIndex] = offset[rowIndex].map(xOffset => xOffset + xMargin);\n    });\n    return offset;\n  }\n\n  getXPositionWhenHorizontalAlign(data) {\n    const maxWidths = data.reduce((acc, datum) => {\n      const {\n        columnIndex,\n        width\n      } = datum;\n\n      if (isUndefined(acc[columnIndex])) {\n        acc[columnIndex] = 0;\n      }\n\n      acc[columnIndex] = Math.max(acc[columnIndex], width);\n      return acc;\n    }, []);\n    return data.reduce((acc, datum) => {\n      const {\n        rowIndex,\n        columnIndex\n      } = datum;\n\n      if (isUndefined(acc[rowIndex])) {\n        acc[rowIndex] = [0];\n      }\n\n      acc[rowIndex][columnIndex + 1] = acc[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + maxWidths[columnIndex];\n      return acc;\n    }, []);\n  }\n\n  renderLegendModel(legend) {\n    const {\n      data,\n      showCheckbox,\n      align,\n      useScatterChartIcon\n    } = legend;\n    const verticalAlign = isVerticalAlign(align);\n    const itemHeight = getLegendItemHeight(this.theme.label.fontSize);\n    const xPosition = verticalAlign ? this.getXPositionWhenVerticalAlign(data) : this.getXPositionWhenHorizontalAlign(data);\n    return [Object.assign({\n      type: 'legend',\n      align,\n      showCheckbox,\n      data: data.map(datum => {\n        var _a;\n\n        const {\n          label,\n          iconType,\n          rowIndex,\n          columnIndex\n        } = datum;\n        return Object.assign(Object.assign({}, datum), {\n          iconType: (_a = this.seriesIconTypeMap[label], _a !== null && _a !== void 0 ? _a : iconType),\n          color: this.seriesColorMap[label],\n          x: xPosition[rowIndex][columnIndex],\n          y: padding.Y + itemHeight * rowIndex,\n          useScatterChartIcon\n        });\n      })\n    }, this.theme.label)];\n  }\n\n  makeCheckboxResponder(data, showCheckbox) {\n    return showCheckbox ? data.map(m => Object.assign(Object.assign({}, m), {\n      type: 'rect',\n      x: m.x,\n      y: m.y,\n      width: LEGEND_CHECKBOX_SIZE,\n      height: LEGEND_CHECKBOX_SIZE,\n      data: {\n        name: 'checkbox'\n      }\n    })) : [];\n  }\n\n  makeLabelResponder(data, showCheckbox) {\n    const font = getTitleFontString(this.theme.label);\n    return data.map(m => Object.assign(Object.assign({}, m), {\n      type: 'rect',\n      x: m.x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X,\n      y: m.y,\n      width: getTextWidth(m.label, font),\n      data: {\n        name: 'label'\n      },\n      height: LEGEND_CHECKBOX_SIZE\n    }));\n  }\n\n  render({\n    layout,\n    legend,\n    theme\n  }) {\n    this.isShow = legend.visible && !!legend.data.length;\n\n    if (!this.isShow) {\n      return;\n    } // @TODO: stack 일 떄 라벨 순서 역순으로(스택이 쌓인 순서대로) 되어야\n\n\n    const {\n      showCheckbox,\n      data: legendData\n    } = legend;\n    this.rect = layout.legend;\n    this.theme = theme.legend;\n    this.initColorAndIconTypeMap(legendData);\n    this.models = this.renderLegendModel(legend);\n    const {\n      data\n    } = this.models[0];\n    const checkboxResponder = this.makeCheckboxResponder(data, showCheckbox);\n    const labelResponder = this.makeLabelResponder(data, showCheckbox);\n    this.responders = [...checkboxResponder, ...labelResponder];\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/legend.js"],"names":["Component","getLegendItemHeight","LEGEND_CHECKBOX_SIZE","LEGEND_ICON_SIZE","LEGEND_ITEM_MARGIN_X","LEGEND_MARGIN_X","getTextWidth","isVerticalAlign","padding","isUndefined","getTitleFontString","makeObservableObjectToNormal","Legend","constructor","arguments","activatedResponders","seriesColorMap","seriesIconTypeMap","onClickCheckbox","responders","label","checked","store","dispatch","name","eventBus","emit","onClickLabel","length","active","onClick","_a","data","initialize","type","on","initColorAndIconTypeMap","legendData","forEach","color","iconType","getXPositionWhenVerticalAlign","offset","rowWidths","reduce","acc","datum","rowIndex","columnIndex","width","rect","rowWidth","xMargin","map","xOffset","getXPositionWhenHorizontalAlign","maxWidths","Math","max","renderLegendModel","legend","showCheckbox","align","useScatterChartIcon","verticalAlign","itemHeight","theme","fontSize","xPosition","Object","assign","x","y","Y","makeCheckboxResponder","m","height","makeLabelResponder","font","render","layout","isShow","visible","models","checkboxResponder","labelResponder"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { getLegendItemHeight, LEGEND_CHECKBOX_SIZE, LEGEND_ICON_SIZE, LEGEND_ITEM_MARGIN_X, LEGEND_MARGIN_X, } from \"../brushes/legend\";\nimport { getTextWidth } from \"../helpers/calculator\";\nimport { isVerticalAlign, padding } from \"../store/layout\";\nimport { isUndefined } from \"../helpers/utils\";\nimport { getTitleFontString } from \"../helpers/style\";\nimport { makeObservableObjectToNormal } from \"../store/reactive\";\nexport default class Legend extends Component {\n    constructor() {\n        super(...arguments);\n        this.activatedResponders = [];\n        this.seriesColorMap = {};\n        this.seriesIconTypeMap = {};\n        this.onClickCheckbox = (responders) => {\n            const { label, checked } = responders[0];\n            this.store.dispatch('setAllLegendActiveState', true);\n            this.store.dispatch('setLegendCheckedState', { name: label, checked: !checked });\n            if (checked) {\n                this.store.dispatch('disableSeries', label);\n            }\n            else {\n                this.store.dispatch('enableSeries', label);\n            }\n            this.eventBus.emit('needDraw');\n        };\n        this.onClickLabel = (responders) => {\n            const { label } = responders[0];\n            this.eventBus.emit('resetSelectedSeries');\n            if (this.activatedResponders.length && this.activatedResponders[0].label === label) {\n                this.store.dispatch('setAllLegendActiveState', true);\n                this.activatedResponders = [];\n            }\n            else {\n                this.store.dispatch('setAllLegendActiveState', false);\n                this.store.dispatch('setLegendActiveState', { name: label, active: true });\n                this.activatedResponders = responders;\n            }\n            this.eventBus.emit('needDraw');\n        };\n    }\n    onClick({ responders }) {\n        var _a;\n        if (responders.length) {\n            const { data } = responders[0];\n            if (((_a = data) === null || _a === void 0 ? void 0 : _a.name) === 'checkbox') {\n                this.eventBus.emit('clickLegendCheckbox', makeObservableObjectToNormal(responders));\n            }\n            else {\n                this.eventBus.emit('clickLegendLabel', makeObservableObjectToNormal(responders));\n            }\n        }\n    }\n    initialize() {\n        this.type = 'legend';\n        this.name = 'legend';\n        this.eventBus.on('clickLegendCheckbox', this.onClickCheckbox);\n        this.eventBus.on('clickLegendLabel', this.onClickLabel);\n    }\n    initColorAndIconTypeMap(legendData) {\n        this.seriesColorMap = {};\n        this.seriesIconTypeMap = {};\n        legendData.forEach(({ label, color, iconType }) => {\n            this.seriesColorMap[label] = color;\n            this.seriesIconTypeMap[label] = iconType;\n        });\n    }\n    getXPositionWhenVerticalAlign(data) {\n        const { offset, rowWidths } = data.reduce((acc, datum) => {\n            const { rowIndex, columnIndex, width } = datum;\n            if (isUndefined(acc.rowWidths[rowIndex])) {\n                acc.rowWidths[rowIndex] = 0;\n                acc.offset[rowIndex] = [0];\n            }\n            acc.rowWidths[rowIndex] += width + (columnIndex ? LEGEND_ITEM_MARGIN_X : 0);\n            acc.offset[rowIndex][columnIndex + 1] =\n                acc.offset[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + width;\n            return acc;\n        }, { offset: [], rowWidths: [] });\n        const { width } = this.rect;\n        rowWidths.forEach((rowWidth, rowIndex) => {\n            const xMargin = (width - rowWidth) / 2;\n            offset[rowIndex] = offset[rowIndex].map((xOffset) => xOffset + xMargin);\n        });\n        return offset;\n    }\n    getXPositionWhenHorizontalAlign(data) {\n        const maxWidths = data.reduce((acc, datum) => {\n            const { columnIndex, width } = datum;\n            if (isUndefined(acc[columnIndex])) {\n                acc[columnIndex] = 0;\n            }\n            acc[columnIndex] = Math.max(acc[columnIndex], width);\n            return acc;\n        }, []);\n        return data.reduce((acc, datum) => {\n            const { rowIndex, columnIndex } = datum;\n            if (isUndefined(acc[rowIndex])) {\n                acc[rowIndex] = [0];\n            }\n            acc[rowIndex][columnIndex + 1] =\n                acc[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + maxWidths[columnIndex];\n            return acc;\n        }, []);\n    }\n    renderLegendModel(legend) {\n        const { data, showCheckbox, align, useScatterChartIcon } = legend;\n        const verticalAlign = isVerticalAlign(align);\n        const itemHeight = getLegendItemHeight(this.theme.label.fontSize);\n        const xPosition = verticalAlign\n            ? this.getXPositionWhenVerticalAlign(data)\n            : this.getXPositionWhenHorizontalAlign(data);\n        return [\n            Object.assign({ type: 'legend', align,\n                showCheckbox, data: data.map((datum) => {\n                    var _a;\n                    const { label, iconType, rowIndex, columnIndex } = datum;\n                    return Object.assign(Object.assign({}, datum), { iconType: (_a = this.seriesIconTypeMap[label], (_a !== null && _a !== void 0 ? _a : iconType)), color: this.seriesColorMap[label], x: xPosition[rowIndex][columnIndex], y: padding.Y + itemHeight * rowIndex, useScatterChartIcon });\n                }) }, this.theme.label),\n        ];\n    }\n    makeCheckboxResponder(data, showCheckbox) {\n        return showCheckbox\n            ? data.map((m) => (Object.assign(Object.assign({}, m), { type: 'rect', x: m.x, y: m.y, width: LEGEND_CHECKBOX_SIZE, height: LEGEND_CHECKBOX_SIZE, data: { name: 'checkbox' } })))\n            : [];\n    }\n    makeLabelResponder(data, showCheckbox) {\n        const font = getTitleFontString(this.theme.label);\n        return data.map((m) => (Object.assign(Object.assign({}, m), { type: 'rect', x: m.x +\n                (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) +\n                LEGEND_ICON_SIZE +\n                LEGEND_MARGIN_X, y: m.y, width: getTextWidth(m.label, font), data: { name: 'label' }, height: LEGEND_CHECKBOX_SIZE })));\n    }\n    render({ layout, legend, theme }) {\n        this.isShow = legend.visible && !!legend.data.length;\n        if (!this.isShow) {\n            return;\n        }\n        // @TODO: stack 일 떄 라벨 순서 역순으로(스택이 쌓인 순서대로) 되어야\n        const { showCheckbox, data: legendData } = legend;\n        this.rect = layout.legend;\n        this.theme = theme.legend;\n        this.initColorAndIconTypeMap(legendData);\n        this.models = this.renderLegendModel(legend);\n        const { data } = this.models[0];\n        const checkboxResponder = this.makeCheckboxResponder(data, showCheckbox);\n        const labelResponder = this.makeLabelResponder(data, showCheckbox);\n        this.responders = [...checkboxResponder, ...labelResponder];\n    }\n}\n"]},"metadata":{},"sourceType":"module"}