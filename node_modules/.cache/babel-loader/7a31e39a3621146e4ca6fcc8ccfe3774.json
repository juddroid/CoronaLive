{"ast":null,"code":"function limitNegative(value, min, max) {\n  let result = value;\n\n  if (result >= max) {\n    return 0;\n  }\n\n  if (max < 0) {\n    result = Math.min(value - max, 0);\n  }\n\n  if (value < min) {\n    result -= value - min;\n  }\n\n  return result;\n}\n\nfunction limitPositive(value, min, max) {\n  let result = value;\n\n  if (min > 0) {\n    result = Math.max(value - min, 0);\n  }\n\n  if (value > max) {\n    result -= value - max;\n  }\n\n  return result;\n}\n\nexport function calibrateDrawingValue(value, min, max) {\n  return value < 0 ? limitNegative(value, min, max) : limitPositive(value, min, max);\n}\nexport function sumValuesBeforeIndex(values, targetIndex, includeTarget = false) {\n  const target = values[targetIndex];\n  return values.reduce((total, value, idx) => {\n    const isBefore = includeTarget ? idx <= targetIndex : idx < targetIndex;\n    const isSameSign = value * target >= 0;\n    return isBefore && isSameSign ? total + value : total;\n  }, 0);\n}\nexport function outsideRange(values, currentIndex, min, max) {\n  const value = values[currentIndex];\n  const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);\n  const positive = value >= 0;\n  const negative = value < 0;\n  return positive && totalOfIndexBefore >= max || negative && totalOfIndexBefore <= min || currentIndex === 0 && positive && value < min || currentIndex === 0 && negative && value > max;\n}\nexport function calibrateBoxStackDrawingValue(values, currentIndex, min, max) {\n  const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);\n  const totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);\n\n  if (outsideRange(values, currentIndex, min, max)) {\n    return null;\n  }\n\n  if (currentIndex === 0) {\n    return calibrateDrawingValue(values[currentIndex], min, max);\n  }\n\n  if (totalOfIndexBefore < min && totalOfValues > max) {\n    return max - min;\n  }\n\n  let result = values[currentIndex];\n\n  if (totalOfValues > max) {\n    result = max - totalOfIndexBefore;\n  } else if (totalOfValues < min) {\n    result = min - totalOfIndexBefore;\n  } else if (totalOfIndexBefore < min) {\n    result = totalOfValues - min;\n  } else if (totalOfIndexBefore > max) {\n    result = totalOfValues - max;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/helpers/boxSeries.js"],"names":["limitNegative","value","min","max","result","Math","limitPositive","calibrateDrawingValue","sumValuesBeforeIndex","values","targetIndex","includeTarget","target","reduce","total","idx","isBefore","isSameSign","outsideRange","currentIndex","totalOfIndexBefore","positive","negative","calibrateBoxStackDrawingValue","totalOfValues"],"mappings":"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","sourcesContent":["function limitNegative(value, min, max) {\n    let result = value;\n    if (result >= max) {\n        return 0;\n    }\n    if (max < 0) {\n        result = Math.min(value - max, 0);\n    }\n    if (value < min) {\n        result -= value - min;\n    }\n    return result;\n}\nfunction limitPositive(value, min, max) {\n    let result = value;\n    if (min > 0) {\n        result = Math.max(value - min, 0);\n    }\n    if (value > max) {\n        result -= value - max;\n    }\n    return result;\n}\nexport function calibrateDrawingValue(value, min, max) {\n    return value < 0 ? limitNegative(value, min, max) : limitPositive(value, min, max);\n}\nexport function sumValuesBeforeIndex(values, targetIndex, includeTarget = false) {\n    const target = values[targetIndex];\n    return values.reduce((total, value, idx) => {\n        const isBefore = includeTarget ? idx <= targetIndex : idx < targetIndex;\n        const isSameSign = value * target >= 0;\n        return isBefore && isSameSign ? total + value : total;\n    }, 0);\n}\nexport function outsideRange(values, currentIndex, min, max) {\n    const value = values[currentIndex];\n    const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);\n    const positive = value >= 0;\n    const negative = value < 0;\n    return ((positive && totalOfIndexBefore >= max) ||\n        (negative && totalOfIndexBefore <= min) ||\n        (currentIndex === 0 && positive && value < min) ||\n        (currentIndex === 0 && negative && value > max));\n}\nexport function calibrateBoxStackDrawingValue(values, currentIndex, min, max) {\n    const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);\n    const totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);\n    if (outsideRange(values, currentIndex, min, max)) {\n        return null;\n    }\n    if (currentIndex === 0) {\n        return calibrateDrawingValue(values[currentIndex], min, max);\n    }\n    if (totalOfIndexBefore < min && totalOfValues > max) {\n        return max - min;\n    }\n    let result = values[currentIndex];\n    if (totalOfValues > max) {\n        result = max - totalOfIndexBefore;\n    }\n    else if (totalOfValues < min) {\n        result = min - totalOfIndexBefore;\n    }\n    else if (totalOfIndexBefore < min) {\n        result = totalOfValues - min;\n    }\n    else if (totalOfIndexBefore > max) {\n        result = totalOfValues - max;\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}