{"ast":null,"code":"import Component from \"./component\";\nimport { range } from \"../helpers/utils\";\nimport { sortNumber } from \"../helpers/utils\";\nimport { makeObservableObjectToNormal } from \"../store/reactive\";\nconst DRAG_MIN_WIDTH = 15;\nexport default class Zoom extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      selectionArea: []\n    };\n    this.dragStartPosition = null;\n    this.dragStartPoint = null;\n    this.isDragging = false;\n  }\n\n  initialize() {\n    this.type = 'zoom';\n  }\n\n  render(state) {\n    if (!state.zoomRange) {\n      return;\n    }\n\n    this.resetSelectionArea();\n    const {\n      layout,\n      axes,\n      categories\n    } = state;\n    this.rect = layout.plot;\n    const {\n      tickDistance,\n      pointOnColumn,\n      tickCount\n    } = axes.xAxis;\n    this.responders = this.makeRectResponderModel(categories, {\n      pointOnColumn,\n      tickDistance,\n      tickCount\n    });\n  }\n\n  resetSelectionArea() {\n    this.dragStartPosition = null;\n    this.dragStartPoint = null;\n    this.models.selectionArea = [];\n    this.isDragging = false;\n  }\n\n  onMousedown({\n    responders,\n    mousePosition\n  }) {\n    if (responders.length) {\n      this.dragStartPoint = responders.find(responder => responder.data.name === 'selectionArea');\n      this.dragStartPosition = mousePosition;\n    }\n  }\n\n  onMouseup({\n    responders\n  }) {\n    if (this.isDragging && this.dragStartPoint && responders.length) {\n      const dragRange = [this.dragStartPoint, responders[0]].sort((a, b) => a.index - b.index).map(m => {\n        var _a;\n\n        return (_a = m.data) === null || _a === void 0 ? void 0 : _a.value;\n      });\n      this.store.dispatch('zoom', dragRange);\n      this.eventBus.emit('zoom', makeObservableObjectToNormal(dragRange));\n      this.eventBus.emit('resetHoveredSeries');\n      this.eventBus.emit('hideTooltip'); // @TODO: Should occur after the series' click event\n      // Additional logic to control the sequence of events with each other is required.\n\n      setTimeout(() => {\n        this.eventBus.emit('resetSelectedSeries');\n      });\n    }\n\n    this.resetSelectionArea();\n  }\n\n  makeRectResponderModel(categories, renderOptions) {\n    const categorySize = categories.length;\n    const {\n      pointOnColumn,\n      tickDistance\n    } = renderOptions;\n    const {\n      height\n    } = this.rect;\n    const halfDetectAreaIndex = pointOnColumn ? [] : [0, categorySize - 1];\n    const halfWidth = tickDistance / 2;\n    return range(0, categorySize).map(index => {\n      const half = halfDetectAreaIndex.includes(index);\n      const width = half ? halfWidth : tickDistance;\n      let startX = 0;\n\n      if (index !== 0) {\n        startX += pointOnColumn ? tickDistance * index : halfWidth + tickDistance * (index - 1);\n      }\n\n      return {\n        type: 'rect',\n        x: startX,\n        y: 0,\n        height,\n        width,\n        index,\n        data: {\n          name: 'selectionArea',\n          value: categories[index]\n        }\n      };\n    });\n  }\n\n  onMousemove({\n    responders,\n    mousePosition\n  }) {\n    if (!responders.length) {\n      return;\n    }\n\n    if (this.dragStartPosition && !this.isDragging) {\n      const {\n        x\n      } = mousePosition;\n      const {\n        x: startX\n      } = this.dragStartPosition;\n      this.isDragging = Math.abs(startX - x) > DRAG_MIN_WIDTH;\n    }\n\n    if (this.isDragging) {\n      const startIndex = this.dragStartPoint.index;\n      const endIndex = responders[0].index;\n      const [start, end] = [startIndex, endIndex].sort(sortNumber);\n      const includedResponders = this.responders.slice(start, end + 1);\n      this.models.selectionArea = [...includedResponders.map(m => Object.assign(Object.assign({}, m), {\n        x: m.x,\n        y: 0,\n        type: 'rect',\n        color: 'rgba(0, 0, 0, 0.2)'\n      }))];\n      this.eventBus.emit('needDraw');\n    }\n  }\n\n  onMouseoutComponent() {\n    this.resetSelectionArea();\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/zoom.js"],"names":["Component","range","sortNumber","makeObservableObjectToNormal","DRAG_MIN_WIDTH","Zoom","constructor","arguments","models","selectionArea","dragStartPosition","dragStartPoint","isDragging","initialize","type","render","state","zoomRange","resetSelectionArea","layout","axes","categories","rect","plot","tickDistance","pointOnColumn","tickCount","xAxis","responders","makeRectResponderModel","onMousedown","mousePosition","length","find","responder","data","name","onMouseup","dragRange","sort","a","b","index","map","m","_a","value","store","dispatch","eventBus","emit","setTimeout","renderOptions","categorySize","height","halfDetectAreaIndex","halfWidth","half","includes","width","startX","x","y","onMousemove","Math","abs","startIndex","endIndex","start","end","includedResponders","slice","Object","assign","color","onMouseoutComponent"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { range } from \"../helpers/utils\";\nimport { sortNumber } from \"../helpers/utils\";\nimport { makeObservableObjectToNormal } from \"../store/reactive\";\nconst DRAG_MIN_WIDTH = 15;\nexport default class Zoom extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { selectionArea: [] };\n        this.dragStartPosition = null;\n        this.dragStartPoint = null;\n        this.isDragging = false;\n    }\n    initialize() {\n        this.type = 'zoom';\n    }\n    render(state) {\n        if (!state.zoomRange) {\n            return;\n        }\n        this.resetSelectionArea();\n        const { layout, axes, categories } = state;\n        this.rect = layout.plot;\n        const { tickDistance, pointOnColumn, tickCount } = axes.xAxis;\n        this.responders = this.makeRectResponderModel(categories, {\n            pointOnColumn,\n            tickDistance,\n            tickCount,\n        });\n    }\n    resetSelectionArea() {\n        this.dragStartPosition = null;\n        this.dragStartPoint = null;\n        this.models.selectionArea = [];\n        this.isDragging = false;\n    }\n    onMousedown({ responders, mousePosition }) {\n        if (responders.length) {\n            this.dragStartPoint = responders.find((responder) => responder.data.name === 'selectionArea');\n            this.dragStartPosition = mousePosition;\n        }\n    }\n    onMouseup({ responders }) {\n        if (this.isDragging && this.dragStartPoint && responders.length) {\n            const dragRange = [this.dragStartPoint, responders[0]]\n                .sort((a, b) => a.index - b.index)\n                .map((m) => { var _a; return (_a = m.data) === null || _a === void 0 ? void 0 : _a.value; });\n            this.store.dispatch('zoom', dragRange);\n            this.eventBus.emit('zoom', makeObservableObjectToNormal(dragRange));\n            this.eventBus.emit('resetHoveredSeries');\n            this.eventBus.emit('hideTooltip');\n            // @TODO: Should occur after the series' click event\n            // Additional logic to control the sequence of events with each other is required.\n            setTimeout(() => {\n                this.eventBus.emit('resetSelectedSeries');\n            });\n        }\n        this.resetSelectionArea();\n    }\n    makeRectResponderModel(categories, renderOptions) {\n        const categorySize = categories.length;\n        const { pointOnColumn, tickDistance } = renderOptions;\n        const { height } = this.rect;\n        const halfDetectAreaIndex = pointOnColumn ? [] : [0, categorySize - 1];\n        const halfWidth = tickDistance / 2;\n        return range(0, categorySize).map((index) => {\n            const half = halfDetectAreaIndex.includes(index);\n            const width = half ? halfWidth : tickDistance;\n            let startX = 0;\n            if (index !== 0) {\n                startX += pointOnColumn ? tickDistance * index : halfWidth + tickDistance * (index - 1);\n            }\n            return {\n                type: 'rect',\n                x: startX,\n                y: 0,\n                height,\n                width,\n                index,\n                data: { name: 'selectionArea', value: categories[index] },\n            };\n        });\n    }\n    onMousemove({ responders, mousePosition }) {\n        if (!responders.length) {\n            return;\n        }\n        if (this.dragStartPosition && !this.isDragging) {\n            const { x } = mousePosition;\n            const { x: startX } = this.dragStartPosition;\n            this.isDragging = Math.abs(startX - x) > DRAG_MIN_WIDTH;\n        }\n        if (this.isDragging) {\n            const startIndex = this.dragStartPoint.index;\n            const endIndex = responders[0].index;\n            const [start, end] = [startIndex, endIndex].sort(sortNumber);\n            const includedResponders = this.responders.slice(start, end + 1);\n            this.models.selectionArea = [\n                ...includedResponders.map((m) => (Object.assign(Object.assign({}, m), { x: m.x, y: 0, type: 'rect', color: 'rgba(0, 0, 0, 0.2)' }))),\n            ];\n            this.eventBus.emit('needDraw');\n        }\n    }\n    onMouseoutComponent() {\n        this.resetSelectionArea();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}