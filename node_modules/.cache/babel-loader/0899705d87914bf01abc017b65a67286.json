{"ast":null,"code":"import { extend } from \"./store\";\nimport { pickProperty, isObject, sum } from \"../helpers/utils\";\nexport function isPercentStack(stack) {\n  var _a;\n\n  return !!(((_a = stack) === null || _a === void 0 ? void 0 : _a.type) === 'percent');\n}\nexport function isGroupStack(rawData) {\n  return !Array.isArray(rawData);\n}\nexport function hasPercentStackSeries(stackSeries) {\n  if (!stackSeries) {\n    return false;\n  }\n\n  return Object.keys(stackSeries).some(seriesName => isPercentStack(stackSeries[seriesName].stack));\n}\nexport function pickStackOption(options) {\n  return pickProperty(options, ['series', 'stack']) || pickProperty(options, ['series', 'column', 'stack']) || pickProperty(options, ['series', 'area', 'stack']);\n}\n\nfunction makeStackData(seriesData) {\n  const seriesCount = seriesData.length;\n  const groupCountLengths = seriesData.map(({\n    rawData\n  }) => rawData.length);\n  const seriesGroupCount = Math.max(...groupCountLengths);\n  const stackData = [];\n\n  for (let i = 0; i < seriesGroupCount; i += 1) {\n    const stackValues = [];\n\n    for (let j = 0; j < seriesCount; j += 1) {\n      stackValues.push(seriesData[j].rawData[i]);\n    }\n\n    stackData[i] = {\n      values: stackValues,\n      sum: sum(stackValues),\n      total: {\n        positive: sum(stackValues.filter(value => value >= 0)),\n        negative: sum(stackValues.filter(value => value < 0))\n      }\n    };\n  }\n\n  return stackData;\n}\n\nfunction makeStackGroupData(seriesData) {\n  const stackData = {};\n  const stackGroupIds = [...new Set(seriesData.map(({\n    stackGroup\n  }) => stackGroup))];\n  stackGroupIds.forEach(groupId => {\n    const filtered = seriesData.filter(({\n      stackGroup\n    }) => groupId === stackGroup);\n    stackData[groupId] = makeStackData(filtered);\n  });\n  return stackData;\n}\n\nfunction initializeStack(stackOption) {\n  if (!stackOption) {\n    return;\n  }\n\n  const defaultStackOption = {\n    type: 'normal',\n    connector: false\n  };\n\n  if (isStackObject(stackOption)) {\n    return Object.assign(Object.assign({}, defaultStackOption), stackOption);\n  }\n\n  return defaultStackOption;\n}\n\nfunction isStackObject(stackOption) {\n  return isObject(stackOption);\n}\n\nfunction hasStackGrouped(seriesRawData) {\n  return seriesRawData.some(rawData => rawData.hasOwnProperty('stackGroup'));\n}\n\nfunction getStackDataRangeValues(stackData) {\n  let values = [];\n\n  if (Array.isArray(stackData)) {\n    values = [0, ...getSumValues(stackData)];\n  } else {\n    for (const groupId in stackData) {\n      if (Object.prototype.hasOwnProperty.call(stackData, groupId)) {\n        values = [0, ...values, ...getSumValues(stackData[groupId])];\n      }\n    }\n  }\n\n  return values;\n}\n\nfunction getSumValues(stackData) {\n  const positiveSum = stackData.map(({\n    total\n  }) => total.positive);\n  const negativeSum = stackData.map(({\n    total\n  }) => total.negative);\n  return [...negativeSum, ...positiveSum];\n}\n\nfunction getStackDataValues(stackData) {\n  if (!isGroupStack(stackData)) {\n    return stackData;\n  }\n\n  let stackDataValues = [];\n\n  if (isGroupStack(stackData)) {\n    Object.keys(stackData).forEach(groupId => {\n      stackDataValues = [...stackDataValues, ...stackData[groupId]];\n    });\n  }\n\n  return stackDataValues;\n}\n\nfunction checkIfNegativeAndPositiveValues(stackData) {\n  return {\n    hasNegative: stackData.map(({\n      total\n    }) => total.negative).some(total => total < 0),\n    hasPositive: stackData.map(({\n      total\n    }) => total.positive).some(total => total >= 0)\n  };\n}\n\nfunction getScaleType(stackData, stackType, diverging) {\n  const {\n    hasPositive,\n    hasNegative\n  } = checkIfNegativeAndPositiveValues(stackData);\n\n  if (stackType === 'percent') {\n    if (diverging) {\n      return 'divergingPercentStack';\n    }\n\n    if (hasNegative && hasPositive) {\n      return 'dualPercentStack';\n    }\n\n    if (!hasNegative && hasPositive) {\n      return 'percentStack';\n    }\n\n    if (hasNegative && !hasPositive) {\n      return 'minusPercentStack';\n    }\n  }\n}\n\nfunction initStackSeries(series, options) {\n  const stackSeries = {};\n  Object.keys(series).forEach(seriesName => {\n    const chartType = seriesName;\n    const stackOption = pickStackOption(options);\n\n    if (stackOption) {\n      if (!stackSeries[chartType]) {\n        stackSeries[chartType] = {};\n      }\n\n      stackSeries[chartType].stack = initializeStack(stackOption);\n    } else if (seriesName === 'radialBar') {\n      stackSeries[seriesName] = {\n        stack: true\n      };\n    }\n  });\n  return stackSeries;\n}\n\nconst stackSeriesData = {\n  name: 'stackSeriesData',\n  state: ({\n    series,\n    options\n  }) => ({\n    stackSeries: initStackSeries(series, options)\n  }),\n  action: {\n    setStackSeriesData({\n      state\n    }) {\n      const {\n        series,\n        stackSeries,\n        options\n      } = state;\n      const stackOption = pickStackOption(options);\n      const newStackSeries = {};\n      Object.keys(series).forEach(seriesName => {\n        var _a, _b;\n\n        const seriesData = series[seriesName];\n        const {\n          data,\n          seriesCount,\n          seriesGroupCount\n        } = seriesData;\n        const isRadialBar = seriesName === 'radialBar';\n\n        if (stackOption) {\n          if (!stackSeries[seriesName]) {\n            stackSeries[seriesName] = {};\n          }\n\n          stackSeries[seriesName].stack = initializeStack(stackOption);\n        } else if (!isRadialBar) {\n          stackSeries[seriesName] = null;\n          delete stackSeries[seriesName];\n        }\n\n        const {\n          stack\n        } = stackSeries[seriesName] || {};\n        const diverging = !!((_a = options.series) === null || _a === void 0 ? void 0 : _a.diverging);\n\n        if (stack) {\n          const stackData = hasStackGrouped(data) ? makeStackGroupData(data) : makeStackData(data);\n          const stackType = (_b = stack.type, _b !== null && _b !== void 0 ? _b : 'normal');\n          const dataRangeValues = getStackDataRangeValues(stackData);\n          newStackSeries[seriesName] = {\n            data,\n            seriesCount,\n            seriesGroupCount,\n            stackData,\n            dataRangeValues,\n            scaleType: getScaleType(getStackDataValues(stackData), stackType, diverging)\n          };\n          state.stackSeries[seriesName].stackData = stackData;\n        }\n\n        extend(state.stackSeries, newStackSeries);\n      });\n    }\n\n  },\n  observe: {\n    updateStackSeriesData() {\n      this.dispatch('setStackSeriesData');\n    }\n\n  }\n};\nexport default stackSeriesData;","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js"],"names":["extend","pickProperty","isObject","sum","isPercentStack","stack","_a","type","isGroupStack","rawData","Array","isArray","hasPercentStackSeries","stackSeries","Object","keys","some","seriesName","pickStackOption","options","makeStackData","seriesData","seriesCount","length","groupCountLengths","map","seriesGroupCount","Math","max","stackData","i","stackValues","j","push","values","total","positive","filter","value","negative","makeStackGroupData","stackGroupIds","Set","stackGroup","forEach","groupId","filtered","initializeStack","stackOption","defaultStackOption","connector","isStackObject","assign","hasStackGrouped","seriesRawData","hasOwnProperty","getStackDataRangeValues","getSumValues","prototype","call","positiveSum","negativeSum","getStackDataValues","stackDataValues","checkIfNegativeAndPositiveValues","hasNegative","hasPositive","getScaleType","stackType","diverging","initStackSeries","series","chartType","stackSeriesData","name","state","action","setStackSeriesData","newStackSeries","_b","data","isRadialBar","dataRangeValues","scaleType","observe","updateStackSeriesData","dispatch"],"mappings":"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","sourcesContent":["import { extend } from \"./store\";\nimport { pickProperty, isObject, sum } from \"../helpers/utils\";\nexport function isPercentStack(stack) {\n    var _a;\n    return !!(((_a = stack) === null || _a === void 0 ? void 0 : _a.type) === 'percent');\n}\nexport function isGroupStack(rawData) {\n    return !Array.isArray(rawData);\n}\nexport function hasPercentStackSeries(stackSeries) {\n    if (!stackSeries) {\n        return false;\n    }\n    return Object.keys(stackSeries).some((seriesName) => isPercentStack(stackSeries[seriesName].stack));\n}\nexport function pickStackOption(options) {\n    return (pickProperty(options, ['series', 'stack']) ||\n        pickProperty(options, ['series', 'column', 'stack']) ||\n        pickProperty(options, ['series', 'area', 'stack']));\n}\nfunction makeStackData(seriesData) {\n    const seriesCount = seriesData.length;\n    const groupCountLengths = seriesData.map(({ rawData }) => rawData.length);\n    const seriesGroupCount = Math.max(...groupCountLengths);\n    const stackData = [];\n    for (let i = 0; i < seriesGroupCount; i += 1) {\n        const stackValues = [];\n        for (let j = 0; j < seriesCount; j += 1) {\n            stackValues.push(seriesData[j].rawData[i]);\n        }\n        stackData[i] = {\n            values: stackValues,\n            sum: sum(stackValues),\n            total: {\n                positive: sum(stackValues.filter((value) => value >= 0)),\n                negative: sum(stackValues.filter((value) => value < 0)),\n            },\n        };\n    }\n    return stackData;\n}\nfunction makeStackGroupData(seriesData) {\n    const stackData = {};\n    const stackGroupIds = [...new Set(seriesData.map(({ stackGroup }) => stackGroup))];\n    stackGroupIds.forEach((groupId) => {\n        const filtered = seriesData.filter(({ stackGroup }) => groupId === stackGroup);\n        stackData[groupId] = makeStackData(filtered);\n    });\n    return stackData;\n}\nfunction initializeStack(stackOption) {\n    if (!stackOption) {\n        return;\n    }\n    const defaultStackOption = {\n        type: 'normal',\n        connector: false,\n    };\n    if (isStackObject(stackOption)) {\n        return Object.assign(Object.assign({}, defaultStackOption), stackOption);\n    }\n    return defaultStackOption;\n}\nfunction isStackObject(stackOption) {\n    return isObject(stackOption);\n}\nfunction hasStackGrouped(seriesRawData) {\n    return seriesRawData.some((rawData) => rawData.hasOwnProperty('stackGroup'));\n}\nfunction getStackDataRangeValues(stackData) {\n    let values = [];\n    if (Array.isArray(stackData)) {\n        values = [0, ...getSumValues(stackData)];\n    }\n    else {\n        for (const groupId in stackData) {\n            if (Object.prototype.hasOwnProperty.call(stackData, groupId)) {\n                values = [0, ...values, ...getSumValues(stackData[groupId])];\n            }\n        }\n    }\n    return values;\n}\nfunction getSumValues(stackData) {\n    const positiveSum = stackData.map(({ total }) => total.positive);\n    const negativeSum = stackData.map(({ total }) => total.negative);\n    return [...negativeSum, ...positiveSum];\n}\nfunction getStackDataValues(stackData) {\n    if (!isGroupStack(stackData)) {\n        return stackData;\n    }\n    let stackDataValues = [];\n    if (isGroupStack(stackData)) {\n        Object.keys(stackData).forEach((groupId) => {\n            stackDataValues = [...stackDataValues, ...stackData[groupId]];\n        });\n    }\n    return stackDataValues;\n}\nfunction checkIfNegativeAndPositiveValues(stackData) {\n    return {\n        hasNegative: stackData.map(({ total }) => total.negative).some((total) => total < 0),\n        hasPositive: stackData.map(({ total }) => total.positive).some((total) => total >= 0),\n    };\n}\nfunction getScaleType(stackData, stackType, diverging) {\n    const { hasPositive, hasNegative } = checkIfNegativeAndPositiveValues(stackData);\n    if (stackType === 'percent') {\n        if (diverging) {\n            return 'divergingPercentStack';\n        }\n        if (hasNegative && hasPositive) {\n            return 'dualPercentStack';\n        }\n        if (!hasNegative && hasPositive) {\n            return 'percentStack';\n        }\n        if (hasNegative && !hasPositive) {\n            return 'minusPercentStack';\n        }\n    }\n}\nfunction initStackSeries(series, options) {\n    const stackSeries = {};\n    Object.keys(series).forEach((seriesName) => {\n        const chartType = seriesName;\n        const stackOption = pickStackOption(options);\n        if (stackOption) {\n            if (!stackSeries[chartType]) {\n                stackSeries[chartType] = {};\n            }\n            stackSeries[chartType].stack = initializeStack(stackOption);\n        }\n        else if (seriesName === 'radialBar') {\n            stackSeries[seriesName] = { stack: true };\n        }\n    });\n    return stackSeries;\n}\nconst stackSeriesData = {\n    name: 'stackSeriesData',\n    state: ({ series, options }) => ({\n        stackSeries: initStackSeries(series, options),\n    }),\n    action: {\n        setStackSeriesData({ state }) {\n            const { series, stackSeries, options } = state;\n            const stackOption = pickStackOption(options);\n            const newStackSeries = {};\n            Object.keys(series).forEach((seriesName) => {\n                var _a, _b;\n                const seriesData = series[seriesName];\n                const { data, seriesCount, seriesGroupCount } = seriesData;\n                const isRadialBar = seriesName === 'radialBar';\n                if (stackOption) {\n                    if (!stackSeries[seriesName]) {\n                        stackSeries[seriesName] = {};\n                    }\n                    stackSeries[seriesName].stack = initializeStack(stackOption);\n                }\n                else if (!isRadialBar) {\n                    stackSeries[seriesName] = null;\n                    delete stackSeries[seriesName];\n                }\n                const { stack } = stackSeries[seriesName] || {};\n                const diverging = !!((_a = options.series) === null || _a === void 0 ? void 0 : _a.diverging);\n                if (stack) {\n                    const stackData = hasStackGrouped(data) ? makeStackGroupData(data) : makeStackData(data);\n                    const stackType = (_b = stack.type, (_b !== null && _b !== void 0 ? _b : 'normal'));\n                    const dataRangeValues = getStackDataRangeValues(stackData);\n                    newStackSeries[seriesName] = {\n                        data,\n                        seriesCount,\n                        seriesGroupCount,\n                        stackData,\n                        dataRangeValues,\n                        scaleType: getScaleType(getStackDataValues(stackData), stackType, diverging),\n                    };\n                    state.stackSeries[seriesName].stackData = stackData;\n                }\n                extend(state.stackSeries, newStackSeries);\n            });\n        },\n    },\n    observe: {\n        updateStackSeriesData() {\n            this.dispatch('setStackSeriesData');\n        },\n    },\n};\nexport default stackSeriesData;\n"]},"metadata":{},"sourceType":"module"}