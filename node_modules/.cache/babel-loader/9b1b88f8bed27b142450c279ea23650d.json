{"ast":null,"code":"import { getFirstValidValue, includes, isNumber } from \"../helpers/utils\";\nimport { setSplineControlPoint } from \"../helpers/calculator\";\nimport { isSameArray } from \"../helpers/arrayUtil\";\nexport default class Component {\n  constructor({\n    store,\n    eventBus\n  }) {\n    this.name = 'Component';\n    this.type = 'component';\n    this.rect = {\n      x: 0,\n      y: 0,\n      height: 0,\n      width: 0\n    };\n    this.isShow = true;\n    this.store = store;\n    this.eventBus = eventBus;\n  }\n\n  update(delta) {\n    if (!this.drawModels) {\n      return;\n    }\n\n    if (Array.isArray(this.models)) {\n      this.updateModels(this.drawModels, this.models, delta);\n    } else {\n      Object.keys(this.models).forEach(type => {\n        const currentModels = this.drawModels[type];\n        const targetModels = this.models[type];\n        this.updateModels(currentModels, targetModels, delta);\n      });\n    }\n  }\n\n  initUpdate(delta) {\n    this.update(delta);\n  }\n\n  updateModels(currentModels, targetModels, delta) {\n    currentModels.forEach((current, index) => {\n      const target = targetModels[index];\n      Object.keys(current).forEach(key => {\n        var _a;\n\n        if (!current || !target) {\n          return;\n        }\n\n        if (key[0] !== '_') {\n          if (isNumber(current[key])) {\n            current[key] = current[key] + (target[key] - current[key]) * delta;\n          } else if (key === 'points') {\n            const matchedModel = this.getCurrentModelToMatchTargetModel(current[key], current[key], target[key]);\n            const newPoints = matchedModel.map((curPoint, idx) => {\n              const next = target[key][idx];\n\n              if (curPoint && next) {\n                const {\n                  x,\n                  y\n                } = curPoint;\n                const {\n                  x: nextX,\n                  y: nextY\n                } = next;\n                return Object.assign(Object.assign({}, next), {\n                  x: x + (nextX - x) * delta,\n                  y: y + (nextY - y) * delta\n                });\n              }\n\n              return next;\n            });\n\n            if ((_a = this.store.state.options.series) === null || _a === void 0 ? void 0 : _a.spline) {\n              setSplineControlPoint(newPoints);\n            }\n\n            current[key] = newPoints;\n          } else {\n            current[key] = target[key];\n          }\n        }\n      });\n    });\n  }\n\n  sync() {\n    if (!this.drawModels) {\n      return;\n    }\n\n    if (Array.isArray(this.models)) {\n      this.syncModels(this.drawModels, this.models);\n    } else {\n      Object.keys(this.models).forEach(type => {\n        const currentModels = this.drawModels[type];\n        const targetModels = this.models[type];\n        this.syncModels(currentModels, targetModels, type);\n      });\n    }\n  }\n\n  getCurrentModelToMatchTargetModel(models, currentModels, targetModels) {\n    var _a;\n\n    if ((_a = getFirstValidValue(targetModels)) === null || _a === void 0 ? void 0 : _a.name) {\n      const modelNames = [...new Set(models.map(({\n        name\n      }) => name))];\n      const targetNames = [...new Set(targetModels.map(({\n        name\n      }) => name))];\n      const same = isSameArray(modelNames, targetNames);\n\n      if (!same) {\n        return this.getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames);\n      }\n    }\n\n    const currentLength = currentModels.length;\n    const targetLength = targetModels.length;\n\n    if (currentLength < targetLength) {\n      return [...currentModels, ...targetModels.slice(currentLength, targetLength)];\n    }\n\n    if (currentLength > targetLength) {\n      return currentModels.slice(0, targetLength);\n    }\n\n    return models;\n  }\n\n  getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames) {\n    const currentLength = currentModels.length;\n    const targetLength = targetModels.length;\n\n    if (currentLength > targetLength) {\n      const newModels = models.filter(({\n        name\n      }) => includes(targetNames, name));\n      return newModels.length !== targetModels.length ? targetModels : newModels;\n    }\n\n    if (currentLength < targetLength) {\n      const notIncludedModels = targetModels.reduce((acc, cur, idx) => {\n        const notIncluded = !includes(modelNames, cur.name);\n        return notIncluded ? {\n          models: [...acc.models, cur],\n          modelIdx: [...acc.modelIdx, idx]\n        } : acc;\n      }, {\n        models: [],\n        modelIdx: []\n      });\n\n      if (models.length + notIncludedModels.models.length === targetLength) {\n        const newModels = [...models];\n        notIncludedModels.models.forEach((model, idx) => {\n          newModels.splice(notIncludedModels.modelIdx[idx], 0, model);\n        });\n        return newModels;\n      }\n\n      return targetModels;\n    }\n\n    return models;\n  }\n\n  syncModels(currentModels, targetModels, type) {\n    const drawModels = type ? this.drawModels[type] : this.drawModels;\n    const model = this.getCurrentModelToMatchTargetModel(drawModels, currentModels, targetModels);\n\n    if (type) {\n      this.drawModels[type] = model;\n    } else {\n      this.drawModels = model;\n    }\n  }\n\n  getSelectableOption(options) {\n    var _a, _b, _c;\n\n    return _c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.selectable, _c !== null && _c !== void 0 ? _c : false;\n  }\n\n  renderDataLabels(data, name) {\n    setTimeout(() => {\n      this.eventBus.emit('renderDataLabels', {\n        data,\n        name: name !== null && name !== void 0 ? name : this.name\n      });\n    }, 0);\n  }\n\n  draw(painter) {\n    const models = this.drawModels ? this.drawModels : this.models;\n\n    if (Array.isArray(models)) {\n      painter.paintForEach(models);\n    } else if (models) {\n      Object.keys(models).forEach(item => {\n        painter.paintForEach(models[item]);\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/component.js"],"names":["getFirstValidValue","includes","isNumber","setSplineControlPoint","isSameArray","Component","constructor","store","eventBus","name","type","rect","x","y","height","width","isShow","update","delta","drawModels","Array","isArray","models","updateModels","Object","keys","forEach","currentModels","targetModels","initUpdate","current","index","target","key","_a","matchedModel","getCurrentModelToMatchTargetModel","newPoints","map","curPoint","idx","next","nextX","nextY","assign","state","options","series","spline","sync","syncModels","modelNames","Set","targetNames","same","getCurrentModelWithDifferentModel","currentLength","length","targetLength","slice","newModels","filter","notIncludedModels","reduce","acc","cur","notIncluded","modelIdx","model","splice","getSelectableOption","_b","_c","selectable","renderDataLabels","data","setTimeout","emit","draw","painter","paintForEach","item"],"mappings":"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","sourcesContent":["import { getFirstValidValue, includes, isNumber } from \"../helpers/utils\";\nimport { setSplineControlPoint } from \"../helpers/calculator\";\nimport { isSameArray } from \"../helpers/arrayUtil\";\nexport default class Component {\n    constructor({ store, eventBus }) {\n        this.name = 'Component';\n        this.type = 'component';\n        this.rect = {\n            x: 0,\n            y: 0,\n            height: 0,\n            width: 0,\n        };\n        this.isShow = true;\n        this.store = store;\n        this.eventBus = eventBus;\n    }\n    update(delta) {\n        if (!this.drawModels) {\n            return;\n        }\n        if (Array.isArray(this.models)) {\n            this.updateModels(this.drawModels, this.models, delta);\n        }\n        else {\n            Object.keys(this.models).forEach((type) => {\n                const currentModels = this.drawModels[type];\n                const targetModels = this.models[type];\n                this.updateModels(currentModels, targetModels, delta);\n            });\n        }\n    }\n    initUpdate(delta) {\n        this.update(delta);\n    }\n    updateModels(currentModels, targetModels, delta) {\n        currentModels.forEach((current, index) => {\n            const target = targetModels[index];\n            Object.keys(current).forEach((key) => {\n                var _a;\n                if (!current || !target) {\n                    return;\n                }\n                if (key[0] !== '_') {\n                    if (isNumber(current[key])) {\n                        current[key] = current[key] + (target[key] - current[key]) * delta;\n                    }\n                    else if (key === 'points') {\n                        const matchedModel = this.getCurrentModelToMatchTargetModel(current[key], current[key], target[key]);\n                        const newPoints = matchedModel.map((curPoint, idx) => {\n                            const next = target[key][idx];\n                            if (curPoint && next) {\n                                const { x, y } = curPoint;\n                                const { x: nextX, y: nextY } = next;\n                                return Object.assign(Object.assign({}, next), { x: x + (nextX - x) * delta, y: y + (nextY - y) * delta });\n                            }\n                            return next;\n                        });\n                        if ((_a = this.store.state.options.series) === null || _a === void 0 ? void 0 : _a.spline) {\n                            setSplineControlPoint(newPoints);\n                        }\n                        current[key] = newPoints;\n                    }\n                    else {\n                        current[key] = target[key];\n                    }\n                }\n            });\n        });\n    }\n    sync() {\n        if (!this.drawModels) {\n            return;\n        }\n        if (Array.isArray(this.models)) {\n            this.syncModels(this.drawModels, this.models);\n        }\n        else {\n            Object.keys(this.models).forEach((type) => {\n                const currentModels = this.drawModels[type];\n                const targetModels = this.models[type];\n                this.syncModels(currentModels, targetModels, type);\n            });\n        }\n    }\n    getCurrentModelToMatchTargetModel(models, currentModels, targetModels) {\n        var _a;\n        if ((_a = getFirstValidValue(targetModels)) === null || _a === void 0 ? void 0 : _a.name) {\n            const modelNames = [...new Set(models.map(({ name }) => name))];\n            const targetNames = [...new Set(targetModels.map(({ name }) => name))];\n            const same = isSameArray(modelNames, targetNames);\n            if (!same) {\n                return this.getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames);\n            }\n        }\n        const currentLength = currentModels.length;\n        const targetLength = targetModels.length;\n        if (currentLength < targetLength) {\n            return [...currentModels, ...targetModels.slice(currentLength, targetLength)];\n        }\n        if (currentLength > targetLength) {\n            return currentModels.slice(0, targetLength);\n        }\n        return models;\n    }\n    getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames) {\n        const currentLength = currentModels.length;\n        const targetLength = targetModels.length;\n        if (currentLength > targetLength) {\n            const newModels = models.filter(({ name }) => includes(targetNames, name));\n            return newModels.length !== targetModels.length ? targetModels : newModels;\n        }\n        if (currentLength < targetLength) {\n            const notIncludedModels = targetModels.reduce((acc, cur, idx) => {\n                const notIncluded = !includes(modelNames, cur.name);\n                return notIncluded\n                    ? {\n                        models: [...acc.models, cur],\n                        modelIdx: [...acc.modelIdx, idx],\n                    }\n                    : acc;\n            }, { models: [], modelIdx: [] });\n            if (models.length + notIncludedModels.models.length === targetLength) {\n                const newModels = [...models];\n                notIncludedModels.models.forEach((model, idx) => {\n                    newModels.splice(notIncludedModels.modelIdx[idx], 0, model);\n                });\n                return newModels;\n            }\n            return targetModels;\n        }\n        return models;\n    }\n    syncModels(currentModels, targetModels, type) {\n        const drawModels = type ? this.drawModels[type] : this.drawModels;\n        const model = this.getCurrentModelToMatchTargetModel(drawModels, currentModels, targetModels);\n        if (type) {\n            this.drawModels[type] = model;\n        }\n        else {\n            this.drawModels = model;\n        }\n    }\n    getSelectableOption(options) {\n        var _a, _b, _c;\n        return _c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.selectable, (_c !== null && _c !== void 0 ? _c : false);\n    }\n    renderDataLabels(data, name) {\n        setTimeout(() => {\n            this.eventBus.emit('renderDataLabels', { data, name: (name !== null && name !== void 0 ? name : this.name) });\n        }, 0);\n    }\n    draw(painter) {\n        const models = this.drawModels ? this.drawModels : this.models;\n        if (Array.isArray(models)) {\n            painter.paintForEach(models);\n        }\n        else if (models) {\n            Object.keys(models).forEach((item) => {\n                painter.paintForEach(models[item]);\n            });\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}