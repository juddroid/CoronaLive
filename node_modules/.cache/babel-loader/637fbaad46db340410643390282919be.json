{"ast":null,"code":"import { setLineDash, fillStyle, strokeWithOptions } from \"../helpers/style\";\nimport { isNull } from \"../helpers/utils\";\nexport function linePoints(ctx, pointsModel) {\n  const {\n    color: strokeStyle,\n    lineWidth,\n    points,\n    dashSegments = []\n  } = pointsModel;\n  ctx.lineCap = 'round';\n  ctx.beginPath();\n\n  if (dashSegments) {\n    setLineDash(ctx, dashSegments);\n  }\n\n  let start = false;\n  points.forEach((point, idx) => {\n    var _a, _b;\n\n    if (isNull(point)) {\n      start = false;\n      return;\n    }\n\n    if (!start) {\n      ctx.moveTo(point.x, point.y);\n      start = true;\n      return;\n    }\n\n    if (point.controlPoint && ((_b = (_a = points[idx - 1]) === null || _a === void 0 ? void 0 : _a.controlPoint) === null || _b === void 0 ? void 0 : _b.next)) {\n      const {\n        x: prevX,\n        y: prevY\n      } = points[idx - 1].controlPoint.next;\n      const {\n        controlPoint,\n        x,\n        y\n      } = point;\n      ctx.bezierCurveTo(prevX, prevY, controlPoint.prev.x, controlPoint.prev.y, x, y);\n    } else {\n      ctx.lineTo(point.x, point.y);\n    }\n  });\n  strokeWithOptions(ctx, {\n    lineWidth,\n    strokeStyle\n  });\n  ctx.closePath();\n  setLineDash(ctx, []);\n}\nexport function areaPoints(ctx, areaPointsModel) {\n  const {\n    fillColor\n  } = areaPointsModel;\n  ctx.beginPath();\n  linePoints(ctx, areaPointsModel);\n  fillStyle(ctx, fillColor);\n  ctx.closePath();\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js"],"names":["setLineDash","fillStyle","strokeWithOptions","isNull","linePoints","ctx","pointsModel","color","strokeStyle","lineWidth","points","dashSegments","lineCap","beginPath","start","forEach","point","idx","_a","_b","moveTo","x","y","controlPoint","next","prevX","prevY","bezierCurveTo","prev","lineTo","closePath","areaPoints","areaPointsModel","fillColor"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,iBAAjC,QAA0D,kBAA1D;AACA,SAASC,MAAT,QAAuB,kBAAvB;AACA,OAAO,SAASC,UAAT,CAAoBC,GAApB,EAAyBC,WAAzB,EAAsC;AACzC,QAAM;AAAEC,IAAAA,KAAK,EAAEC,WAAT;AAAsBC,IAAAA,SAAtB;AAAiCC,IAAAA,MAAjC;AAAyCC,IAAAA,YAAY,GAAG;AAAxD,MAA+DL,WAArE;AACAD,EAAAA,GAAG,CAACO,OAAJ,GAAc,OAAd;AACAP,EAAAA,GAAG,CAACQ,SAAJ;;AACA,MAAIF,YAAJ,EAAkB;AACdX,IAAAA,WAAW,CAACK,GAAD,EAAMM,YAAN,CAAX;AACH;;AACD,MAAIG,KAAK,GAAG,KAAZ;AACAJ,EAAAA,MAAM,CAACK,OAAP,CAAe,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAC3B,QAAIC,EAAJ,EAAQC,EAAR;;AACA,QAAIhB,MAAM,CAACa,KAAD,CAAV,EAAmB;AACfF,MAAAA,KAAK,GAAG,KAAR;AACA;AACH;;AACD,QAAI,CAACA,KAAL,EAAY;AACRT,MAAAA,GAAG,CAACe,MAAJ,CAAWJ,KAAK,CAACK,CAAjB,EAAoBL,KAAK,CAACM,CAA1B;AACAR,MAAAA,KAAK,GAAG,IAAR;AACA;AACH;;AACD,QAAIE,KAAK,CAACO,YAAN,KAAuB,CAACJ,EAAE,GAAG,CAACD,EAAE,GAAGR,MAAM,CAACO,GAAG,GAAG,CAAP,CAAZ,MAA2B,IAA3B,IAAmCC,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACK,YAArE,MAAuF,IAAvF,IAA+FJ,EAAE,KAAK,KAAK,CAA3G,GAA+G,KAAK,CAApH,GAAwHA,EAAE,CAACK,IAAlJ,CAAJ,EAA6J;AACzJ,YAAM;AAAEH,QAAAA,CAAC,EAAEI,KAAL;AAAYH,QAAAA,CAAC,EAAEI;AAAf,UAAyBhB,MAAM,CAACO,GAAG,GAAG,CAAP,CAAN,CAAgBM,YAAhB,CAA6BC,IAA5D;AACA,YAAM;AAAED,QAAAA,YAAF;AAAgBF,QAAAA,CAAhB;AAAmBC,QAAAA;AAAnB,UAAyBN,KAA/B;AACAX,MAAAA,GAAG,CAACsB,aAAJ,CAAkBF,KAAlB,EAAyBC,KAAzB,EAAgCH,YAAY,CAACK,IAAb,CAAkBP,CAAlD,EAAqDE,YAAY,CAACK,IAAb,CAAkBN,CAAvE,EAA0ED,CAA1E,EAA6EC,CAA7E;AACH,KAJD,MAKK;AACDjB,MAAAA,GAAG,CAACwB,MAAJ,CAAWb,KAAK,CAACK,CAAjB,EAAoBL,KAAK,CAACM,CAA1B;AACH;AACJ,GAnBD;AAoBApB,EAAAA,iBAAiB,CAACG,GAAD,EAAM;AAAEI,IAAAA,SAAF;AAAaD,IAAAA;AAAb,GAAN,CAAjB;AACAH,EAAAA,GAAG,CAACyB,SAAJ;AACA9B,EAAAA,WAAW,CAACK,GAAD,EAAM,EAAN,CAAX;AACH;AACD,OAAO,SAAS0B,UAAT,CAAoB1B,GAApB,EAAyB2B,eAAzB,EAA0C;AAC7C,QAAM;AAAEC,IAAAA;AAAF,MAAgBD,eAAtB;AACA3B,EAAAA,GAAG,CAACQ,SAAJ;AACAT,EAAAA,UAAU,CAACC,GAAD,EAAM2B,eAAN,CAAV;AACA/B,EAAAA,SAAS,CAACI,GAAD,EAAM4B,SAAN,CAAT;AACA5B,EAAAA,GAAG,CAACyB,SAAJ;AACH","sourcesContent":["import { setLineDash, fillStyle, strokeWithOptions } from \"../helpers/style\";\nimport { isNull } from \"../helpers/utils\";\nexport function linePoints(ctx, pointsModel) {\n    const { color: strokeStyle, lineWidth, points, dashSegments = [] } = pointsModel;\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    if (dashSegments) {\n        setLineDash(ctx, dashSegments);\n    }\n    let start = false;\n    points.forEach((point, idx) => {\n        var _a, _b;\n        if (isNull(point)) {\n            start = false;\n            return;\n        }\n        if (!start) {\n            ctx.moveTo(point.x, point.y);\n            start = true;\n            return;\n        }\n        if (point.controlPoint && ((_b = (_a = points[idx - 1]) === null || _a === void 0 ? void 0 : _a.controlPoint) === null || _b === void 0 ? void 0 : _b.next)) {\n            const { x: prevX, y: prevY } = points[idx - 1].controlPoint.next;\n            const { controlPoint, x, y } = point;\n            ctx.bezierCurveTo(prevX, prevY, controlPoint.prev.x, controlPoint.prev.y, x, y);\n        }\n        else {\n            ctx.lineTo(point.x, point.y);\n        }\n    });\n    strokeWithOptions(ctx, { lineWidth, strokeStyle });\n    ctx.closePath();\n    setLineDash(ctx, []);\n}\nexport function areaPoints(ctx, areaPointsModel) {\n    const { fillColor } = areaPointsModel;\n    ctx.beginPath();\n    linePoints(ctx, areaPointsModel);\n    fillStyle(ctx, fillColor);\n    ctx.closePath();\n}\n"]},"metadata":{},"sourceType":"module"}