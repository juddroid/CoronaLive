{"ast":null,"code":"import { isUndefined, sum, deepMergedCopy, range, isNumber } from \"../helpers/utils\";\nimport { getLegendItemHeight, LEGEND_CHECKBOX_SIZE, LEGEND_ICON_SIZE, LEGEND_ITEM_MARGIN_X, LEGEND_MARGIN_X } from \"../brushes/legend\";\nimport { getTextWidth } from \"../helpers/calculator\";\nimport { isVerticalAlign, padding } from \"./layout\";\nimport { SPECTRUM_LEGEND_LABEL_HEIGHT, spectrumLegendBar, spectrumLegendTooltip } from \"../brushes/spectrumLegend\";\nimport { hasNestedPieSeries } from \"../helpers/pieSeries\";\nimport { extend } from \"./store\";\nimport { getTitleFontString } from \"../helpers/style\";\nimport { makeDefaultTheme } from \"../helpers/theme\";\nimport { isNoData } from \"../helpers/validation\";\nimport { getIconType, getLegendAlign, showCheckbox, showCircleLegend, showLegend } from \"../helpers/legend\";\nconst INITIAL_LEGEND_WIDTH = 100;\nconst INITIAL_CIRCLE_LEGEND_WIDTH = 150;\nconst COMPONENT_HEIGHT_EXCEPT_Y_AXIS = 100;\nconst ELLIPSIS_DOT_TEXT = '...';\nconst WIDEST_TEXT = 'W'; // The widest text width in Arial font.\n\nconst NUMBER_OF_BOTH_SIDES = 2;\n\nfunction recalculateLegendWhenHeightOverflows(params, legendHeight) {\n  const {\n    legendWidths,\n    itemHeight\n  } = params;\n  const totalHeight = legendWidths.length * itemHeight;\n  const columnCount = Math.ceil(totalHeight / legendHeight);\n  const rowCount = legendWidths.length / columnCount;\n  let legendWidth = 0;\n  range(0, columnCount).forEach(count => {\n    legendWidth += Math.max(...legendWidths.slice(count * rowCount, (count + 1) * rowCount));\n  });\n  legendWidth += LEGEND_ITEM_MARGIN_X * (columnCount - 1);\n  return {\n    legendWidth,\n    legendHeight: rowCount * itemHeight + padding.Y,\n    columnCount,\n    rowCount\n  };\n}\n\nfunction recalculateLegendWhenWidthOverflows(params, prevLegendWidth) {\n  const {\n    legendWidths,\n    itemHeight\n  } = params;\n  let columnCount = 0;\n  let legendWidth = 0;\n  const {\n    rowCount\n  } = legendWidths.reduce((acc, width) => {\n    const widthWithMargin = LEGEND_ITEM_MARGIN_X + width;\n\n    if (acc.totalWidth + width > prevLegendWidth) {\n      acc.totalWidth = widthWithMargin;\n      acc.rowCount += 1;\n      acc.columnCount = 1;\n      columnCount = Math.max(columnCount, acc.columnCount);\n    } else {\n      acc.totalWidth += widthWithMargin;\n      acc.columnCount += 1;\n    }\n\n    legendWidth = Math.max(legendWidth, acc.totalWidth);\n    return acc;\n  }, {\n    totalWidth: 0,\n    rowCount: 1,\n    columnCount: 0\n  });\n  return {\n    legendHeight: itemHeight * rowCount,\n    rowCount,\n    columnCount,\n    legendWidth\n  };\n}\n\nfunction calculateLegendSize(params) {\n  if (!params.visible) {\n    return {\n      legendWidth: 0,\n      legendHeight: 0,\n      rowCount: 0,\n      columnCount: 0\n    };\n  }\n\n  const {\n    chart,\n    verticalAlign,\n    legendWidths\n  } = params;\n  const {\n    legendWidth,\n    isOverflow: widthOverflow\n  } = calculateLegendWidth(params);\n  const {\n    legendHeight,\n    isOverflow: heightOverflow\n  } = calculateLegendHeight(params);\n  const columnCount = verticalAlign ? legendWidths.length : 1;\n  const rowCount = verticalAlign ? Math.ceil(legendWidth / chart.width) : legendWidths.length;\n\n  if (widthOverflow) {\n    return recalculateLegendWhenWidthOverflows(params, legendWidth / rowCount);\n  }\n\n  if (heightOverflow) {\n    return recalculateLegendWhenHeightOverflows(params, legendHeight);\n  }\n\n  return {\n    legendWidth,\n    legendHeight,\n    columnCount,\n    rowCount\n  };\n}\n\nfunction calculateLegendHeight(params) {\n  const {\n    verticalAlign,\n    itemHeight,\n    legendWidths\n  } = params;\n  const {\n    height: chartHeight\n  } = getDefaultLegendSize(params);\n  let legendHeight;\n  let isOverflow = false;\n\n  if (verticalAlign) {\n    legendHeight = chartHeight;\n  } else {\n    const totalHeight = legendWidths.length * itemHeight;\n    isOverflow = chartHeight < totalHeight;\n    legendHeight = isOverflow ? chartHeight : totalHeight;\n  }\n\n  return {\n    legendHeight,\n    isOverflow\n  };\n}\n\nfunction getSpectrumLegendWidth(legendWidths, chartWidth, verticalAlign) {\n  if (verticalAlign) {\n    const labelAreaWidth = sum(legendWidths);\n    return Math.max(chartWidth / 4, labelAreaWidth);\n  }\n\n  const spectrumAreaWidth = (spectrumLegendTooltip.PADDING + spectrumLegendBar.PADDING + padding.X) * NUMBER_OF_BOTH_SIDES + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendBar.HEIGHT;\n  return Math.max(...legendWidths) + spectrumAreaWidth;\n}\n\nfunction getSpectrumLegendHeight(itemHeight, chartHeight, verticalAlign) {\n  return verticalAlign ? SPECTRUM_LEGEND_LABEL_HEIGHT + spectrumLegendBar.PADDING * NUMBER_OF_BOTH_SIDES + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendTooltip.HEIGHT + padding.Y : chartHeight * 3 / 4;\n}\n\nfunction getNormalLegendWidth(params) {\n  const {\n    initialWidth,\n    legendWidths,\n    checkbox,\n    verticalAlign\n  } = params;\n  let isOverflow = false;\n  let legendWidth;\n\n  if (verticalAlign) {\n    const {\n      width: chartWidth\n    } = getDefaultLegendSize(params);\n    const totalWidth = sum(legendWidths) + LEGEND_ITEM_MARGIN_X * (legendWidths.length - 1);\n    isOverflow = totalWidth > chartWidth;\n    legendWidth = totalWidth;\n  } else {\n    const labelAreaWidth = Math.max(...legendWidths);\n    legendWidth = (checkbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X + Math.max(labelAreaWidth, initialWidth);\n  }\n\n  return {\n    legendWidth,\n    isOverflow\n  };\n}\n\nfunction calculateLegendWidth(params) {\n  var _a, _b;\n\n  const {\n    options,\n    visible\n  } = params;\n  const legendOptions = (_a = options) === null || _a === void 0 ? void 0 : _a.legend;\n\n  if (!visible) {\n    return {\n      legendWidth: 0,\n      isOverflow: false\n    };\n  }\n\n  if ((_b = legendOptions) === null || _b === void 0 ? void 0 : _b.width) {\n    return {\n      legendWidth: legendOptions.width,\n      isOverflow: false\n    };\n  }\n\n  return getNormalLegendWidth(params);\n}\n\nfunction getDefaultLegendSize(params) {\n  const {\n    verticalAlign,\n    chart,\n    itemHeight,\n    initialWidth,\n    circleLegendVisible\n  } = params;\n  const restAreaHeight = COMPONENT_HEIGHT_EXCEPT_Y_AXIS + (circleLegendVisible ? INITIAL_CIRCLE_LEGEND_WIDTH : 0); // rest area temporary value (yAxisTitle.height + xAxis.height + circleLegend.height)\n\n  return verticalAlign ? {\n    width: chart.width - padding.X * NUMBER_OF_BOTH_SIDES,\n    height: itemHeight\n  } : {\n    width: initialWidth,\n    height: chart.height - restAreaHeight\n  };\n}\n\nfunction getNestedPieLegendLabelsInfo(series, legendInfo) {\n  const result = [];\n  const maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);\n  series.pie.forEach(({\n    data\n  }) => {\n    data.forEach(({\n      name,\n      parentName,\n      visible\n    }) => {\n      if (!parentName) {\n        const {\n          width,\n          viewLabel\n        } = getViewLabelInfo(legendInfo, name, maxTextLengthWithEllipsis);\n        result.push({\n          label: name,\n          type: 'pie',\n          checked: visible !== null && visible !== void 0 ? visible : true,\n          viewLabel,\n          width\n        });\n      }\n    });\n  });\n  return result;\n}\n\nfunction getMaxTextLengthWithEllipsis(legendInfo) {\n  var _a, _b;\n\n  const {\n    legendOptions,\n    font,\n    checkboxVisible\n  } = legendInfo;\n  const width = (_b = (_a = legendOptions) === null || _a === void 0 ? void 0 : _a.item) === null || _b === void 0 ? void 0 : _b.width;\n\n  if (isUndefined(width)) {\n    return;\n  }\n\n  const checkboxWidth = checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0;\n  const iconWidth = LEGEND_ICON_SIZE + LEGEND_MARGIN_X;\n  const ellipsisDotWidth = getTextWidth(ELLIPSIS_DOT_TEXT, font);\n  const widestTextWidth = getTextWidth(WIDEST_TEXT, font);\n  const maxTextCount = Math.floor((width - ellipsisDotWidth - checkboxWidth - iconWidth) / widestTextWidth);\n  return maxTextCount > 0 ? maxTextCount : 0;\n}\n\nfunction getViewLabelInfo(legendInfo, label, maxTextLength) {\n  var _a, _b;\n\n  const {\n    checkboxVisible,\n    useSpectrumLegend,\n    font,\n    legendOptions\n  } = legendInfo;\n  let viewLabel = label;\n  const itemWidth = (_b = (_a = legendOptions) === null || _a === void 0 ? void 0 : _a.item) === null || _b === void 0 ? void 0 : _b.width;\n  const itemWidthWithFullText = getItemWidth(viewLabel, checkboxVisible, useSpectrumLegend, font);\n\n  if (isNumber(itemWidth) && isNumber(maxTextLength) && itemWidth < itemWidthWithFullText) {\n    viewLabel = `${label.slice(0, maxTextLength)}${ELLIPSIS_DOT_TEXT}`;\n  }\n\n  return {\n    viewLabel,\n    width: itemWidth !== null && itemWidth !== void 0 ? itemWidth : itemWidthWithFullText\n  };\n}\n\nfunction getLegendLabelsInfo(series, legendInfo) {\n  const maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);\n  return Object.keys(series).flatMap(type => series[type].map(({\n    name,\n    colorValue,\n    visible\n  }) => {\n    const label = colorValue ? colorValue : name;\n    const {\n      width,\n      viewLabel\n    } = getViewLabelInfo(legendInfo, label, maxTextLengthWithEllipsis);\n    return {\n      label,\n      type,\n      checked: visible !== null && visible !== void 0 ? visible : true,\n      viewLabel,\n      width\n    };\n  }));\n}\n\nfunction getItemWidth(label, checkboxVisible, useSpectrumLegend, font) {\n  return (useSpectrumLegend ? 0 : (checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X) + getTextWidth(label, font);\n}\n\nfunction getLegendDataAppliedTheme(data, series) {\n  const colors = Object.values(series).reduce((acc, cur) => cur && cur.colors ? [...acc, ...cur.colors] : acc, []);\n  return data.map((datum, idx) => Object.assign(Object.assign({}, datum), {\n    color: colors[idx]\n  }));\n}\n\nfunction getLegendState(options, series) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n  const useSpectrumLegend = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.useColorValue, _c !== null && _c !== void 0 ? _c : !!series.heatmap);\n  const useScatterChartIcon = !!((_d = series) === null || _d === void 0 ? void 0 : _d.scatter);\n  const checkboxVisible = useSpectrumLegend ? false : showCheckbox(options);\n  const defaultTheme = makeDefaultTheme((_g = (_f = (_e = options) === null || _e === void 0 ? void 0 : _e.theme) === null || _f === void 0 ? void 0 : _f.chart) === null || _g === void 0 ? void 0 : _g.fontFamily);\n  const font = getTitleFontString(deepMergedCopy(defaultTheme.legend.label, Object.assign({}, (_j = (_h = options.theme) === null || _h === void 0 ? void 0 : _h.legend) === null || _j === void 0 ? void 0 : _j.label)));\n  const legendInfo = {\n    checkboxVisible,\n    font,\n    useSpectrumLegend,\n    legendOptions: options.legend\n  };\n  const legendLabelsInfo = hasNestedPieSeries(series) ? getNestedPieLegendLabelsInfo(series, legendInfo) : getLegendLabelsInfo(series, legendInfo);\n  const data = legendLabelsInfo.map(({\n    label,\n    type,\n    checked,\n    width,\n    viewLabel\n  }) => ({\n    label,\n    active: true,\n    checked,\n    width,\n    iconType: getIconType(type),\n    chartType: type,\n    rowIndex: 0,\n    columnIndex: 0,\n    viewLabel\n  }));\n  return {\n    useSpectrumLegend,\n    useScatterChartIcon,\n    data\n  };\n}\n\nfunction getNextColumnRowIndex(params) {\n  const {\n    verticalAlign,\n    columnCount,\n    rowCount,\n    legendCount\n  } = params;\n  let {\n    rowIndex,\n    columnIndex\n  } = params;\n\n  if (verticalAlign) {\n    const maxLen = legendCount / rowCount;\n\n    if (maxLen - 1 > columnIndex) {\n      columnIndex += 1;\n    } else {\n      rowIndex += 1;\n      columnIndex = 0;\n    }\n  } else {\n    const maxLen = legendCount / columnCount;\n\n    if (maxLen - 1 > rowIndex) {\n      rowIndex += 1;\n    } else {\n      columnIndex += 1;\n      rowIndex = 0;\n    }\n  }\n\n  return [rowIndex, columnIndex];\n}\n\nfunction setIndexToLegendData(legendData, rowCount, columnCount, legendCount, verticalAlign) {\n  let columnIndex = 0;\n  let rowIndex = 0;\n  legendData.forEach(datum => {\n    datum.rowIndex = rowIndex;\n    datum.columnIndex = columnIndex;\n    [rowIndex, columnIndex] = getNextColumnRowIndex({\n      rowCount,\n      columnCount,\n      verticalAlign,\n      legendCount,\n      rowIndex,\n      columnIndex\n    });\n  });\n}\n\nconst legend = {\n  name: 'legend',\n  state: ({\n    options,\n    series\n  }) => {\n    return {\n      legend: getLegendState(options, series),\n      circleLegend: {}\n    };\n  },\n  action: {\n    initLegendState({\n      state,\n      initStoreState\n    }) {\n      extend(state.legend, getLegendState(initStoreState.options, initStoreState.series));\n    },\n\n    setLegendLayout({\n      state\n    }) {\n      if (state.legend.useSpectrumLegend) {\n        this.dispatch('setSpectrumLegendLayout');\n      } else {\n        this.dispatch('setNormalLegendLayout');\n      }\n    },\n\n    setSpectrumLegendLayout({\n      state\n    }) {\n      const {\n        legend: {\n          data: legendData\n        },\n        series,\n        options,\n        chart,\n        theme\n      } = state;\n      const align = getLegendAlign(options);\n      const visible = showLegend(options, series);\n      const verticalAlign = isVerticalAlign(align);\n      const legendWidths = legendData.map(({\n        width\n      }) => width);\n      const itemHeight = getLegendItemHeight(theme.legend.label.fontSize);\n      const width = getSpectrumLegendWidth(legendWidths, chart.width, verticalAlign);\n      const height = getSpectrumLegendHeight(itemHeight, chart.height, verticalAlign);\n      extend(state.legend, {\n        visible,\n        align,\n        width,\n        height\n      });\n    },\n\n    setNormalLegendLayout({\n      state,\n      initStoreState\n    }) {\n      const {\n        legend: {\n          data: legendData\n        },\n        series,\n        options,\n        chart,\n        theme\n      } = state;\n      const align = getLegendAlign(options);\n      const visible = showLegend(options, series);\n      const checkbox = showCheckbox(options);\n      const initialWidth = Math.min(chart.width / 5, INITIAL_LEGEND_WIDTH);\n      const verticalAlign = isVerticalAlign(align);\n      const isNestedPieChart = hasNestedPieSeries(initStoreState.series);\n      const isScatterChart = !!series.scatter;\n      const isBubbleChart = !!series.bubble;\n      const circleLegendVisible = isBubbleChart ? showCircleLegend(options) : false;\n      const legendWidths = legendData.map(({\n        width\n      }) => width);\n      const itemHeight = getLegendItemHeight(theme.legend.label.fontSize);\n      const {\n        legendWidth,\n        legendHeight,\n        rowCount,\n        columnCount\n      } = calculateLegendSize({\n        initialWidth,\n        legendWidths,\n        options,\n        verticalAlign,\n        visible,\n        checkbox,\n        chart,\n        itemHeight,\n        circleLegendVisible\n      });\n      setIndexToLegendData(legendData, rowCount, columnCount, legendWidths.length, verticalAlign);\n      extend(state.legend, {\n        visible,\n        align,\n        showCheckbox: checkbox,\n        width: legendWidth,\n        height: legendHeight\n      });\n\n      if (isBubbleChart && circleLegendVisible) {\n        this.dispatch('updateCircleLegendLayout', {\n          legendWidth\n        });\n      }\n\n      if (!isNestedPieChart && !isNoData(series)) {\n        this.dispatch('updateLegendColor');\n      }\n\n      if (isScatterChart) {\n        this.dispatch('updateLegendIcon');\n      }\n    },\n\n    updateCircleLegendLayout({\n      state\n    }, {\n      legendWidth\n    }) {\n      const width = legendWidth === 0 ? INITIAL_CIRCLE_LEGEND_WIDTH : Math.min(legendWidth, INITIAL_CIRCLE_LEGEND_WIDTH);\n      const radius = Math.max((width - LEGEND_MARGIN_X) / 2, 0);\n      extend(state.circleLegend, {\n        visible: true,\n        width,\n        radius\n      });\n    },\n\n    setLegendActiveState({\n      state\n    }, {\n      name,\n      active\n    }) {\n      const {\n        data\n      } = state.legend;\n      const model = data.find(({\n        label\n      }) => label === name);\n      model.active = active;\n      this.notify(state, 'legend');\n    },\n\n    setAllLegendActiveState({\n      state\n    }, active) {\n      state.legend.data.forEach(datum => {\n        datum.active = active;\n      });\n      this.notify(state, 'legend');\n    },\n\n    setLegendCheckedState({\n      state\n    }, {\n      name,\n      checked\n    }) {\n      const model = state.legend.data.find(({\n        label\n      }) => label === name);\n      model.checked = checked;\n      this.notify(state, 'legend');\n    },\n\n    updateLegendColor({\n      state\n    }) {\n      const {\n        legend: legendData,\n        series\n      } = state;\n      const data = getLegendDataAppliedTheme(legendData.data, series);\n      extend(state.legend, {\n        data\n      });\n    },\n\n    updateLegendIcon({\n      state\n    }) {\n      const {\n        legend: legendData,\n        series\n      } = state;\n      const data = legendData.data.reduce((acc, cur) => {\n        var _a;\n\n        if (cur.chartType === 'scatter' && ((_a = series.scatter) === null || _a === void 0 ? void 0 : _a.data)) {\n          const model = series.scatter.data.find(({\n            name\n          }) => name === cur.label);\n          const iconType = model ? model.iconType : cur.iconType;\n          return [...acc, Object.assign(Object.assign({}, cur), {\n            iconType\n          })];\n        }\n\n        return [...acc, cur];\n      }, []);\n      extend(state.legend, {\n        data\n      });\n    },\n\n    updateNestedPieChartLegend({\n      state\n    }) {\n      const {\n        legend: legendData,\n        nestedPieSeries\n      } = state;\n      extend(state.legend, {\n        data: getLegendDataAppliedTheme(legendData.data, nestedPieSeries)\n      });\n    }\n\n  },\n  observe: {\n    updateLegendLayout() {\n      this.dispatch('setLegendLayout');\n    }\n\n  }\n};\nexport default legend;","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/store/legend.js"],"names":["isUndefined","sum","deepMergedCopy","range","isNumber","getLegendItemHeight","LEGEND_CHECKBOX_SIZE","LEGEND_ICON_SIZE","LEGEND_ITEM_MARGIN_X","LEGEND_MARGIN_X","getTextWidth","isVerticalAlign","padding","SPECTRUM_LEGEND_LABEL_HEIGHT","spectrumLegendBar","spectrumLegendTooltip","hasNestedPieSeries","extend","getTitleFontString","makeDefaultTheme","isNoData","getIconType","getLegendAlign","showCheckbox","showCircleLegend","showLegend","INITIAL_LEGEND_WIDTH","INITIAL_CIRCLE_LEGEND_WIDTH","COMPONENT_HEIGHT_EXCEPT_Y_AXIS","ELLIPSIS_DOT_TEXT","WIDEST_TEXT","NUMBER_OF_BOTH_SIDES","recalculateLegendWhenHeightOverflows","params","legendHeight","legendWidths","itemHeight","totalHeight","length","columnCount","Math","ceil","rowCount","legendWidth","forEach","count","max","slice","Y","recalculateLegendWhenWidthOverflows","prevLegendWidth","reduce","acc","width","widthWithMargin","totalWidth","calculateLegendSize","visible","chart","verticalAlign","isOverflow","widthOverflow","calculateLegendWidth","heightOverflow","calculateLegendHeight","height","chartHeight","getDefaultLegendSize","getSpectrumLegendWidth","chartWidth","labelAreaWidth","spectrumAreaWidth","PADDING","X","POINT_HEIGHT","HEIGHT","getSpectrumLegendHeight","getNormalLegendWidth","initialWidth","checkbox","_a","_b","options","legendOptions","legend","circleLegendVisible","restAreaHeight","getNestedPieLegendLabelsInfo","series","legendInfo","result","maxTextLengthWithEllipsis","getMaxTextLengthWithEllipsis","pie","data","name","parentName","viewLabel","getViewLabelInfo","push","label","type","checked","font","checkboxVisible","item","checkboxWidth","iconWidth","ellipsisDotWidth","widestTextWidth","maxTextCount","floor","maxTextLength","useSpectrumLegend","itemWidth","itemWidthWithFullText","getItemWidth","getLegendLabelsInfo","Object","keys","flatMap","map","colorValue","getLegendDataAppliedTheme","colors","values","cur","datum","idx","assign","color","getLegendState","_c","_d","_e","_f","_g","_h","_j","useColorValue","heatmap","useScatterChartIcon","scatter","defaultTheme","theme","fontFamily","legendLabelsInfo","active","iconType","chartType","rowIndex","columnIndex","getNextColumnRowIndex","legendCount","maxLen","setIndexToLegendData","legendData","state","circleLegend","action","initLegendState","initStoreState","setLegendLayout","dispatch","setSpectrumLegendLayout","align","fontSize","setNormalLegendLayout","min","isNestedPieChart","isScatterChart","isBubbleChart","bubble","updateCircleLegendLayout","radius","setLegendActiveState","model","find","notify","setAllLegendActiveState","setLegendCheckedState","updateLegendColor","updateLegendIcon","updateNestedPieChartLegend","nestedPieSeries","observe","updateLegendLayout"],"mappings":"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","sourcesContent":["import { isUndefined, sum, deepMergedCopy, range, isNumber } from \"../helpers/utils\";\nimport { getLegendItemHeight, LEGEND_CHECKBOX_SIZE, LEGEND_ICON_SIZE, LEGEND_ITEM_MARGIN_X, LEGEND_MARGIN_X, } from \"../brushes/legend\";\nimport { getTextWidth } from \"../helpers/calculator\";\nimport { isVerticalAlign, padding } from \"./layout\";\nimport { SPECTRUM_LEGEND_LABEL_HEIGHT, spectrumLegendBar, spectrumLegendTooltip, } from \"../brushes/spectrumLegend\";\nimport { hasNestedPieSeries } from \"../helpers/pieSeries\";\nimport { extend } from \"./store\";\nimport { getTitleFontString } from \"../helpers/style\";\nimport { makeDefaultTheme } from \"../helpers/theme\";\nimport { isNoData } from \"../helpers/validation\";\nimport { getIconType, getLegendAlign, showCheckbox, showCircleLegend, showLegend, } from \"../helpers/legend\";\nconst INITIAL_LEGEND_WIDTH = 100;\nconst INITIAL_CIRCLE_LEGEND_WIDTH = 150;\nconst COMPONENT_HEIGHT_EXCEPT_Y_AXIS = 100;\nconst ELLIPSIS_DOT_TEXT = '...';\nconst WIDEST_TEXT = 'W'; // The widest text width in Arial font.\nconst NUMBER_OF_BOTH_SIDES = 2;\nfunction recalculateLegendWhenHeightOverflows(params, legendHeight) {\n    const { legendWidths, itemHeight } = params;\n    const totalHeight = legendWidths.length * itemHeight;\n    const columnCount = Math.ceil(totalHeight / legendHeight);\n    const rowCount = legendWidths.length / columnCount;\n    let legendWidth = 0;\n    range(0, columnCount).forEach((count) => {\n        legendWidth += Math.max(...legendWidths.slice(count * rowCount, (count + 1) * rowCount));\n    });\n    legendWidth += LEGEND_ITEM_MARGIN_X * (columnCount - 1);\n    return { legendWidth, legendHeight: rowCount * itemHeight + padding.Y, columnCount, rowCount };\n}\nfunction recalculateLegendWhenWidthOverflows(params, prevLegendWidth) {\n    const { legendWidths, itemHeight } = params;\n    let columnCount = 0;\n    let legendWidth = 0;\n    const { rowCount } = legendWidths.reduce((acc, width) => {\n        const widthWithMargin = LEGEND_ITEM_MARGIN_X + width;\n        if (acc.totalWidth + width > prevLegendWidth) {\n            acc.totalWidth = widthWithMargin;\n            acc.rowCount += 1;\n            acc.columnCount = 1;\n            columnCount = Math.max(columnCount, acc.columnCount);\n        }\n        else {\n            acc.totalWidth += widthWithMargin;\n            acc.columnCount += 1;\n        }\n        legendWidth = Math.max(legendWidth, acc.totalWidth);\n        return acc;\n    }, { totalWidth: 0, rowCount: 1, columnCount: 0 });\n    return { legendHeight: itemHeight * rowCount, rowCount, columnCount, legendWidth };\n}\nfunction calculateLegendSize(params) {\n    if (!params.visible) {\n        return { legendWidth: 0, legendHeight: 0, rowCount: 0, columnCount: 0 };\n    }\n    const { chart, verticalAlign, legendWidths } = params;\n    const { legendWidth, isOverflow: widthOverflow } = calculateLegendWidth(params);\n    const { legendHeight, isOverflow: heightOverflow } = calculateLegendHeight(params);\n    const columnCount = verticalAlign ? legendWidths.length : 1;\n    const rowCount = verticalAlign ? Math.ceil(legendWidth / chart.width) : legendWidths.length;\n    if (widthOverflow) {\n        return recalculateLegendWhenWidthOverflows(params, legendWidth / rowCount);\n    }\n    if (heightOverflow) {\n        return recalculateLegendWhenHeightOverflows(params, legendHeight);\n    }\n    return { legendWidth, legendHeight, columnCount, rowCount };\n}\nfunction calculateLegendHeight(params) {\n    const { verticalAlign, itemHeight, legendWidths } = params;\n    const { height: chartHeight } = getDefaultLegendSize(params);\n    let legendHeight;\n    let isOverflow = false;\n    if (verticalAlign) {\n        legendHeight = chartHeight;\n    }\n    else {\n        const totalHeight = legendWidths.length * itemHeight;\n        isOverflow = chartHeight < totalHeight;\n        legendHeight = isOverflow ? chartHeight : totalHeight;\n    }\n    return { legendHeight, isOverflow };\n}\nfunction getSpectrumLegendWidth(legendWidths, chartWidth, verticalAlign) {\n    if (verticalAlign) {\n        const labelAreaWidth = sum(legendWidths);\n        return Math.max(chartWidth / 4, labelAreaWidth);\n    }\n    const spectrumAreaWidth = (spectrumLegendTooltip.PADDING + spectrumLegendBar.PADDING + padding.X) * NUMBER_OF_BOTH_SIDES +\n        spectrumLegendTooltip.POINT_HEIGHT +\n        spectrumLegendBar.HEIGHT;\n    return Math.max(...legendWidths) + spectrumAreaWidth;\n}\nfunction getSpectrumLegendHeight(itemHeight, chartHeight, verticalAlign) {\n    return verticalAlign\n        ? SPECTRUM_LEGEND_LABEL_HEIGHT +\n            spectrumLegendBar.PADDING * NUMBER_OF_BOTH_SIDES +\n            spectrumLegendTooltip.POINT_HEIGHT +\n            spectrumLegendTooltip.HEIGHT +\n            padding.Y\n        : (chartHeight * 3) / 4;\n}\nfunction getNormalLegendWidth(params) {\n    const { initialWidth, legendWidths, checkbox, verticalAlign } = params;\n    let isOverflow = false;\n    let legendWidth;\n    if (verticalAlign) {\n        const { width: chartWidth } = getDefaultLegendSize(params);\n        const totalWidth = sum(legendWidths) + LEGEND_ITEM_MARGIN_X * (legendWidths.length - 1);\n        isOverflow = totalWidth > chartWidth;\n        legendWidth = totalWidth;\n    }\n    else {\n        const labelAreaWidth = Math.max(...legendWidths);\n        legendWidth =\n            (checkbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) +\n                LEGEND_ICON_SIZE +\n                LEGEND_MARGIN_X +\n                Math.max(labelAreaWidth, initialWidth);\n    }\n    return { legendWidth, isOverflow };\n}\nfunction calculateLegendWidth(params) {\n    var _a, _b;\n    const { options, visible } = params;\n    const legendOptions = (_a = options) === null || _a === void 0 ? void 0 : _a.legend;\n    if (!visible) {\n        return { legendWidth: 0, isOverflow: false };\n    }\n    if ((_b = legendOptions) === null || _b === void 0 ? void 0 : _b.width) {\n        return { legendWidth: legendOptions.width, isOverflow: false };\n    }\n    return getNormalLegendWidth(params);\n}\nfunction getDefaultLegendSize(params) {\n    const { verticalAlign, chart, itemHeight, initialWidth, circleLegendVisible } = params;\n    const restAreaHeight = COMPONENT_HEIGHT_EXCEPT_Y_AXIS + (circleLegendVisible ? INITIAL_CIRCLE_LEGEND_WIDTH : 0); // rest area temporary value (yAxisTitle.height + xAxis.height + circleLegend.height)\n    return verticalAlign\n        ? { width: chart.width - padding.X * NUMBER_OF_BOTH_SIDES, height: itemHeight }\n        : {\n            width: initialWidth,\n            height: chart.height - restAreaHeight,\n        };\n}\nfunction getNestedPieLegendLabelsInfo(series, legendInfo) {\n    const result = [];\n    const maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);\n    series.pie.forEach(({ data }) => {\n        data.forEach(({ name, parentName, visible }) => {\n            if (!parentName) {\n                const { width, viewLabel } = getViewLabelInfo(legendInfo, name, maxTextLengthWithEllipsis);\n                result.push({\n                    label: name,\n                    type: 'pie',\n                    checked: (visible !== null && visible !== void 0 ? visible : true),\n                    viewLabel,\n                    width,\n                });\n            }\n        });\n    });\n    return result;\n}\nfunction getMaxTextLengthWithEllipsis(legendInfo) {\n    var _a, _b;\n    const { legendOptions, font, checkboxVisible } = legendInfo;\n    const width = (_b = (_a = legendOptions) === null || _a === void 0 ? void 0 : _a.item) === null || _b === void 0 ? void 0 : _b.width;\n    if (isUndefined(width)) {\n        return;\n    }\n    const checkboxWidth = checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0;\n    const iconWidth = LEGEND_ICON_SIZE + LEGEND_MARGIN_X;\n    const ellipsisDotWidth = getTextWidth(ELLIPSIS_DOT_TEXT, font);\n    const widestTextWidth = getTextWidth(WIDEST_TEXT, font);\n    const maxTextCount = Math.floor((width - ellipsisDotWidth - checkboxWidth - iconWidth) / widestTextWidth);\n    return maxTextCount > 0 ? maxTextCount : 0;\n}\nfunction getViewLabelInfo(legendInfo, label, maxTextLength) {\n    var _a, _b;\n    const { checkboxVisible, useSpectrumLegend, font, legendOptions } = legendInfo;\n    let viewLabel = label;\n    const itemWidth = (_b = (_a = legendOptions) === null || _a === void 0 ? void 0 : _a.item) === null || _b === void 0 ? void 0 : _b.width;\n    const itemWidthWithFullText = getItemWidth(viewLabel, checkboxVisible, useSpectrumLegend, font);\n    if (isNumber(itemWidth) && isNumber(maxTextLength) && itemWidth < itemWidthWithFullText) {\n        viewLabel = `${label.slice(0, maxTextLength)}${ELLIPSIS_DOT_TEXT}`;\n    }\n    return { viewLabel, width: (itemWidth !== null && itemWidth !== void 0 ? itemWidth : itemWidthWithFullText) };\n}\nfunction getLegendLabelsInfo(series, legendInfo) {\n    const maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);\n    return Object.keys(series).flatMap((type) => series[type].map(({ name, colorValue, visible }) => {\n        const label = colorValue ? colorValue : name;\n        const { width, viewLabel } = getViewLabelInfo(legendInfo, label, maxTextLengthWithEllipsis);\n        return {\n            label,\n            type,\n            checked: (visible !== null && visible !== void 0 ? visible : true),\n            viewLabel,\n            width,\n        };\n    }));\n}\nfunction getItemWidth(label, checkboxVisible, useSpectrumLegend, font) {\n    return ((useSpectrumLegend\n        ? 0\n        : (checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) +\n            LEGEND_ICON_SIZE +\n            LEGEND_MARGIN_X) + getTextWidth(label, font));\n}\nfunction getLegendDataAppliedTheme(data, series) {\n    const colors = Object.values(series).reduce((acc, cur) => (cur && cur.colors ? [...acc, ...cur.colors] : acc), []);\n    return data.map((datum, idx) => (Object.assign(Object.assign({}, datum), { color: colors[idx] })));\n}\nfunction getLegendState(options, series) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    const useSpectrumLegend = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.useColorValue, (_c !== null && _c !== void 0 ? _c : !!series.heatmap));\n    const useScatterChartIcon = !!((_d = series) === null || _d === void 0 ? void 0 : _d.scatter);\n    const checkboxVisible = useSpectrumLegend\n        ? false\n        : showCheckbox(options);\n    const defaultTheme = makeDefaultTheme((_g = (_f = (_e = options) === null || _e === void 0 ? void 0 : _e.theme) === null || _f === void 0 ? void 0 : _f.chart) === null || _g === void 0 ? void 0 : _g.fontFamily);\n    const font = getTitleFontString(deepMergedCopy(defaultTheme.legend.label, Object.assign({}, (_j = (_h = options.theme) === null || _h === void 0 ? void 0 : _h.legend) === null || _j === void 0 ? void 0 : _j.label)));\n    const legendInfo = {\n        checkboxVisible,\n        font,\n        useSpectrumLegend,\n        legendOptions: options.legend,\n    };\n    const legendLabelsInfo = hasNestedPieSeries(series)\n        ? getNestedPieLegendLabelsInfo(series, legendInfo)\n        : getLegendLabelsInfo(series, legendInfo);\n    const data = legendLabelsInfo.map(({ label, type, checked, width, viewLabel }) => ({\n        label,\n        active: true,\n        checked,\n        width,\n        iconType: getIconType(type),\n        chartType: type,\n        rowIndex: 0,\n        columnIndex: 0,\n        viewLabel,\n    }));\n    return {\n        useSpectrumLegend,\n        useScatterChartIcon,\n        data,\n    };\n}\nfunction getNextColumnRowIndex(params) {\n    const { verticalAlign, columnCount, rowCount, legendCount } = params;\n    let { rowIndex, columnIndex } = params;\n    if (verticalAlign) {\n        const maxLen = legendCount / rowCount;\n        if (maxLen - 1 > columnIndex) {\n            columnIndex += 1;\n        }\n        else {\n            rowIndex += 1;\n            columnIndex = 0;\n        }\n    }\n    else {\n        const maxLen = legendCount / columnCount;\n        if (maxLen - 1 > rowIndex) {\n            rowIndex += 1;\n        }\n        else {\n            columnIndex += 1;\n            rowIndex = 0;\n        }\n    }\n    return [rowIndex, columnIndex];\n}\nfunction setIndexToLegendData(legendData, rowCount, columnCount, legendCount, verticalAlign) {\n    let columnIndex = 0;\n    let rowIndex = 0;\n    legendData.forEach((datum) => {\n        datum.rowIndex = rowIndex;\n        datum.columnIndex = columnIndex;\n        [rowIndex, columnIndex] = getNextColumnRowIndex({\n            rowCount,\n            columnCount,\n            verticalAlign,\n            legendCount,\n            rowIndex,\n            columnIndex,\n        });\n    });\n}\nconst legend = {\n    name: 'legend',\n    state: ({ options, series }) => {\n        return {\n            legend: getLegendState(options, series),\n            circleLegend: {},\n        };\n    },\n    action: {\n        initLegendState({ state, initStoreState }) {\n            extend(state.legend, getLegendState(initStoreState.options, initStoreState.series));\n        },\n        setLegendLayout({ state }) {\n            if (state.legend.useSpectrumLegend) {\n                this.dispatch('setSpectrumLegendLayout');\n            }\n            else {\n                this.dispatch('setNormalLegendLayout');\n            }\n        },\n        setSpectrumLegendLayout({ state }) {\n            const { legend: { data: legendData }, series, options, chart, theme, } = state;\n            const align = getLegendAlign(options);\n            const visible = showLegend(options, series);\n            const verticalAlign = isVerticalAlign(align);\n            const legendWidths = legendData.map(({ width }) => width);\n            const itemHeight = getLegendItemHeight(theme.legend.label.fontSize);\n            const width = getSpectrumLegendWidth(legendWidths, chart.width, verticalAlign);\n            const height = getSpectrumLegendHeight(itemHeight, chart.height, verticalAlign);\n            extend(state.legend, { visible, align, width, height });\n        },\n        setNormalLegendLayout({ state, initStoreState }) {\n            const { legend: { data: legendData }, series, options, chart, theme, } = state;\n            const align = getLegendAlign(options);\n            const visible = showLegend(options, series);\n            const checkbox = showCheckbox(options);\n            const initialWidth = Math.min(chart.width / 5, INITIAL_LEGEND_WIDTH);\n            const verticalAlign = isVerticalAlign(align);\n            const isNestedPieChart = hasNestedPieSeries(initStoreState.series);\n            const isScatterChart = !!series.scatter;\n            const isBubbleChart = !!series.bubble;\n            const circleLegendVisible = isBubbleChart\n                ? showCircleLegend(options)\n                : false;\n            const legendWidths = legendData.map(({ width }) => width);\n            const itemHeight = getLegendItemHeight(theme.legend.label.fontSize);\n            const { legendWidth, legendHeight, rowCount, columnCount } = calculateLegendSize({\n                initialWidth,\n                legendWidths,\n                options,\n                verticalAlign,\n                visible,\n                checkbox,\n                chart,\n                itemHeight,\n                circleLegendVisible,\n            });\n            setIndexToLegendData(legendData, rowCount, columnCount, legendWidths.length, verticalAlign);\n            extend(state.legend, {\n                visible,\n                align,\n                showCheckbox: checkbox,\n                width: legendWidth,\n                height: legendHeight,\n            });\n            if (isBubbleChart && circleLegendVisible) {\n                this.dispatch('updateCircleLegendLayout', { legendWidth });\n            }\n            if (!isNestedPieChart && !isNoData(series)) {\n                this.dispatch('updateLegendColor');\n            }\n            if (isScatterChart) {\n                this.dispatch('updateLegendIcon');\n            }\n        },\n        updateCircleLegendLayout({ state }, { legendWidth }) {\n            const width = legendWidth === 0\n                ? INITIAL_CIRCLE_LEGEND_WIDTH\n                : Math.min(legendWidth, INITIAL_CIRCLE_LEGEND_WIDTH);\n            const radius = Math.max((width - LEGEND_MARGIN_X) / 2, 0);\n            extend(state.circleLegend, { visible: true, width, radius });\n        },\n        setLegendActiveState({ state }, { name, active }) {\n            const { data } = state.legend;\n            const model = data.find(({ label }) => label === name);\n            model.active = active;\n            this.notify(state, 'legend');\n        },\n        setAllLegendActiveState({ state }, active) {\n            state.legend.data.forEach((datum) => {\n                datum.active = active;\n            });\n            this.notify(state, 'legend');\n        },\n        setLegendCheckedState({ state }, { name, checked }) {\n            const model = state.legend.data.find(({ label }) => label === name);\n            model.checked = checked;\n            this.notify(state, 'legend');\n        },\n        updateLegendColor({ state }) {\n            const { legend: legendData, series } = state;\n            const data = getLegendDataAppliedTheme(legendData.data, series);\n            extend(state.legend, { data });\n        },\n        updateLegendIcon({ state }) {\n            const { legend: legendData, series } = state;\n            const data = legendData.data.reduce((acc, cur) => {\n                var _a;\n                if (cur.chartType === 'scatter' && ((_a = series.scatter) === null || _a === void 0 ? void 0 : _a.data)) {\n                    const model = series.scatter.data.find(({ name }) => name === cur.label);\n                    const iconType = model ? model.iconType : cur.iconType;\n                    return [...acc, Object.assign(Object.assign({}, cur), { iconType })];\n                }\n                return [...acc, cur];\n            }, []);\n            extend(state.legend, { data });\n        },\n        updateNestedPieChartLegend({ state }) {\n            const { legend: legendData, nestedPieSeries } = state;\n            extend(state.legend, {\n                data: getLegendDataAppliedTheme(legendData.data, nestedPieSeries),\n            });\n        },\n    },\n    observe: {\n        updateLegendLayout() {\n            this.dispatch('setLegendLayout');\n        },\n    },\n};\nexport default legend;\n"]},"metadata":{},"sourceType":"module"}