{"ast":null,"code":"import Component from \"./component\";\nimport { makeTickPixelPositions, crispPixel } from \"../helpers/calculator\";\nimport { getAxisTheme } from \"../helpers/axes\";\nimport { getTitleFontString } from \"../helpers/style\";\nimport { AxisType } from \"./axis\";\nexport default class AxisUsingCenterY extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      label: [],\n      tick: [],\n      axisLine: []\n    };\n  }\n\n  initialize({\n    name\n  }) {\n    this.type = 'axis';\n    this.name = name;\n    this.yAxisComponent = name === AxisType.Y;\n  }\n\n  render({\n    layout,\n    axes,\n    theme\n  }) {\n    const {\n      centerYAxis\n    } = axes;\n\n    if (!centerYAxis) {\n      return;\n    }\n\n    this.theme = getAxisTheme(theme, this.name);\n    this.rect = layout[this.name];\n\n    if (this.name === 'yAxis') {\n      this.rect = Object.assign(Object.assign({}, this.rect), {\n        x: centerYAxis.x\n      });\n    }\n\n    const {\n      viewLabels,\n      tickCount,\n      tickInterval,\n      needRotateLabel,\n      radian,\n      offsetY\n    } = axes[this.name];\n    const renderOptions = {\n      tickInterval,\n      centerYAxis,\n      needRotateLabel,\n      radian,\n      offsetY,\n      relativePositions: makeTickPixelPositions(this.axisSize(centerYAxis), tickCount)\n    };\n    const offsetKey = this.yAxisComponent ? 'y' : 'x';\n    const anchorKey = this.yAxisComponent ? 'x' : 'y';\n    this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);\n    this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);\n    this.models.axisLine = this.renderAxisLineModel(centerYAxis);\n\n    if (!this.drawModels) {\n      this.drawModels = {\n        tick: [],\n        label: [],\n        axisLine: this.models.axisLine\n      };\n      ['tick', 'label'].forEach(type => {\n        this.drawModels[type] = this.models[type].map(m => {\n          const drawModel = Object.assign({}, m);\n\n          if (this.yAxisComponent) {\n            drawModel.y = 0;\n          } else {\n            drawModel.x = 0;\n          }\n\n          return drawModel;\n        });\n      });\n    }\n  }\n\n  renderAxisLineModel({\n    xAxisHalfSize,\n    secondStartX\n  }) {\n    const zeroPixel = crispPixel(0);\n    const widthPixel = crispPixel(this.rect.width);\n    let axisLine;\n\n    if (this.yAxisComponent) {\n      const heightPixel = crispPixel(this.rect.height);\n      axisLine = [{\n        type: 'line',\n        x: widthPixel,\n        y: zeroPixel,\n        x2: widthPixel,\n        y2: heightPixel\n      }, {\n        type: 'line',\n        x: zeroPixel,\n        y: zeroPixel,\n        x2: zeroPixel,\n        y2: heightPixel\n      }];\n    } else {\n      axisLine = [{\n        type: 'line',\n        x: zeroPixel,\n        y: zeroPixel,\n        x2: crispPixel(xAxisHalfSize),\n        y2: zeroPixel\n      }, {\n        type: 'line',\n        x: crispPixel(secondStartX),\n        y: zeroPixel,\n        x2: widthPixel,\n        y2: zeroPixel\n      }];\n    }\n\n    return axisLine;\n  }\n\n  renderTickModels(offsetKey, anchorKey, renderOptions) {\n    const tickAnchorPoint = this.yAxisComponent ? crispPixel(this.rect.width) : crispPixel(0);\n    const {\n      tickInterval,\n      centerYAxis: {\n        secondStartX\n      },\n      relativePositions\n    } = renderOptions;\n    return relativePositions.reduce((positions, position, index) => {\n      if (index % tickInterval) {\n        return positions;\n      }\n\n      const model = {\n        type: 'tick',\n        isYAxis: this.yAxisComponent,\n        tickSize: this.yAxisComponent ? -5 : 5,\n        [offsetKey]: crispPixel(position),\n        [anchorKey]: tickAnchorPoint\n      };\n      const addedTickModel = Object.assign({}, model);\n\n      if (this.yAxisComponent) {\n        addedTickModel[anchorKey] = crispPixel(0);\n        addedTickModel.tickSize = 5;\n      } else {\n        addedTickModel[offsetKey] = crispPixel(position + secondStartX);\n      }\n\n      return [...positions, model, addedTickModel];\n    }, []);\n  }\n\n  renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {\n    const {\n      centerYAxis: {\n        secondStartX,\n        yAxisLabelAnchorPoint\n      },\n      offsetY,\n      needRotateLabel,\n      radian\n    } = renderOptions;\n    const labelTheme = this.theme.label;\n    const font = getTitleFontString(labelTheme);\n    let labelAnchorPoint, textAlign, textLabels;\n\n    if (this.yAxisComponent) {\n      labelAnchorPoint = crispPixel(yAxisLabelAnchorPoint);\n      textAlign = 'center';\n      textLabels = labels;\n    } else {\n      labelAnchorPoint = offsetY;\n      textLabels = [...labels].reverse();\n      textAlign = needRotateLabel ? 'left' : 'center';\n    }\n\n    const style = ['default', {\n      textAlign,\n      font,\n      fillStyle: labelTheme.color\n    }];\n    return textLabels.reduce((positions, {\n      text,\n      offsetPos\n    }, index) => {\n      const model = {\n        type: 'label',\n        text,\n        style,\n        [offsetKey]: crispPixel(offsetPos) + (this.yAxisComponent ? 0 : secondStartX),\n        [anchorKey]: labelAnchorPoint,\n        radian\n      };\n      const models = [model];\n\n      if (!this.yAxisComponent) {\n        const addedLabelModel = Object.assign(Object.assign({}, model), {\n          text: labels[index].text,\n          [offsetKey]: crispPixel(model[offsetKey] - secondStartX)\n        });\n        models.push(addedLabelModel);\n      }\n\n      return [...positions, ...models];\n    }, []);\n  }\n\n  axisSize(centerYAxis) {\n    let size;\n\n    if (this.yAxisComponent) {\n      size = this.rect.height;\n    } else {\n      size = centerYAxis.xAxisHalfSize;\n    }\n\n    return size;\n  }\n\n  beforeDraw(painter) {\n    painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';\n    painter.ctx.lineWidth = 1;\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/axisUsingCenterY.js"],"names":["Component","makeTickPixelPositions","crispPixel","getAxisTheme","getTitleFontString","AxisType","AxisUsingCenterY","constructor","arguments","models","label","tick","axisLine","initialize","name","type","yAxisComponent","Y","render","layout","axes","theme","centerYAxis","rect","Object","assign","x","viewLabels","tickCount","tickInterval","needRotateLabel","radian","offsetY","renderOptions","relativePositions","axisSize","offsetKey","anchorKey","renderLabelModels","renderTickModels","renderAxisLineModel","drawModels","forEach","map","m","drawModel","y","xAxisHalfSize","secondStartX","zeroPixel","widthPixel","width","heightPixel","height","x2","y2","tickAnchorPoint","reduce","positions","position","index","model","isYAxis","tickSize","addedTickModel","labels","yAxisLabelAnchorPoint","labelTheme","font","labelAnchorPoint","textAlign","textLabels","reverse","style","fillStyle","color","text","offsetPos","addedLabelModel","push","size","beforeDraw","painter","ctx","strokeStyle","lineWidth"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { makeTickPixelPositions, crispPixel } from \"../helpers/calculator\";\nimport { getAxisTheme } from \"../helpers/axes\";\nimport { getTitleFontString } from \"../helpers/style\";\nimport { AxisType } from \"./axis\";\nexport default class AxisUsingCenterY extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { label: [], tick: [], axisLine: [] };\n    }\n    initialize({ name }) {\n        this.type = 'axis';\n        this.name = name;\n        this.yAxisComponent = name === AxisType.Y;\n    }\n    render({ layout, axes, theme }) {\n        const { centerYAxis } = axes;\n        if (!centerYAxis) {\n            return;\n        }\n        this.theme = getAxisTheme(theme, this.name);\n        this.rect = layout[this.name];\n        if (this.name === 'yAxis') {\n            this.rect = Object.assign(Object.assign({}, this.rect), { x: centerYAxis.x });\n        }\n        const { viewLabels, tickCount, tickInterval, needRotateLabel, radian, offsetY } = axes[this.name];\n        const renderOptions = {\n            tickInterval,\n            centerYAxis,\n            needRotateLabel,\n            radian,\n            offsetY,\n            relativePositions: makeTickPixelPositions(this.axisSize(centerYAxis), tickCount),\n        };\n        const offsetKey = this.yAxisComponent ? 'y' : 'x';\n        const anchorKey = this.yAxisComponent ? 'x' : 'y';\n        this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);\n        this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);\n        this.models.axisLine = this.renderAxisLineModel(centerYAxis);\n        if (!this.drawModels) {\n            this.drawModels = {\n                tick: [],\n                label: [],\n                axisLine: this.models.axisLine,\n            };\n            ['tick', 'label'].forEach((type) => {\n                this.drawModels[type] = this.models[type].map((m) => {\n                    const drawModel = Object.assign({}, m);\n                    if (this.yAxisComponent) {\n                        drawModel.y = 0;\n                    }\n                    else {\n                        drawModel.x = 0;\n                    }\n                    return drawModel;\n                });\n            });\n        }\n    }\n    renderAxisLineModel({ xAxisHalfSize, secondStartX }) {\n        const zeroPixel = crispPixel(0);\n        const widthPixel = crispPixel(this.rect.width);\n        let axisLine;\n        if (this.yAxisComponent) {\n            const heightPixel = crispPixel(this.rect.height);\n            axisLine = [\n                {\n                    type: 'line',\n                    x: widthPixel,\n                    y: zeroPixel,\n                    x2: widthPixel,\n                    y2: heightPixel,\n                },\n                {\n                    type: 'line',\n                    x: zeroPixel,\n                    y: zeroPixel,\n                    x2: zeroPixel,\n                    y2: heightPixel,\n                },\n            ];\n        }\n        else {\n            axisLine = [\n                {\n                    type: 'line',\n                    x: zeroPixel,\n                    y: zeroPixel,\n                    x2: crispPixel(xAxisHalfSize),\n                    y2: zeroPixel,\n                },\n                {\n                    type: 'line',\n                    x: crispPixel(secondStartX),\n                    y: zeroPixel,\n                    x2: widthPixel,\n                    y2: zeroPixel,\n                },\n            ];\n        }\n        return axisLine;\n    }\n    renderTickModels(offsetKey, anchorKey, renderOptions) {\n        const tickAnchorPoint = this.yAxisComponent ? crispPixel(this.rect.width) : crispPixel(0);\n        const { tickInterval, centerYAxis: { secondStartX }, relativePositions, } = renderOptions;\n        return relativePositions.reduce((positions, position, index) => {\n            if (index % tickInterval) {\n                return positions;\n            }\n            const model = {\n                type: 'tick',\n                isYAxis: this.yAxisComponent,\n                tickSize: this.yAxisComponent ? -5 : 5,\n                [offsetKey]: crispPixel(position),\n                [anchorKey]: tickAnchorPoint,\n            };\n            const addedTickModel = Object.assign({}, model);\n            if (this.yAxisComponent) {\n                addedTickModel[anchorKey] = crispPixel(0);\n                addedTickModel.tickSize = 5;\n            }\n            else {\n                addedTickModel[offsetKey] = crispPixel(position + secondStartX);\n            }\n            return [...positions, model, addedTickModel];\n        }, []);\n    }\n    renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {\n        const { centerYAxis: { secondStartX, yAxisLabelAnchorPoint }, offsetY, needRotateLabel, radian, } = renderOptions;\n        const labelTheme = this.theme.label;\n        const font = getTitleFontString(labelTheme);\n        let labelAnchorPoint, textAlign, textLabels;\n        if (this.yAxisComponent) {\n            labelAnchorPoint = crispPixel(yAxisLabelAnchorPoint);\n            textAlign = 'center';\n            textLabels = labels;\n        }\n        else {\n            labelAnchorPoint = offsetY;\n            textLabels = [...labels].reverse();\n            textAlign = needRotateLabel ? 'left' : 'center';\n        }\n        const style = ['default', { textAlign, font, fillStyle: labelTheme.color }];\n        return textLabels.reduce((positions, { text, offsetPos }, index) => {\n            const model = {\n                type: 'label',\n                text,\n                style,\n                [offsetKey]: crispPixel(offsetPos) + (this.yAxisComponent ? 0 : secondStartX),\n                [anchorKey]: labelAnchorPoint,\n                radian,\n            };\n            const models = [model];\n            if (!this.yAxisComponent) {\n                const addedLabelModel = Object.assign(Object.assign({}, model), { text: labels[index].text, [offsetKey]: crispPixel(model[offsetKey] - secondStartX) });\n                models.push(addedLabelModel);\n            }\n            return [...positions, ...models];\n        }, []);\n    }\n    axisSize(centerYAxis) {\n        let size;\n        if (this.yAxisComponent) {\n            size = this.rect.height;\n        }\n        else {\n            size = centerYAxis.xAxisHalfSize;\n        }\n        return size;\n    }\n    beforeDraw(painter) {\n        painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';\n        painter.ctx.lineWidth = 1;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}