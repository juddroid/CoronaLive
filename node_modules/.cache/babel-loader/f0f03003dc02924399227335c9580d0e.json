{"ast":null,"code":"import Component from \"./component\";\nimport { getCoordinateXValue, getCoordinateYValue } from \"../helpers/coordinate\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getValueRatio } from \"../helpers/calculator\";\nimport { deepCopy, deepMergedCopy, isNumber, isString, pick } from \"../helpers/utils\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getValueAxisName } from \"../helpers/axes\";\nimport { getNearestResponder } from \"../helpers/responders\";\nimport { message } from \"../message\";\nimport { isAvailableSelectSeries } from \"../helpers/validation\";\nexport default class ScatterSeries extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      series: []\n    };\n    this.activatedResponders = [];\n\n    this.onMouseoutComponent = () => {\n      this.eventBus.emit('seriesPointHovered', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('renderHoveredSeries', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.getModelsForSelectInfo = info => {\n      const {\n        index,\n        seriesIndex,\n        state\n      } = info;\n\n      if (!isAvailableSelectSeries(info, 'scatter')) {\n        return [];\n      }\n\n      const {\n        name\n      } = state.series.scatter.data[seriesIndex];\n      return [this.responders.filter(({\n        name: dataName\n      }) => dataName === name)[index]];\n    };\n\n    this.selectSeries = info => {\n      const models = this.getModelsForSelectInfo(info);\n\n      if (!models.length) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.showTooltip = info => {\n      const models = this.getModelsForSelectInfo(info);\n\n      if (!models.length) {\n        return;\n      }\n\n      this.eventBus.emit('renderHoveredSeries', {\n        models,\n        name: this.name\n      });\n      this.activatedResponders = models;\n      this.eventBus.emit('seriesPointHovered', {\n        models: this.activatedResponders,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  initialize() {\n    this.type = 'series';\n    this.name = 'scatter';\n    this.eventBus.on('selectSeries', this.selectSeries);\n    this.eventBus.on('showTooltip', this.showTooltip);\n    this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n  }\n\n  initUpdate(delta) {\n    this.drawModels.series.forEach((model, index) => {\n      model.size = this.models.series[index].size * delta;\n    });\n  }\n\n  render(chartState) {\n    const {\n      layout,\n      series,\n      scale,\n      legend,\n      options,\n      theme\n    } = chartState;\n\n    if (!series.scatter) {\n      throw new Error(message.noDataError(this.name));\n    }\n\n    const scatterData = series.scatter.data;\n    this.theme = theme.series.scatter;\n    this.rect = layout.plot;\n    this.activeSeriesMap = getActiveSeriesMap(legend);\n    this.selectable = this.getSelectableOption(options);\n    const seriesModel = this.renderScatterPointsModel(scatterData, scale.xAxis.limit, scale[getValueAxisName(options, this.name, 'yAxis')].limit);\n    const tooltipModel = this.makeTooltipModel(scatterData);\n    this.models.series = seriesModel;\n\n    if (!this.drawModels) {\n      this.drawModels = deepCopy(this.models);\n    }\n\n    this.responders = seriesModel.map((m, index) => Object.assign(Object.assign({}, m), {\n      type: 'circle',\n      detectionSize: 0,\n      radius: this.theme.size / 2,\n      color: m.fillColor,\n      style: [{\n        strokeStyle: m.borderColor,\n        lineWidth: m.borderWidth\n      }],\n      data: tooltipModel[index]\n    }));\n  }\n\n  renderScatterPointsModel(seriesRawData, xAxisLimit, yAxisLimit) {\n    return seriesRawData.flatMap(({\n      data,\n      name,\n      color: seriesColor,\n      iconType\n    }, seriesIndex) => {\n      const models = [];\n      const active = this.activeSeriesMap[name];\n      const color = getRGBA(seriesColor, active ? 1 : 0.3);\n      data.forEach((datum, index) => {\n        const rawXValue = getCoordinateXValue(datum);\n        const xValue = isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);\n        const yValue = getCoordinateYValue(datum);\n        const xValueRatio = getValueRatio(xValue, xAxisLimit);\n        const yValueRatio = getValueRatio(yValue, yAxisLimit);\n        const x = xValueRatio * this.rect.width;\n        const y = (1 - yValueRatio) * this.rect.height;\n        models.push(Object.assign({\n          x,\n          y,\n          type: 'scatterSeries',\n          iconType,\n          seriesIndex,\n          name,\n          borderColor: color,\n          index\n        }, pick(this.theme, 'borderWidth', 'size', 'fillColor')));\n      });\n      return models;\n    });\n  }\n\n  makeTooltipModel(circleData) {\n    return [...circleData].flatMap(({\n      data,\n      name,\n      color\n    }) => {\n      const tooltipData = [];\n      data.forEach(datum => {\n        const value = {\n          x: getCoordinateXValue(datum),\n          y: getCoordinateYValue(datum)\n        };\n        tooltipData.push({\n          label: name,\n          color,\n          value\n        });\n      });\n      return tooltipData;\n    });\n  }\n\n  getClosestModel(closestResponder) {\n    if (!closestResponder.length) {\n      return [];\n    }\n\n    const model = this.models.series.find(({\n      index,\n      seriesIndex\n    }) => isNumber(index) && isNumber(seriesIndex) && index === closestResponder[0].index && seriesIndex === closestResponder[0].seriesIndex);\n    return model ? [model] : [];\n  }\n\n  getResponderAppliedTheme(closestModel, type) {\n    const {\n      fillColor,\n      size\n    } = this.theme[type];\n    return closestModel.map(m => deepMergedCopy(m, Object.assign(Object.assign({}, this.theme[type]), {\n      color: fillColor,\n      radius: size / 2\n    })));\n  }\n\n  onMousemove({\n    responders,\n    mousePosition\n  }) {\n    const closestResponder = getNearestResponder(responders, mousePosition, this.rect);\n    let closestModel = this.getClosestModel(closestResponder);\n    closestModel = this.getResponderAppliedTheme(closestModel, 'hover');\n    this.eventBus.emit('renderHoveredSeries', {\n      models: closestModel,\n      name: this.name\n    });\n    this.activatedResponders = closestResponder;\n    this.eventBus.emit('seriesPointHovered', {\n      models: this.activatedResponders,\n      name: this.name\n    });\n    this.eventBus.emit('needDraw');\n  }\n\n  onClick({\n    responders,\n    mousePosition\n  }) {\n    if (this.selectable) {\n      const closestResponder = getNearestResponder(responders, mousePosition, this.rect);\n      let closestModel = this.getClosestModel(closestResponder);\n      closestModel = this.getResponderAppliedTheme(closestModel, 'select');\n      this.eventBus.emit('renderSelectedSeries', {\n        models: closestModel,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/scatterSeries.js"],"names":["Component","getCoordinateXValue","getCoordinateYValue","getRGBA","getValueRatio","deepCopy","deepMergedCopy","isNumber","isString","pick","getActiveSeriesMap","getValueAxisName","getNearestResponder","message","isAvailableSelectSeries","ScatterSeries","constructor","arguments","models","series","activatedResponders","onMouseoutComponent","eventBus","emit","name","getModelsForSelectInfo","info","index","seriesIndex","state","scatter","data","responders","filter","dataName","selectSeries","length","Error","SELECT_SERIES_API_INDEX_ERROR","showTooltip","initialize","type","on","initUpdate","delta","drawModels","forEach","model","size","render","chartState","layout","scale","legend","options","theme","noDataError","scatterData","rect","plot","activeSeriesMap","selectable","getSelectableOption","seriesModel","renderScatterPointsModel","xAxis","limit","tooltipModel","makeTooltipModel","map","m","Object","assign","detectionSize","radius","color","fillColor","style","strokeStyle","borderColor","lineWidth","borderWidth","seriesRawData","xAxisLimit","yAxisLimit","flatMap","seriesColor","iconType","active","datum","rawXValue","xValue","Number","Date","yValue","xValueRatio","yValueRatio","x","width","y","height","push","circleData","tooltipData","value","label","getClosestModel","closestResponder","find","getResponderAppliedTheme","closestModel","onMousemove","mousePosition","onClick"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { getCoordinateXValue, getCoordinateYValue } from \"../helpers/coordinate\";\nimport { getRGBA } from \"../helpers/color\";\nimport { getValueRatio } from \"../helpers/calculator\";\nimport { deepCopy, deepMergedCopy, isNumber, isString, pick } from \"../helpers/utils\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getValueAxisName } from \"../helpers/axes\";\nimport { getNearestResponder } from \"../helpers/responders\";\nimport { message } from \"../message\";\nimport { isAvailableSelectSeries } from \"../helpers/validation\";\nexport default class ScatterSeries extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { series: [] };\n        this.activatedResponders = [];\n        this.onMouseoutComponent = () => {\n            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });\n            this.eventBus.emit('renderHoveredSeries', {\n                models: [],\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.getModelsForSelectInfo = (info) => {\n            const { index, seriesIndex, state } = info;\n            if (!isAvailableSelectSeries(info, 'scatter')) {\n                return [];\n            }\n            const { name } = state.series.scatter.data[seriesIndex];\n            return [this.responders.filter(({ name: dataName }) => dataName === name)[index]];\n        };\n        this.selectSeries = (info) => {\n            const models = this.getModelsForSelectInfo(info);\n            if (!models.length) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            this.eventBus.emit('renderSelectedSeries', { models, name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n        this.showTooltip = (info) => {\n            const models = this.getModelsForSelectInfo(info);\n            if (!models.length) {\n                return;\n            }\n            this.eventBus.emit('renderHoveredSeries', { models, name: this.name });\n            this.activatedResponders = models;\n            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n    }\n    initialize() {\n        this.type = 'series';\n        this.name = 'scatter';\n        this.eventBus.on('selectSeries', this.selectSeries);\n        this.eventBus.on('showTooltip', this.showTooltip);\n        this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n    }\n    initUpdate(delta) {\n        this.drawModels.series.forEach((model, index) => {\n            model.size = this.models.series[index].size * delta;\n        });\n    }\n    render(chartState) {\n        const { layout, series, scale, legend, options, theme } = chartState;\n        if (!series.scatter) {\n            throw new Error(message.noDataError(this.name));\n        }\n        const scatterData = series.scatter.data;\n        this.theme = theme.series.scatter;\n        this.rect = layout.plot;\n        this.activeSeriesMap = getActiveSeriesMap(legend);\n        this.selectable = this.getSelectableOption(options);\n        const seriesModel = this.renderScatterPointsModel(scatterData, scale.xAxis.limit, scale[getValueAxisName(options, this.name, 'yAxis')].limit);\n        const tooltipModel = this.makeTooltipModel(scatterData);\n        this.models.series = seriesModel;\n        if (!this.drawModels) {\n            this.drawModels = deepCopy(this.models);\n        }\n        this.responders = seriesModel.map((m, index) => (Object.assign(Object.assign({}, m), { type: 'circle', detectionSize: 0, radius: this.theme.size / 2, color: m.fillColor, style: [{ strokeStyle: m.borderColor, lineWidth: m.borderWidth }], data: tooltipModel[index] })));\n    }\n    renderScatterPointsModel(seriesRawData, xAxisLimit, yAxisLimit) {\n        return seriesRawData.flatMap(({ data, name, color: seriesColor, iconType }, seriesIndex) => {\n            const models = [];\n            const active = this.activeSeriesMap[name];\n            const color = getRGBA(seriesColor, active ? 1 : 0.3);\n            data.forEach((datum, index) => {\n                const rawXValue = getCoordinateXValue(datum);\n                const xValue = isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);\n                const yValue = getCoordinateYValue(datum);\n                const xValueRatio = getValueRatio(xValue, xAxisLimit);\n                const yValueRatio = getValueRatio(yValue, yAxisLimit);\n                const x = xValueRatio * this.rect.width;\n                const y = (1 - yValueRatio) * this.rect.height;\n                models.push(Object.assign({ x,\n                    y, type: 'scatterSeries', iconType,\n                    seriesIndex,\n                    name, borderColor: color, index }, pick(this.theme, 'borderWidth', 'size', 'fillColor')));\n            });\n            return models;\n        });\n    }\n    makeTooltipModel(circleData) {\n        return [...circleData].flatMap(({ data, name, color }) => {\n            const tooltipData = [];\n            data.forEach((datum) => {\n                const value = {\n                    x: getCoordinateXValue(datum),\n                    y: getCoordinateYValue(datum),\n                };\n                tooltipData.push({ label: name, color, value });\n            });\n            return tooltipData;\n        });\n    }\n    getClosestModel(closestResponder) {\n        if (!closestResponder.length) {\n            return [];\n        }\n        const model = this.models.series.find(({ index, seriesIndex }) => isNumber(index) &&\n            isNumber(seriesIndex) &&\n            index === closestResponder[0].index &&\n            seriesIndex === closestResponder[0].seriesIndex);\n        return model ? [model] : [];\n    }\n    getResponderAppliedTheme(closestModel, type) {\n        const { fillColor, size } = this.theme[type];\n        return closestModel.map((m) => deepMergedCopy(m, Object.assign(Object.assign({}, this.theme[type]), { color: fillColor, radius: size / 2 })));\n    }\n    onMousemove({ responders, mousePosition }) {\n        const closestResponder = getNearestResponder(responders, mousePosition, this.rect);\n        let closestModel = this.getClosestModel(closestResponder);\n        closestModel = this.getResponderAppliedTheme(closestModel, 'hover');\n        this.eventBus.emit('renderHoveredSeries', { models: closestModel, name: this.name });\n        this.activatedResponders = closestResponder;\n        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n        this.eventBus.emit('needDraw');\n    }\n    onClick({ responders, mousePosition }) {\n        if (this.selectable) {\n            const closestResponder = getNearestResponder(responders, mousePosition, this.rect);\n            let closestModel = this.getClosestModel(closestResponder);\n            closestModel = this.getResponderAppliedTheme(closestModel, 'select');\n            this.eventBus.emit('renderSelectedSeries', {\n                models: closestModel,\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}