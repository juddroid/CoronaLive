{"ast":null,"code":"import { extend } from \"./store\";\nimport { deepCopy, getFirstValidValue, includes, isBoolean, isNumber, isUndefined, range } from \"../helpers/utils\";\nimport { makeRawCategories } from \"./category\";\nimport { getCoordinateXValue, isCoordinateSeries } from \"../helpers/coordinate\";\nimport { isZooming } from \"../helpers/range\";\nimport { message } from \"../message\";\nimport { hasNestedPieSeries } from \"../helpers/pieSeries\";\n\nfunction initRange(series, categories) {\n  let rawCategoriesLength;\n\n  if (categories) {\n    rawCategoriesLength = Array.isArray(categories) ? categories.length : categories.x.length;\n  } else {\n    rawCategoriesLength = Object.keys(makeRawCategories(series, categories)).length;\n  }\n\n  return [0, rawCategoriesLength - 1];\n}\n\nfunction initZoomRange(series, options, categories) {\n  var _a;\n\n  if (!(series.line || series.area) || !((_a = options.series) === null || _a === void 0 ? void 0 : _a.zoomable)) {\n    return;\n  }\n\n  return initRange(series, categories);\n}\n\nfunction initShiftRange(series, options, categories) {\n  var _a;\n\n  if (!(series.line || series.area || series.column || series.heatmap) || !((_a = options.series) === null || _a === void 0 ? void 0 : _a.shift)) {\n    return;\n  }\n\n  return initRange(series, categories);\n}\n\nfunction getCoordinateDataRange(data, rawCategories, zoomRange) {\n  const [zoomStart, zoomEnd] = zoomRange;\n  let start, end;\n  range(zoomStart, zoomEnd + 1).forEach(i => {\n    const idx = data.findIndex(datum => getCoordinateXValue(datum).toString() === rawCategories[i]);\n\n    if (idx !== -1) {\n      if (isUndefined(start)) {\n        start = idx;\n      }\n\n      if (!isUndefined(start)) {\n        end = Math.max(idx, end !== null && end !== void 0 ? end : 0);\n      }\n    }\n  });\n  return [start, end];\n}\n\nfunction getSeriesDataInRange(data, rawCategories, chartType, zoomRange) {\n  if (!zoomRange) {\n    return data;\n  }\n\n  let [startIdx, endIdx] = zoomRange;\n  const isCoordinateChart = chartType !== 'area' && !isNumber(getFirstValidValue(data));\n\n  if (isCoordinateChart) {\n    [startIdx, endIdx] = getCoordinateDataRange(data, rawCategories, zoomRange);\n  } else {\n    startIdx = startIdx > 1 ? startIdx - 1 : startIdx;\n    endIdx = endIdx < rawCategories.length - 1 ? endIdx + 1 : endIdx;\n  }\n\n  return data.slice(startIdx, endIdx + 1);\n}\n\nfunction isCoordinateTypeSeries(series, chartType) {\n  return isCoordinateSeries(series) && (isUndefined(chartType) || chartType === 'line' || chartType === 'scatter');\n}\n\nfunction isSeriesAlreadyExist(series, seriesName, data) {\n  return series[seriesName].some(({\n    label\n  }) => label === data.name);\n}\n\nfunction isTreemapSeriesAlreadyExist(series, data) {\n  return series.treemap.some(({\n    label\n  }) => label === data.label);\n}\n\nfunction isHeatmapSeriesAlreadyExist(categories, category) {\n  return includes(categories.y, category);\n}\n\nfunction initDisabledSeries(series) {\n  const nestedPieChart = hasNestedPieSeries(series);\n  const disabledSeries = [];\n\n  if (nestedPieChart) {\n    series.pie.forEach(({\n      data\n    }) => {\n      data.forEach(datum => {\n        if (isBoolean(datum.visible) && !datum.visible) {\n          disabledSeries.push(datum.name);\n        }\n      });\n    });\n  } else {\n    Object.keys(series).forEach(type => {\n      series[type].forEach(({\n        name,\n        visible\n      }) => {\n        if (isBoolean(visible) && !visible) {\n          disabledSeries.push(name);\n        }\n      });\n    });\n  }\n\n  return disabledSeries;\n}\n\nconst seriesData = {\n  name: 'seriesData',\n  state: ({\n    series,\n    categories,\n    options\n  }) => ({\n    rawCategories: makeRawCategories(series, categories),\n    series: Object.assign({}, series),\n    zoomRange: initZoomRange(series, options, categories),\n    shiftRange: initShiftRange(series, options, categories),\n    disabledSeries: initDisabledSeries(series)\n  }),\n  action: {\n    setSeriesData({\n      state,\n      initStoreState\n    }) {\n      const rawSeries = deepCopy(initStoreState.series);\n      const {\n        disabledSeries,\n        theme,\n        zoomRange,\n        rawCategories\n      } = state;\n      const newSeriesData = {};\n      Object.keys(rawSeries).forEach(seriesName => {\n        var _a, _b, _c;\n\n        const {\n          colors,\n          iconTypes\n        } = theme.series[seriesName];\n        let originSeriesData = rawSeries[seriesName].map((m, idx) => Object.assign(Object.assign({}, m), {\n          rawData: m.data,\n          data: getSeriesDataInRange(m.data, rawCategories, seriesName, zoomRange),\n          color: colors ? colors[idx % colors.length] : ''\n        }));\n\n        if (seriesName === 'scatter') {\n          originSeriesData = originSeriesData.map((m, idx) => Object.assign(Object.assign({}, m), {\n            iconType: iconTypes ? iconTypes[idx] : 'circle'\n          }));\n        }\n\n        const seriesCount = originSeriesData.length;\n        const seriesGroupCount = (_c = (_b = (_a = originSeriesData[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.length, _c !== null && _c !== void 0 ? _c : 0);\n        const data = originSeriesData.filter(({\n          name\n        }) => !disabledSeries.includes(name));\n        newSeriesData[seriesName] = {\n          seriesCount,\n          seriesGroupCount,\n          data,\n          colors\n        };\n      });\n      extend(state.series, newSeriesData);\n    },\n\n    disableSeries({\n      state\n    }, name) {\n      state.disabledSeries.push(name);\n      this.notify(state, 'disabledSeries');\n\n      if (state.series.bullet) {\n        this.dispatch('removeCategoryByName', name);\n      }\n    },\n\n    enableSeries({\n      state\n    }, name) {\n      const index = state.disabledSeries.findIndex(disabled => disabled === name);\n      state.disabledSeries.splice(index, 1);\n      this.notify(state, 'disabledSeries');\n\n      if (state.series.bullet) {\n        state.categories = state.series.bullet.data.map(({\n          name: seriesName\n        }) => seriesName);\n        this.notify(state, 'axes');\n      }\n    },\n\n    zoom({\n      state\n    }, rangeCategories) {\n      const rawCategories = state.rawCategories;\n      state.zoomRange = rangeCategories.map(rangeCategory => rawCategories.findIndex(category => category === rangeCategory));\n      this.notify(state, 'zoomRange');\n    },\n\n    resetZoom({\n      state,\n      initStoreState\n    }) {\n      const {\n        series,\n        options\n      } = initStoreState;\n      const rawCategories = state.rawCategories;\n      state.zoomRange = initZoomRange(series, options, rawCategories);\n      this.notify(state, 'zoomRange');\n    },\n\n    addData({\n      state,\n      initStoreState\n    }, {\n      data,\n      category,\n      chartType\n    }) {\n      const {\n        series\n      } = initStoreState;\n      const coordinateChart = isCoordinateTypeSeries(state.series, chartType);\n      let {\n        categories\n      } = initStoreState;\n      categories = series.heatmap ? categories.x : categories;\n\n      if (category && Array.isArray(categories)) {\n        const isExist = categories.some(c => c === category);\n\n        if (!isExist) {\n          categories.push(category);\n\n          if (Array.isArray(state.shiftRange)) {\n            const [start, end] = state.shiftRange;\n            state.shiftRange = [start + 1, end + 1];\n          }\n        }\n      }\n\n      if (chartType) {\n        series[chartType].forEach((datum, idx) => {\n          datum.data.push(data[idx]);\n        });\n      } else {\n        const [seriesName] = Object.keys(initStoreState.series);\n        series[seriesName].forEach((datum, idx) => {\n          datum.data.push(data[idx]);\n        });\n      }\n\n      this.notify(state, 'series');\n      this.notify(state, 'rawCategories');\n\n      if (Array.isArray(state.zoomRange)) {\n        this.dispatch('resetZoom');\n      }\n\n      if (coordinateChart) {\n        this.dispatch('initCategory');\n      }\n    },\n\n    addSeries({\n      state,\n      initStoreState\n    }, {\n      data,\n      chartType,\n      category\n    }) {\n      const {\n        series,\n        categories\n      } = initStoreState;\n      const coordinateChart = isCoordinateTypeSeries(state.series, chartType);\n      const seriesName = chartType || Object.keys(series)[0];\n      const isExist = isSeriesAlreadyExist(series, seriesName, data);\n\n      if (!isExist) {\n        series[seriesName].push(data);\n\n        if (Array.isArray(categories) && category) {\n          categories.push(category);\n        }\n      }\n\n      this.dispatch('initThemeState');\n      this.dispatch('initLegendState');\n      this.notify(state, 'series');\n\n      if (coordinateChart || seriesName === 'bullet') {\n        this.dispatch('initCategory');\n      }\n    },\n\n    addHeatmapSeries({\n      state,\n      initStoreState\n    }, {\n      data,\n      category\n    }) {\n      const {\n        series,\n        categories\n      } = initStoreState;\n      const isExist = isHeatmapSeriesAlreadyExist(categories, category);\n\n      if (!isExist) {\n        series.heatmap.push({\n          data,\n          yCategory: category\n        });\n      }\n\n      if (!isExist && category) {\n        categories.y.push(category);\n        this.notify(state, 'rawCategories');\n      }\n\n      this.notify(state, 'series');\n      this.dispatch('initThemeState');\n      this.dispatch('initLegendState');\n    },\n\n    addTreemapSeries({\n      state,\n      initStoreState\n    }, {\n      data\n    }) {\n      const {\n        series\n      } = initStoreState;\n      const isExist = isTreemapSeriesAlreadyExist(series, data);\n\n      if (!isExist) {\n        series.treemap.push(data);\n      }\n\n      this.notify(state, 'series');\n      this.notify(state, 'treemapSeries');\n      this.dispatch('initThemeState');\n      this.dispatch('initLegendState');\n    },\n\n    setData({\n      state,\n      initStoreState\n    }, {\n      series,\n      categories\n    }) {\n      initStoreState.series = series;\n      state.rawCategories = makeRawCategories(series, categories);\n      this.dispatch('initThemeState');\n      this.dispatch('initLegendState');\n    },\n\n    addOutlier({\n      state,\n      initStoreState\n    }, {\n      seriesIndex,\n      outliers\n    }) {\n      var _a;\n\n      const {\n        series\n      } = initStoreState;\n      const seriesRawData = series.boxPlot[seriesIndex];\n\n      if (!seriesRawData) {\n        throw new Error(message.SERIES_INDEX_ERROR);\n      }\n\n      seriesRawData.outliers = [...(_a = seriesRawData.outliers, _a !== null && _a !== void 0 ? _a : []), ...outliers];\n      this.notify(state, 'series');\n    }\n\n  },\n  observe: {\n    updateSeriesData() {\n      this.dispatch('setSeriesData');\n    }\n\n  },\n  computed: {\n    isLineTypeSeriesZooming: ({\n      zoomRange,\n      rawCategories\n    }) => {\n      return isZooming(rawCategories, zoomRange);\n    },\n    viewRange: ({\n      zoomRange,\n      shiftRange\n    }) => {\n      return zoomRange || shiftRange;\n    }\n  }\n};\nexport default seriesData;","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/store/seriesData.js"],"names":["extend","deepCopy","getFirstValidValue","includes","isBoolean","isNumber","isUndefined","range","makeRawCategories","getCoordinateXValue","isCoordinateSeries","isZooming","message","hasNestedPieSeries","initRange","series","categories","rawCategoriesLength","Array","isArray","length","x","Object","keys","initZoomRange","options","_a","line","area","zoomable","initShiftRange","column","heatmap","shift","getCoordinateDataRange","data","rawCategories","zoomRange","zoomStart","zoomEnd","start","end","forEach","i","idx","findIndex","datum","toString","Math","max","getSeriesDataInRange","chartType","startIdx","endIdx","isCoordinateChart","slice","isCoordinateTypeSeries","isSeriesAlreadyExist","seriesName","some","label","name","isTreemapSeriesAlreadyExist","treemap","isHeatmapSeriesAlreadyExist","category","y","initDisabledSeries","nestedPieChart","disabledSeries","pie","visible","push","type","seriesData","state","assign","shiftRange","action","setSeriesData","initStoreState","rawSeries","theme","newSeriesData","_b","_c","colors","iconTypes","originSeriesData","map","m","rawData","color","iconType","seriesCount","seriesGroupCount","filter","disableSeries","notify","bullet","dispatch","enableSeries","index","disabled","splice","zoom","rangeCategories","rangeCategory","resetZoom","addData","coordinateChart","isExist","c","addSeries","addHeatmapSeries","yCategory","addTreemapSeries","setData","addOutlier","seriesIndex","outliers","seriesRawData","boxPlot","Error","SERIES_INDEX_ERROR","observe","updateSeriesData","computed","isLineTypeSeriesZooming","viewRange"],"mappings":"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","sourcesContent":["import { extend } from \"./store\";\nimport { deepCopy, getFirstValidValue, includes, isBoolean, isNumber, isUndefined, range, } from \"../helpers/utils\";\nimport { makeRawCategories } from \"./category\";\nimport { getCoordinateXValue, isCoordinateSeries } from \"../helpers/coordinate\";\nimport { isZooming } from \"../helpers/range\";\nimport { message } from \"../message\";\nimport { hasNestedPieSeries } from \"../helpers/pieSeries\";\nfunction initRange(series, categories) {\n    let rawCategoriesLength;\n    if (categories) {\n        rawCategoriesLength = Array.isArray(categories) ? categories.length : categories.x.length;\n    }\n    else {\n        rawCategoriesLength = Object.keys(makeRawCategories(series, categories)).length;\n    }\n    return [0, rawCategoriesLength - 1];\n}\nfunction initZoomRange(series, options, categories) {\n    var _a;\n    if (!(series.line || series.area) || !((_a = options.series) === null || _a === void 0 ? void 0 : _a.zoomable)) {\n        return;\n    }\n    return initRange(series, categories);\n}\nfunction initShiftRange(series, options, categories) {\n    var _a;\n    if (!(series.line || series.area || series.column || series.heatmap) ||\n        !((_a = options.series) === null || _a === void 0 ? void 0 : _a.shift)) {\n        return;\n    }\n    return initRange(series, categories);\n}\nfunction getCoordinateDataRange(data, rawCategories, zoomRange) {\n    const [zoomStart, zoomEnd] = zoomRange;\n    let start, end;\n    range(zoomStart, zoomEnd + 1).forEach((i) => {\n        const idx = data.findIndex((datum) => getCoordinateXValue(datum).toString() === rawCategories[i]);\n        if (idx !== -1) {\n            if (isUndefined(start)) {\n                start = idx;\n            }\n            if (!isUndefined(start)) {\n                end = Math.max(idx, (end !== null && end !== void 0 ? end : 0));\n            }\n        }\n    });\n    return [start, end];\n}\nfunction getSeriesDataInRange(data, rawCategories, chartType, zoomRange) {\n    if (!zoomRange) {\n        return data;\n    }\n    let [startIdx, endIdx] = zoomRange;\n    const isCoordinateChart = chartType !== 'area' && !isNumber(getFirstValidValue(data));\n    if (isCoordinateChart) {\n        [startIdx, endIdx] = getCoordinateDataRange(data, rawCategories, zoomRange);\n    }\n    else {\n        startIdx = startIdx > 1 ? startIdx - 1 : startIdx;\n        endIdx = endIdx < rawCategories.length - 1 ? endIdx + 1 : endIdx;\n    }\n    return data.slice(startIdx, endIdx + 1);\n}\nfunction isCoordinateTypeSeries(series, chartType) {\n    return (isCoordinateSeries(series) &&\n        (isUndefined(chartType) || chartType === 'line' || chartType === 'scatter'));\n}\nfunction isSeriesAlreadyExist(series, seriesName, data) {\n    return series[seriesName].some(({ label }) => label === data.name);\n}\nfunction isTreemapSeriesAlreadyExist(series, data) {\n    return series.treemap.some(({ label }) => label === data.label);\n}\nfunction isHeatmapSeriesAlreadyExist(categories, category) {\n    return includes(categories.y, category);\n}\nfunction initDisabledSeries(series) {\n    const nestedPieChart = hasNestedPieSeries(series);\n    const disabledSeries = [];\n    if (nestedPieChart) {\n        series.pie.forEach(({ data }) => {\n            data.forEach((datum) => {\n                if (isBoolean(datum.visible) && !datum.visible) {\n                    disabledSeries.push(datum.name);\n                }\n            });\n        });\n    }\n    else {\n        Object.keys(series).forEach((type) => {\n            series[type].forEach(({ name, visible }) => {\n                if (isBoolean(visible) && !visible) {\n                    disabledSeries.push(name);\n                }\n            });\n        });\n    }\n    return disabledSeries;\n}\nconst seriesData = {\n    name: 'seriesData',\n    state: ({ series, categories, options }) => ({\n        rawCategories: makeRawCategories(series, categories),\n        series: Object.assign({}, series),\n        zoomRange: initZoomRange(series, options, categories),\n        shiftRange: initShiftRange(series, options, categories),\n        disabledSeries: initDisabledSeries(series),\n    }),\n    action: {\n        setSeriesData({ state, initStoreState }) {\n            const rawSeries = deepCopy(initStoreState.series);\n            const { disabledSeries, theme, zoomRange, rawCategories } = state;\n            const newSeriesData = {};\n            Object.keys(rawSeries).forEach((seriesName) => {\n                var _a, _b, _c;\n                const { colors, iconTypes } = theme.series[seriesName];\n                let originSeriesData = rawSeries[seriesName].map((m, idx) => (Object.assign(Object.assign({}, m), { rawData: m.data, data: getSeriesDataInRange(m.data, rawCategories, seriesName, zoomRange), color: colors ? colors[idx % colors.length] : '' })));\n                if (seriesName === 'scatter') {\n                    originSeriesData = originSeriesData.map((m, idx) => (Object.assign(Object.assign({}, m), { iconType: iconTypes ? iconTypes[idx] : 'circle' })));\n                }\n                const seriesCount = originSeriesData.length;\n                const seriesGroupCount = (_c = (_b = (_a = originSeriesData[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.length, (_c !== null && _c !== void 0 ? _c : 0));\n                const data = originSeriesData.filter(({ name }) => !disabledSeries.includes(name));\n                newSeriesData[seriesName] = {\n                    seriesCount,\n                    seriesGroupCount,\n                    data,\n                    colors,\n                };\n            });\n            extend(state.series, newSeriesData);\n        },\n        disableSeries({ state }, name) {\n            state.disabledSeries.push(name);\n            this.notify(state, 'disabledSeries');\n            if (state.series.bullet) {\n                this.dispatch('removeCategoryByName', name);\n            }\n        },\n        enableSeries({ state }, name) {\n            const index = state.disabledSeries.findIndex((disabled) => disabled === name);\n            state.disabledSeries.splice(index, 1);\n            this.notify(state, 'disabledSeries');\n            if (state.series.bullet) {\n                state.categories = state.series.bullet.data.map(({ name: seriesName }) => seriesName);\n                this.notify(state, 'axes');\n            }\n        },\n        zoom({ state }, rangeCategories) {\n            const rawCategories = state.rawCategories;\n            state.zoomRange = rangeCategories.map((rangeCategory) => rawCategories.findIndex((category) => category === rangeCategory));\n            this.notify(state, 'zoomRange');\n        },\n        resetZoom({ state, initStoreState }) {\n            const { series, options } = initStoreState;\n            const rawCategories = state.rawCategories;\n            state.zoomRange = initZoomRange(series, options, rawCategories);\n            this.notify(state, 'zoomRange');\n        },\n        addData({ state, initStoreState }, { data, category, chartType }) {\n            const { series } = initStoreState;\n            const coordinateChart = isCoordinateTypeSeries(state.series, chartType);\n            let { categories } = initStoreState;\n            categories = series.heatmap ? categories.x : categories;\n            if (category && Array.isArray(categories)) {\n                const isExist = categories.some((c) => c === category);\n                if (!isExist) {\n                    categories.push(category);\n                    if (Array.isArray(state.shiftRange)) {\n                        const [start, end] = state.shiftRange;\n                        state.shiftRange = [start + 1, end + 1];\n                    }\n                }\n            }\n            if (chartType) {\n                series[chartType].forEach((datum, idx) => {\n                    datum.data.push(data[idx]);\n                });\n            }\n            else {\n                const [seriesName] = Object.keys(initStoreState.series);\n                series[seriesName].forEach((datum, idx) => {\n                    datum.data.push(data[idx]);\n                });\n            }\n            this.notify(state, 'series');\n            this.notify(state, 'rawCategories');\n            if (Array.isArray(state.zoomRange)) {\n                this.dispatch('resetZoom');\n            }\n            if (coordinateChart) {\n                this.dispatch('initCategory');\n            }\n        },\n        addSeries({ state, initStoreState }, { data, chartType, category, }) {\n            const { series, categories } = initStoreState;\n            const coordinateChart = isCoordinateTypeSeries(state.series, chartType);\n            const seriesName = chartType || Object.keys(series)[0];\n            const isExist = isSeriesAlreadyExist(series, seriesName, data);\n            if (!isExist) {\n                series[seriesName].push(data);\n                if (Array.isArray(categories) && category) {\n                    categories.push(category);\n                }\n            }\n            this.dispatch('initThemeState');\n            this.dispatch('initLegendState');\n            this.notify(state, 'series');\n            if (coordinateChart || seriesName === 'bullet') {\n                this.dispatch('initCategory');\n            }\n        },\n        addHeatmapSeries({ state, initStoreState }, { data, category }) {\n            const { series, categories } = initStoreState;\n            const isExist = isHeatmapSeriesAlreadyExist(categories, category);\n            if (!isExist) {\n                series.heatmap.push({ data, yCategory: category });\n            }\n            if (!isExist && category) {\n                categories.y.push(category);\n                this.notify(state, 'rawCategories');\n            }\n            this.notify(state, 'series');\n            this.dispatch('initThemeState');\n            this.dispatch('initLegendState');\n        },\n        addTreemapSeries({ state, initStoreState }, { data }) {\n            const { series } = initStoreState;\n            const isExist = isTreemapSeriesAlreadyExist(series, data);\n            if (!isExist) {\n                series.treemap.push(data);\n            }\n            this.notify(state, 'series');\n            this.notify(state, 'treemapSeries');\n            this.dispatch('initThemeState');\n            this.dispatch('initLegendState');\n        },\n        setData({ state, initStoreState }, { series, categories }) {\n            initStoreState.series = series;\n            state.rawCategories = makeRawCategories(series, categories);\n            this.dispatch('initThemeState');\n            this.dispatch('initLegendState');\n        },\n        addOutlier({ state, initStoreState }, { seriesIndex, outliers }) {\n            var _a;\n            const { series } = initStoreState;\n            const seriesRawData = series.boxPlot[seriesIndex];\n            if (!seriesRawData) {\n                throw new Error(message.SERIES_INDEX_ERROR);\n            }\n            seriesRawData.outliers = [...(_a = seriesRawData.outliers, (_a !== null && _a !== void 0 ? _a : [])), ...outliers];\n            this.notify(state, 'series');\n        },\n    },\n    observe: {\n        updateSeriesData() {\n            this.dispatch('setSeriesData');\n        },\n    },\n    computed: {\n        isLineTypeSeriesZooming: ({ zoomRange, rawCategories }) => {\n            return isZooming(rawCategories, zoomRange);\n        },\n        viewRange: ({ zoomRange, shiftRange }) => {\n            return zoomRange || shiftRange;\n        },\n    },\n};\nexport default seriesData;\n"]},"metadata":{},"sourceType":"module"}