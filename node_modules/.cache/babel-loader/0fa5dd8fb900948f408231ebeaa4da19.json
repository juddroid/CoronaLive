{"ast":null,"code":"import Component from \"./component\";\nimport { getValueRatio, setSplineControlPoint, getXPosition } from \"../helpers/calculator\";\nimport { getCoordinateDataIndex, getCoordinateXValue, getCoordinateYValue } from \"../helpers/coordinate\";\nimport { getRGBA } from \"../helpers/color\";\nimport { pick, includes, isNull } from \"../helpers/utils\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getNearestResponder, makeRectResponderModel, makeTooltipCircleMap } from \"../helpers/responders\";\nimport { getValueAxisName } from \"../helpers/axes\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { message } from \"../message\";\nimport { isAvailableSelectSeries, isAvailableShowTooltipInfo } from \"../helpers/validation\";\nexport default class LineSeries extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      rect: [],\n      series: [],\n      dot: []\n    };\n    this.activatedResponders = [];\n    this.eventDetectType = 'nearest';\n    this.yAxisName = 'yAxis';\n\n    this.onMouseoutComponent = () => {\n      this.eventBus.emit('seriesPointHovered', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('renderHoveredSeries', {\n        models: [],\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.selectSeries = info => {\n      const {\n        index,\n        seriesIndex\n      } = info;\n\n      if (!isAvailableSelectSeries(info, 'line')) {\n        return;\n      }\n\n      const category = this.getResponderCategoryByIndex(index);\n\n      if (!category) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      const model = this.tooltipCircleMap[category][seriesIndex];\n\n      if (!model) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models: [model],\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.showTooltip = info => {\n      var _a;\n\n      const {\n        index,\n        seriesIndex\n      } = info;\n\n      if (!isAvailableShowTooltipInfo(info, this.eventDetectType, 'line')) {\n        return;\n      }\n\n      const category = this.getResponderCategoryByIndex(index);\n\n      if (!category) {\n        return;\n      }\n\n      const models = this.eventDetectType === 'grouped' ? this.tooltipCircleMap[category] : [this.tooltipCircleMap[category][seriesIndex]];\n\n      if (!((_a = models) === null || _a === void 0 ? void 0 : _a.length)) {\n        return;\n      }\n\n      this.onMousemoveNearType(models);\n      this.eventBus.emit('seriesPointHovered', {\n        models: this.activatedResponders,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  initialize() {\n    this.type = 'series';\n    this.name = 'line';\n    this.eventBus.on('selectSeries', this.selectSeries);\n    this.eventBus.on('showTooltip', this.showTooltip);\n    this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n  }\n\n  initUpdate(delta) {\n    this.drawModels.rect[0].width = this.models.rect[0].width * delta;\n  }\n\n  setEventDetectType(series, options) {\n    var _a, _b;\n\n    if (series.area || series.column) {\n      this.eventDetectType = 'grouped';\n    }\n\n    if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n      this.eventDetectType = options.series.eventDetectType;\n    }\n\n    if (series.scatter) {\n      this.eventDetectType = 'near';\n    }\n  }\n\n  render(chartState, computed) {\n    var _a, _b;\n\n    const {\n      viewRange\n    } = computed;\n    const {\n      layout,\n      series,\n      scale,\n      axes,\n      legend,\n      theme\n    } = chartState;\n\n    if (!series.line) {\n      throw new Error(message.noDataError(this.name));\n    }\n\n    const categories = (_a = chartState.categories, _a !== null && _a !== void 0 ? _a : []);\n    const options = Object.assign({}, chartState.options);\n\n    if (((_b = options) === null || _b === void 0 ? void 0 : _b.series) && 'line' in options.series) {\n      options.series = Object.assign(Object.assign({}, options.series), options.series.line);\n    }\n\n    this.setEventDetectType(series, options);\n    const labelAxisData = axes.xAxis;\n    const {\n      tickDistance,\n      pointOnColumn,\n      labelDistance\n    } = labelAxisData;\n    const lineSeriesData = series.line.data;\n    const renderLineOptions = {\n      pointOnColumn,\n      options: options.series || {},\n      tickDistance,\n      labelDistance\n    };\n    this.theme = theme.series.line;\n    this.rect = layout.plot;\n    this.activeSeriesMap = getActiveSeriesMap(legend);\n    this.startIndex = viewRange ? viewRange[0] : 0;\n    this.selectable = this.getSelectableOption(options);\n    this.yAxisName = getValueAxisName(options, this.name, 'yAxis');\n    const lineSeriesModel = this.renderLinePointsModel(lineSeriesData, scale, renderLineOptions, categories);\n    const {\n      dotSeriesModel,\n      responderModel\n    } = this.renderCircleModel(lineSeriesModel, renderLineOptions);\n    const tooltipDataArr = this.makeTooltipData(lineSeriesData, categories);\n    this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);\n    this.models = {\n      rect: [this.renderClipRectAreaModel()],\n      series: lineSeriesModel,\n      dot: dotSeriesModel\n    };\n\n    if (!this.drawModels) {\n      this.drawModels = Object.assign(Object.assign({}, this.models), {\n        rect: [this.renderClipRectAreaModel(true)]\n      });\n    }\n\n    if (getDataLabelsOptions(options, this.name).visible) {\n      this.renderDataLabels(this.getDataLabels(lineSeriesModel));\n    }\n\n    this.responders = this.getResponders(labelAxisData, responderModel, tooltipDataArr, categories);\n  }\n\n  getResponders(axisData, seriesCircleModel, tooltipDataArr, categories) {\n    let res;\n\n    if (this.eventDetectType === 'near') {\n      res = this.makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr);\n    } else if (this.eventDetectType === 'point') {\n      res = this.makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, 0);\n    } else {\n      res = makeRectResponderModel(this.rect, axisData, categories);\n    }\n\n    return res;\n  }\n\n  makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, detectionSize) {\n    return seriesCircleModel.map((m, index) => Object.assign(Object.assign({}, m), {\n      data: tooltipDataArr[index],\n      detectionSize\n    }));\n  }\n\n  makeTooltipData(lineSeriesData, categories) {\n    return lineSeriesData.flatMap(({\n      rawData,\n      name,\n      color\n    }, seriesIndex) => {\n      return rawData.map((datum, index) => isNull(datum) ? {} : {\n        label: name,\n        color,\n        value: getCoordinateYValue(datum),\n        category: categories[getCoordinateDataIndex(datum, categories, index, this.startIndex)],\n        seriesIndex,\n        index\n      });\n    });\n  }\n\n  renderClipRectAreaModel(isDrawModel) {\n    return {\n      type: 'clipRectArea',\n      x: 0,\n      y: 0,\n      width: isDrawModel ? 0 : this.rect.width,\n      height: this.rect.height\n    };\n  }\n\n  renderLinePointsModel(seriesRawData, scale, renderOptions, categories) {\n    var _a, _b;\n\n    const {\n      spline\n    } = renderOptions.options;\n    const yAxisLimit = scale[this.yAxisName].limit;\n    const xAxisLimit = (_b = (_a = scale) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.limit;\n    const {\n      lineWidth,\n      dashSegments\n    } = this.theme;\n    return seriesRawData.map(({\n      rawData,\n      name,\n      color: seriesColor\n    }, seriesIndex) => {\n      const points = [];\n      const active = this.activeSeriesMap[name];\n      rawData.forEach((datum, idx) => {\n        if (isNull(datum)) {\n          return points.push(null);\n        }\n\n        const value = getCoordinateYValue(datum);\n        const yValueRatio = getValueRatio(value, yAxisLimit);\n        const y = (1 - yValueRatio) * this.rect.height;\n        const x = getXPosition(pick(renderOptions, 'pointOnColumn', 'tickDistance', 'labelDistance'), this.rect.width, getCoordinateXValue(datum), getCoordinateDataIndex(datum, categories, idx, this.startIndex), xAxisLimit);\n        points.push({\n          x,\n          y,\n          value\n        });\n      });\n\n      if (spline) {\n        setSplineControlPoint(points);\n      }\n\n      return {\n        type: 'linePoints',\n        points,\n        seriesIndex,\n        name,\n        color: getRGBA(seriesColor, active ? 1 : 0.3),\n        lineWidth,\n        dashSegments\n      };\n    });\n  }\n\n  renderCircleModel(lineSeriesModel, {\n    options\n  }) {\n    const dotSeriesModel = [];\n    const responderModel = [];\n    const showDot = !!options.showDot;\n    const {\n      hover,\n      dot: dotTheme\n    } = this.theme;\n    const hoverDotTheme = hover.dot;\n    lineSeriesModel.forEach(({\n      color,\n      name,\n      points\n    }, seriesIndex) => {\n      const active = this.activeSeriesMap[name];\n      points.forEach((point, index) => {\n        var _a, _b;\n\n        if (isNull(point)) {\n          return;\n        }\n\n        const {\n          x,\n          y\n        } = point;\n        const model = {\n          type: 'circle',\n          x,\n          y,\n          seriesIndex,\n          name,\n          index\n        };\n\n        if (showDot) {\n          dotSeriesModel.push(Object.assign(Object.assign({}, model), {\n            radius: dotTheme.radius,\n            color: getRGBA(color, active ? 1 : 0.3),\n            style: [{\n              lineWidth: dotTheme.borderWidth,\n              strokeStyle: (_a = dotTheme.borderColor, _a !== null && _a !== void 0 ? _a : color)\n            }]\n          }));\n        }\n\n        responderModel.push(Object.assign(Object.assign({}, model), {\n          radius: hoverDotTheme.radius,\n          color: (_b = hoverDotTheme.color, _b !== null && _b !== void 0 ? _b : getRGBA(color, 1)),\n          style: ['default']\n        }));\n      });\n    });\n    return {\n      dotSeriesModel,\n      responderModel\n    };\n  }\n\n  getCircleModelsFromRectResponders(responders, mousePositions) {\n    var _a, _b;\n\n    if (!responders.length || !responders[0].label) {\n      return [];\n    }\n\n    const models = (_b = this.tooltipCircleMap[(_a = responders[0]) === null || _a === void 0 ? void 0 : _a.label], _b !== null && _b !== void 0 ? _b : []);\n    return this.eventDetectType === 'grouped' ? models : getNearestResponder(models, mousePositions, this.rect);\n  }\n\n  onMousemoveNearType(responders) {\n    this.eventBus.emit('renderHoveredSeries', {\n      models: this.getResponderSeriesWithTheme(responders, 'hover'),\n      name: this.name,\n      eventDetectType: this.eventDetectType\n    });\n    this.activatedResponders = responders;\n  }\n\n  onMousemoveNearestType(responders, mousePositions) {\n    const circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);\n    this.onMousemoveNearType(circleModels);\n  }\n\n  onMousemoveGroupedType(responders) {\n    const circleModels = this.getCircleModelsFromRectResponders(responders);\n    this.onMousemoveNearType(circleModels);\n  }\n\n  onMousemove({\n    responders,\n    mousePosition\n  }) {\n    if (this.eventDetectType === 'nearest') {\n      this.onMousemoveNearestType(responders, mousePosition);\n    } else if (includes(['near', 'point'], this.eventDetectType)) {\n      this.onMousemoveNearType(responders);\n    } else {\n      this.onMousemoveGroupedType(responders);\n    }\n\n    this.eventBus.emit('seriesPointHovered', {\n      models: this.activatedResponders,\n      name: this.name\n    });\n    this.eventBus.emit('needDraw');\n  }\n\n  getDataLabels(seriesModels) {\n    const dataLabelTheme = this.theme.dataLabels;\n    return seriesModels.flatMap(({\n      points,\n      name,\n      color\n    }) => points.map(point => isNull(point) ? {} : Object.assign(Object.assign({\n      type: 'point'\n    }, point), {\n      name,\n      theme: Object.assign(Object.assign({}, dataLabelTheme), {\n        color: dataLabelTheme.useSeriesColor ? color : dataLabelTheme.color\n      })\n    })));\n  }\n\n  getResponderSeriesWithTheme(models, type) {\n    const {\n      radius,\n      color,\n      borderWidth,\n      borderColor\n    } = this.theme[type].dot;\n    return models.map(model => {\n      const modelColor = color !== null && color !== void 0 ? color : model.color;\n      return Object.assign(Object.assign({}, model), {\n        radius,\n        color: modelColor,\n        style: [{\n          lineWidth: borderWidth,\n          strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)\n        }]\n      });\n    });\n  }\n\n  onClick({\n    responders,\n    mousePosition\n  }) {\n    if (this.selectable) {\n      let models;\n\n      if (this.eventDetectType === 'near') {\n        models = responders;\n      } else {\n        models = this.getCircleModelsFromRectResponders(responders, mousePosition);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models: this.getResponderSeriesWithTheme(models, 'select'),\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    }\n  }\n\n  getResponderCategoryByIndex(index) {\n    var _a, _b;\n\n    const responder = Object.values(this.tooltipCircleMap).flatMap(val => val).find(model => model.index === index);\n    return (_b = (_a = responder) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.category;\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/lineSeries.js"],"names":["Component","getValueRatio","setSplineControlPoint","getXPosition","getCoordinateDataIndex","getCoordinateXValue","getCoordinateYValue","getRGBA","pick","includes","isNull","getActiveSeriesMap","getNearestResponder","makeRectResponderModel","makeTooltipCircleMap","getValueAxisName","getDataLabelsOptions","message","isAvailableSelectSeries","isAvailableShowTooltipInfo","LineSeries","constructor","arguments","models","rect","series","dot","activatedResponders","eventDetectType","yAxisName","onMouseoutComponent","eventBus","emit","name","selectSeries","info","index","seriesIndex","category","getResponderCategoryByIndex","Error","SELECT_SERIES_API_INDEX_ERROR","model","tooltipCircleMap","showTooltip","_a","length","onMousemoveNearType","initialize","type","on","initUpdate","delta","drawModels","width","setEventDetectType","options","_b","area","column","scatter","render","chartState","computed","viewRange","layout","scale","axes","legend","theme","line","noDataError","categories","Object","assign","labelAxisData","xAxis","tickDistance","pointOnColumn","labelDistance","lineSeriesData","data","renderLineOptions","plot","activeSeriesMap","startIndex","selectable","getSelectableOption","lineSeriesModel","renderLinePointsModel","dotSeriesModel","responderModel","renderCircleModel","tooltipDataArr","makeTooltipData","renderClipRectAreaModel","visible","renderDataLabels","getDataLabels","responders","getResponders","axisData","seriesCircleModel","res","makeNearTypeResponderModel","detectionSize","map","m","flatMap","rawData","color","datum","label","value","isDrawModel","x","y","height","seriesRawData","renderOptions","spline","yAxisLimit","limit","xAxisLimit","lineWidth","dashSegments","seriesColor","points","active","forEach","idx","push","yValueRatio","showDot","hover","dotTheme","hoverDotTheme","point","radius","style","borderWidth","strokeStyle","borderColor","getCircleModelsFromRectResponders","mousePositions","getResponderSeriesWithTheme","onMousemoveNearestType","circleModels","onMousemoveGroupedType","onMousemove","mousePosition","seriesModels","dataLabelTheme","dataLabels","useSeriesColor","modelColor","onClick","responder","values","val","find"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { getValueRatio, setSplineControlPoint, getXPosition } from \"../helpers/calculator\";\nimport { getCoordinateDataIndex, getCoordinateXValue, getCoordinateYValue, } from \"../helpers/coordinate\";\nimport { getRGBA } from \"../helpers/color\";\nimport { pick, includes, isNull } from \"../helpers/utils\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getNearestResponder, makeRectResponderModel, makeTooltipCircleMap, } from \"../helpers/responders\";\nimport { getValueAxisName } from \"../helpers/axes\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { message } from \"../message\";\nimport { isAvailableSelectSeries, isAvailableShowTooltipInfo } from \"../helpers/validation\";\nexport default class LineSeries extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { rect: [], series: [], dot: [] };\n        this.activatedResponders = [];\n        this.eventDetectType = 'nearest';\n        this.yAxisName = 'yAxis';\n        this.onMouseoutComponent = () => {\n            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });\n            this.eventBus.emit('renderHoveredSeries', {\n                models: [],\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.selectSeries = (info) => {\n            const { index, seriesIndex } = info;\n            if (!isAvailableSelectSeries(info, 'line')) {\n                return;\n            }\n            const category = this.getResponderCategoryByIndex(index);\n            if (!category) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            const model = this.tooltipCircleMap[category][seriesIndex];\n            if (!model) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            this.eventBus.emit('renderSelectedSeries', { models: [model], name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n        this.showTooltip = (info) => {\n            var _a;\n            const { index, seriesIndex } = info;\n            if (!isAvailableShowTooltipInfo(info, this.eventDetectType, 'line')) {\n                return;\n            }\n            const category = this.getResponderCategoryByIndex(index);\n            if (!category) {\n                return;\n            }\n            const models = this.eventDetectType === 'grouped'\n                ? this.tooltipCircleMap[category]\n                : [this.tooltipCircleMap[category][seriesIndex]];\n            if (!((_a = models) === null || _a === void 0 ? void 0 : _a.length)) {\n                return;\n            }\n            this.onMousemoveNearType(models);\n            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n    }\n    initialize() {\n        this.type = 'series';\n        this.name = 'line';\n        this.eventBus.on('selectSeries', this.selectSeries);\n        this.eventBus.on('showTooltip', this.showTooltip);\n        this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n    }\n    initUpdate(delta) {\n        this.drawModels.rect[0].width = this.models.rect[0].width * delta;\n    }\n    setEventDetectType(series, options) {\n        var _a, _b;\n        if (series.area || series.column) {\n            this.eventDetectType = 'grouped';\n        }\n        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n            this.eventDetectType = options.series.eventDetectType;\n        }\n        if (series.scatter) {\n            this.eventDetectType = 'near';\n        }\n    }\n    render(chartState, computed) {\n        var _a, _b;\n        const { viewRange } = computed;\n        const { layout, series, scale, axes, legend, theme } = chartState;\n        if (!series.line) {\n            throw new Error(message.noDataError(this.name));\n        }\n        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));\n        const options = Object.assign({}, chartState.options);\n        if (((_b = options) === null || _b === void 0 ? void 0 : _b.series) && 'line' in options.series) {\n            options.series = Object.assign(Object.assign({}, options.series), options.series.line);\n        }\n        this.setEventDetectType(series, options);\n        const labelAxisData = axes.xAxis;\n        const { tickDistance, pointOnColumn, labelDistance } = labelAxisData;\n        const lineSeriesData = series.line.data;\n        const renderLineOptions = {\n            pointOnColumn,\n            options: (options.series || {}),\n            tickDistance,\n            labelDistance,\n        };\n        this.theme = theme.series.line;\n        this.rect = layout.plot;\n        this.activeSeriesMap = getActiveSeriesMap(legend);\n        this.startIndex = viewRange ? viewRange[0] : 0;\n        this.selectable = this.getSelectableOption(options);\n        this.yAxisName = getValueAxisName(options, this.name, 'yAxis');\n        const lineSeriesModel = this.renderLinePointsModel(lineSeriesData, scale, renderLineOptions, categories);\n        const { dotSeriesModel, responderModel } = this.renderCircleModel(lineSeriesModel, renderLineOptions);\n        const tooltipDataArr = this.makeTooltipData(lineSeriesData, categories);\n        this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);\n        this.models = {\n            rect: [this.renderClipRectAreaModel()],\n            series: lineSeriesModel,\n            dot: dotSeriesModel,\n        };\n        if (!this.drawModels) {\n            this.drawModels = Object.assign(Object.assign({}, this.models), { rect: [this.renderClipRectAreaModel(true)] });\n        }\n        if (getDataLabelsOptions(options, this.name).visible) {\n            this.renderDataLabels(this.getDataLabels(lineSeriesModel));\n        }\n        this.responders = this.getResponders(labelAxisData, responderModel, tooltipDataArr, categories);\n    }\n    getResponders(axisData, seriesCircleModel, tooltipDataArr, categories) {\n        let res;\n        if (this.eventDetectType === 'near') {\n            res = this.makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr);\n        }\n        else if (this.eventDetectType === 'point') {\n            res = this.makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, 0);\n        }\n        else {\n            res = makeRectResponderModel(this.rect, axisData, categories);\n        }\n        return res;\n    }\n    makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, detectionSize) {\n        return seriesCircleModel.map((m, index) => (Object.assign(Object.assign({}, m), { data: tooltipDataArr[index], detectionSize })));\n    }\n    makeTooltipData(lineSeriesData, categories) {\n        return lineSeriesData.flatMap(({ rawData, name, color }, seriesIndex) => {\n            return rawData.map((datum, index) => isNull(datum)\n                ? {}\n                : {\n                    label: name,\n                    color,\n                    value: getCoordinateYValue(datum),\n                    category: categories[getCoordinateDataIndex(datum, categories, index, this.startIndex)],\n                    seriesIndex,\n                    index,\n                });\n        });\n    }\n    renderClipRectAreaModel(isDrawModel) {\n        return {\n            type: 'clipRectArea',\n            x: 0,\n            y: 0,\n            width: isDrawModel ? 0 : this.rect.width,\n            height: this.rect.height,\n        };\n    }\n    renderLinePointsModel(seriesRawData, scale, renderOptions, categories) {\n        var _a, _b;\n        const { spline } = renderOptions.options;\n        const yAxisLimit = scale[this.yAxisName].limit;\n        const xAxisLimit = (_b = (_a = scale) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.limit;\n        const { lineWidth, dashSegments } = this.theme;\n        return seriesRawData.map(({ rawData, name, color: seriesColor }, seriesIndex) => {\n            const points = [];\n            const active = this.activeSeriesMap[name];\n            rawData.forEach((datum, idx) => {\n                if (isNull(datum)) {\n                    return points.push(null);\n                }\n                const value = getCoordinateYValue(datum);\n                const yValueRatio = getValueRatio(value, yAxisLimit);\n                const y = (1 - yValueRatio) * this.rect.height;\n                const x = getXPosition(pick(renderOptions, 'pointOnColumn', 'tickDistance', 'labelDistance'), this.rect.width, getCoordinateXValue(datum), getCoordinateDataIndex(datum, categories, idx, this.startIndex), xAxisLimit);\n                points.push({ x, y, value });\n            });\n            if (spline) {\n                setSplineControlPoint(points);\n            }\n            return {\n                type: 'linePoints',\n                points,\n                seriesIndex,\n                name,\n                color: getRGBA(seriesColor, active ? 1 : 0.3),\n                lineWidth,\n                dashSegments,\n            };\n        });\n    }\n    renderCircleModel(lineSeriesModel, { options }) {\n        const dotSeriesModel = [];\n        const responderModel = [];\n        const showDot = !!options.showDot;\n        const { hover, dot: dotTheme } = this.theme;\n        const hoverDotTheme = hover.dot;\n        lineSeriesModel.forEach(({ color, name, points }, seriesIndex) => {\n            const active = this.activeSeriesMap[name];\n            points.forEach((point, index) => {\n                var _a, _b;\n                if (isNull(point)) {\n                    return;\n                }\n                const { x, y } = point;\n                const model = { type: 'circle', x, y, seriesIndex, name, index };\n                if (showDot) {\n                    dotSeriesModel.push(Object.assign(Object.assign({}, model), { radius: dotTheme.radius, color: getRGBA(color, active ? 1 : 0.3), style: [\n                            { lineWidth: dotTheme.borderWidth, strokeStyle: (_a = dotTheme.borderColor, (_a !== null && _a !== void 0 ? _a : color)) },\n                        ] }));\n                }\n                responderModel.push(Object.assign(Object.assign({}, model), { radius: hoverDotTheme.radius, color: (_b = hoverDotTheme.color, (_b !== null && _b !== void 0 ? _b : getRGBA(color, 1))), style: ['default'] }));\n            });\n        });\n        return { dotSeriesModel, responderModel };\n    }\n    getCircleModelsFromRectResponders(responders, mousePositions) {\n        var _a, _b;\n        if (!responders.length || !responders[0].label) {\n            return [];\n        }\n        const models = (_b = this.tooltipCircleMap[(_a = responders[0]) === null || _a === void 0 ? void 0 : _a.label], (_b !== null && _b !== void 0 ? _b : []));\n        return this.eventDetectType === 'grouped'\n            ? models\n            : getNearestResponder(models, mousePositions, this.rect);\n    }\n    onMousemoveNearType(responders) {\n        this.eventBus.emit('renderHoveredSeries', {\n            models: this.getResponderSeriesWithTheme(responders, 'hover'),\n            name: this.name,\n            eventDetectType: this.eventDetectType,\n        });\n        this.activatedResponders = responders;\n    }\n    onMousemoveNearestType(responders, mousePositions) {\n        const circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);\n        this.onMousemoveNearType(circleModels);\n    }\n    onMousemoveGroupedType(responders) {\n        const circleModels = this.getCircleModelsFromRectResponders(responders);\n        this.onMousemoveNearType(circleModels);\n    }\n    onMousemove({ responders, mousePosition }) {\n        if (this.eventDetectType === 'nearest') {\n            this.onMousemoveNearestType(responders, mousePosition);\n        }\n        else if (includes(['near', 'point'], this.eventDetectType)) {\n            this.onMousemoveNearType(responders);\n        }\n        else {\n            this.onMousemoveGroupedType(responders);\n        }\n        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n        this.eventBus.emit('needDraw');\n    }\n    getDataLabels(seriesModels) {\n        const dataLabelTheme = this.theme.dataLabels;\n        return seriesModels.flatMap(({ points, name, color }) => points.map((point) => isNull(point)\n            ? {}\n            : Object.assign(Object.assign({ type: 'point' }, point), { name, theme: Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? color : dataLabelTheme.color }) })));\n    }\n    getResponderSeriesWithTheme(models, type) {\n        const { radius, color, borderWidth, borderColor } = this.theme[type].dot;\n        return models.map((model) => {\n            const modelColor = (color !== null && color !== void 0 ? color : model.color);\n            return Object.assign(Object.assign({}, model), { radius, color: modelColor, style: [{ lineWidth: borderWidth, strokeStyle: (borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)) }] });\n        });\n    }\n    onClick({ responders, mousePosition }) {\n        if (this.selectable) {\n            let models;\n            if (this.eventDetectType === 'near') {\n                models = responders;\n            }\n            else {\n                models = this.getCircleModelsFromRectResponders(responders, mousePosition);\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models: this.getResponderSeriesWithTheme(models, 'select'),\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        }\n    }\n    getResponderCategoryByIndex(index) {\n        var _a, _b;\n        const responder = Object.values(this.tooltipCircleMap)\n            .flatMap((val) => val)\n            .find((model) => model.index === index);\n        return (_b = (_a = responder) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.category;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}