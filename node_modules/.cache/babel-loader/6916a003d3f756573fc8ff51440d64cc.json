{"ast":null,"code":"import Component from \"./component\";\nimport { first, includes, hasNegative, deepCopyArray, last, hasNegativeOnly, hasPositiveOnly, isNull, isNumber, calculateSizeWithPercentString, omit } from \"../helpers/utils\";\nimport { makeTickPixelPositions, makeLabelsFromLimit } from \"../helpers/calculator\";\nimport { getRGBA, getAlpha } from \"../helpers/color\";\nimport { getDataInRange, isRangeData, isRangeValue } from \"../helpers/range\";\nimport { getLimitOnAxis, getValueAxisName } from \"../helpers/axes\";\nimport { calibrateDrawingValue } from \"../helpers/boxSeries\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getBoxTypeSeriesPadding } from \"../helpers/style\";\nimport { makeRectResponderModel } from \"../helpers/responders\";\nimport { message } from \"../message\";\nimport { isAvailableSelectSeries, isAvailableShowTooltipInfo } from \"../helpers/validation\";\nexport var SeriesDirection;\n\n(function (SeriesDirection) {\n  SeriesDirection[SeriesDirection[\"POSITIVE\"] = 0] = \"POSITIVE\";\n  SeriesDirection[SeriesDirection[\"NEGATIVE\"] = 1] = \"NEGATIVE\";\n  SeriesDirection[SeriesDirection[\"BOTH\"] = 2] = \"BOTH\";\n})(SeriesDirection || (SeriesDirection = {}));\n\nconst BOX = {\n  BAR: 'bar',\n  COLUMN: 'column'\n};\nexport function isLeftBottomSide(seriesIndex) {\n  return !!(seriesIndex % 2);\n}\n\nfunction calculateBarLength(value, min, max) {\n  if (isRangeValue(value)) {\n    let [start, end] = value;\n\n    if (start < min) {\n      start = min;\n    }\n\n    if (end > max) {\n      end = max;\n    }\n\n    return end - start;\n  }\n\n  return calibrateDrawingValue(value, min, max);\n}\n\nexport function isBoxSeries(seriesName) {\n  return includes(Object.values(BOX), seriesName);\n}\nexport default class BoxSeries extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      series: []\n    };\n    this.activatedResponders = [];\n    this.isBar = true;\n    this.valueAxis = 'xAxis';\n    this.labelAxis = 'yAxis';\n    this.anchorSizeKey = 'height';\n    this.offsetSizeKey = 'width';\n    this.basePosition = 0;\n    this.leftBasePosition = 0;\n    this.rightBasePosition = 0;\n    this.isRangeData = false;\n    this.offsetKey = 'x';\n    this.eventDetectType = 'point';\n\n    this.onMouseoutComponent = () => {\n      this.eventBus.emit('seriesPointHovered', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('renderHoveredSeries', {\n        models: [],\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.selectSeries = info => {\n      const {\n        index,\n        seriesIndex\n      } = info;\n\n      if (!isAvailableSelectSeries(info, 'column')) {\n        return;\n      }\n\n      const model = this.tooltipRectMap[seriesIndex][index];\n\n      if (!model) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models: this.getRespondersWithTheme([model], 'select'),\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.showTooltip = info => {\n      const {\n        index,\n        seriesIndex\n      } = info;\n\n      if (!isAvailableShowTooltipInfo(info, this.eventDetectType, 'column')) {\n        return;\n      }\n\n      const models = this.eventDetectType === 'grouped' ? this.getGroupedRect([this.responders[index]], 'hover') : this.getRespondersWithTheme([this.tooltipRectMap[index][seriesIndex]], 'hover');\n\n      if (!models.length) {\n        return;\n      }\n\n      this.eventBus.emit('renderHoveredSeries', {\n        models,\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.activatedResponders = this.eventDetectType === 'grouped' ? this.tooltipRectMap[index] : models;\n      this.eventBus.emit('seriesPointHovered', {\n        models: this.activatedResponders,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  initialize({\n    name,\n    stackChart\n  }) {\n    this.initializeFields(name);\n\n    if (!stackChart) {\n      this.eventBus.on('selectSeries', this.selectSeries);\n      this.eventBus.on('showTooltip', this.showTooltip);\n      this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n    }\n  }\n\n  initializeFields(name) {\n    this.type = 'series';\n    this.name = name;\n    this.isBar = name === BOX.BAR;\n    this.offsetKey = this.isBar ? 'x' : 'y';\n    this.valueAxis = this.isBar ? 'xAxis' : 'yAxis';\n    this.labelAxis = this.isBar ? 'yAxis' : 'xAxis';\n    this.anchorSizeKey = this.isBar ? 'height' : 'width';\n    this.offsetSizeKey = this.isBar ? 'width' : 'height';\n  }\n\n  initUpdate(delta) {\n    if (!this.drawModels) {\n      return;\n    }\n\n    if (this.isRangeData) {\n      this.initUpdateRangeData(delta);\n      return;\n    }\n\n    this.initUpdateClipRect(delta);\n    this.initUpdateConnector(delta);\n  }\n\n  initUpdateRangeData(delta) {\n    const {\n      series\n    } = this.drawModels;\n    this.drawModels.clipRect = this.models.clipRect;\n    const target = this.models.series;\n    series.forEach((current, index) => {\n      const targetModel = target[index];\n\n      if (delta === 0) {\n        current[this.offsetSizeKey] = 0;\n      }\n\n      const offsetSize = current[this.offsetSizeKey] + (targetModel[this.offsetSizeKey] - current[this.offsetSizeKey]) * delta;\n      current[this.offsetSizeKey] = offsetSize;\n\n      if (!this.isBar) {\n        current[this.offsetKey] = targetModel[this.offsetKey] + targetModel[this.offsetSizeKey] - offsetSize;\n      }\n    });\n  }\n\n  initUpdateClipRect(delta) {\n    const {\n      clipRect\n    } = this.drawModels;\n\n    if (!clipRect) {\n      return;\n    }\n\n    const current = clipRect[0];\n    const key = this.offsetSizeKey;\n    const target = this.models.clipRect[0];\n    const offsetSize = current[key] + (target[key] - current[key]) * delta;\n    current[key] = offsetSize;\n    current[this.offsetKey] = Math.max(this.basePosition - offsetSize * this.basePosition / target[key], 0);\n  }\n\n  initUpdateConnector(delta) {\n    const {\n      connector\n    } = this.drawModels;\n\n    if (!connector) {\n      return;\n    }\n\n    const target = this.models.connector;\n    connector.forEach((current, index) => {\n      const alpha = getAlpha(target[index].strokeStyle) * delta;\n      current.strokeStyle = getRGBA(current.strokeStyle, alpha);\n    });\n  }\n\n  setEventDetectType(series, options) {\n    var _a, _b;\n\n    if (series.line) {\n      this.eventDetectType = 'grouped';\n    }\n\n    if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n      this.eventDetectType = options.series.eventDetectType;\n    }\n  }\n\n  getOptions(chartOptions) {\n    var _a;\n\n    const options = Object.assign({}, chartOptions);\n\n    if (((_a = options) === null || _a === void 0 ? void 0 : _a.series) && options.series.column) {\n      options.series = Object.assign(Object.assign({}, options.series), options.series.column);\n    }\n\n    return options;\n  }\n\n  render(chartState, computed) {\n    var _a, _b;\n\n    const {\n      layout,\n      series,\n      axes,\n      stackSeries,\n      legend,\n      theme,\n      scale\n    } = chartState;\n    this.isShow = !(stackSeries && stackSeries[this.name]);\n\n    if (!this.isShow) {\n      return;\n    }\n\n    const categories = (_a = chartState.categories, _a !== null && _a !== void 0 ? _a : []);\n    const options = this.getOptions(chartState.options);\n    this.setEventDetectType(series, options);\n    this.theme = theme.series[this.name];\n    this.rect = layout.plot;\n    this.activeSeriesMap = getActiveSeriesMap(legend);\n    this.selectable = this.getSelectableOption(options);\n    this.valueAxis = getValueAxisName(options, this.name, this.isBar ? 'xAxis' : 'yAxis');\n    const seriesData = series[this.name].data.map(seriesDatum => Object.assign(Object.assign({}, seriesDatum), {\n      data: getDataInRange(seriesDatum.data, computed.viewRange)\n    }));\n\n    if (axes.centerYAxis) {\n      this.valueAxis = 'centerYAxis';\n    }\n\n    const {\n      tickDistance\n    } = axes[this.labelAxis];\n    const diverging = !!((_b = options.series) === null || _b === void 0 ? void 0 : _b.diverging);\n    const {\n      limit,\n      stepSize\n    } = this.getScaleData(scale);\n    const labels = makeLabelsFromLimit(limit, stepSize);\n    const {\n      min,\n      max\n    } = getLimitOnAxis(labels);\n    this.basePosition = this.getBasePosition(axes[this.valueAxis]);\n    let offsetSize = this.getOffsetSize();\n    const {\n      centerYAxis\n    } = axes;\n\n    if (diverging) {\n      const [left, right] = this.getDivergingBasePosition(centerYAxis);\n      this.basePosition = this.getOffsetSize() / 2;\n      this.leftBasePosition = left;\n      this.rightBasePosition = right;\n      offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);\n    }\n\n    const renderOptions = {\n      min,\n      max,\n      tickDistance,\n      diverging,\n      ratio: this.getValueRatio(min, max, offsetSize),\n      hasNegativeValue: hasNegative(labels),\n      seriesDirection: this.getSeriesDirection(labels),\n      defaultPadding: getBoxTypeSeriesPadding(tickDistance)\n    };\n    const seriesModels = this.renderSeriesModel(seriesData, renderOptions);\n    const tooltipData = this.makeTooltipData(seriesData, renderOptions, categories);\n    const clipRect = this.renderClipRectAreaModel();\n    this.models = {\n      clipRect: [clipRect],\n      series: seriesModels\n    };\n\n    if (!this.drawModels) {\n      this.drawModels = {\n        clipRect: [this.initClipRect(clipRect)],\n        series: deepCopyArray(seriesModels)\n      };\n    }\n\n    if (getDataLabelsOptions(options, this.name).visible) {\n      const dataLabelData = seriesModels.reduce((acc, data) => {\n        return isRangeValue(data.value) ? [...acc, ...this.makeDataLabelRangeData(data)] : [...acc, this.makeDataLabel(data, centerYAxis)];\n      }, []);\n      this.renderDataLabels(dataLabelData);\n    }\n\n    this.tooltipRectMap = this.makeTooltipRectMap(seriesModels, tooltipData);\n    this.responders = this.getBoxSeriesResponders(seriesModels, tooltipData, axes, categories);\n  }\n\n  getScaleData(scale) {\n    return scale[this.valueAxis === 'centerYAxis' ? 'xAxis' : this.valueAxis];\n  }\n\n  getBoxSeriesResponders(seriesModels, tooltipData, axes, categories) {\n    const hoveredSeries = this.renderHoveredSeriesModel(seriesModels);\n    return this.eventDetectType === 'grouped' ? makeRectResponderModel(this.rect, this.isBar ? axes.yAxis : axes.xAxis, categories, !this.isBar) : hoveredSeries.map((m, index) => Object.assign(Object.assign({}, m), {\n      data: tooltipData[index]\n    }));\n  }\n\n  makeTooltipRectMap(seriesModels, tooltipDataArr) {\n    return seriesModels.reduce((acc, cur, dataIndex) => {\n      const index = cur.index;\n      const tooltipModel = Object.assign(Object.assign({}, cur), {\n        data: tooltipDataArr[dataIndex]\n      });\n\n      if (!acc[index]) {\n        acc[index] = [];\n      }\n\n      acc[index].push(tooltipModel);\n      return acc;\n    }, []);\n  }\n\n  renderClipRectAreaModel() {\n    return {\n      type: 'clipRectArea',\n      x: 0,\n      y: 0,\n      width: this.rect.width,\n      height: this.rect.height\n    };\n  }\n\n  initClipRect(clipRect) {\n    return {\n      type: 'clipRectArea',\n      width: this.isBar ? 0 : clipRect.width,\n      height: this.isBar ? clipRect.height : 0,\n      x: this.isBar ? 0 : clipRect.x,\n      y: this.isBar ? clipRect.y : 0\n    };\n  }\n\n  renderSeriesModel(seriesData, renderOptions) {\n    const {\n      tickDistance,\n      diverging\n    } = renderOptions;\n    const seriesLength = seriesData.length;\n    const validDiverging = diverging && seriesData.length === 2;\n    const columnWidth = this.getColumnWidth(renderOptions, seriesLength, validDiverging);\n    const seriesModels = [];\n    const padding = (tickDistance - columnWidth * (validDiverging ? 1 : seriesLength)) / 2;\n    seriesData.forEach(({\n      data,\n      color: seriesColor,\n      name\n    }, seriesIndex) => {\n      const seriesPos = (diverging ? 0 : seriesIndex) * columnWidth + padding;\n      const isLBSideWithDiverging = diverging && isLeftBottomSide(seriesIndex);\n      this.isRangeData = isRangeData(data);\n      data.forEach((value, index) => {\n        const dataStart = seriesPos + index * tickDistance;\n        const barLength = this.makeBarLength(value, renderOptions);\n        const color = this.getSeriesColor(name, seriesColor);\n\n        if (isNumber(barLength)) {\n          const startPosition = this.getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging);\n          seriesModels.push(Object.assign(Object.assign({\n            type: 'rect',\n            color,\n            value\n          }, this.getAdjustedRect(dataStart, startPosition, barLength, columnWidth)), {\n            name,\n            index\n          }));\n        }\n      });\n    });\n    return seriesModels;\n  }\n\n  renderHoveredSeriesModel(seriesModel) {\n    return seriesModel.map(data => {\n      return this.makeHoveredSeriesModel(data);\n    });\n  }\n\n  makeHoveredSeriesModel(data) {\n    const {\n      x,\n      y,\n      width,\n      height,\n      color,\n      index\n    } = data;\n    return {\n      type: 'rect',\n      color: getRGBA(color, 1),\n      x,\n      y,\n      width,\n      height,\n      index\n    };\n  }\n\n  getRectModelsFromRectResponders(responders) {\n    var _a;\n\n    if (!responders.length) {\n      return [];\n    }\n\n    return _a = this.tooltipRectMap[responders[0].index], _a !== null && _a !== void 0 ? _a : [];\n  }\n\n  getGroupedRect(responders, type) {\n    const rectModels = this.getRectModelsFromRectResponders(responders);\n    const {\n      color,\n      opacity\n    } = this.theme[type].groupedRect;\n    return rectModels.length ? responders.map(m => Object.assign(Object.assign({}, m), {\n      color: getRGBA(color, opacity)\n    })) : [];\n  }\n\n  onMousemoveGroupedType(responders) {\n    const rectModels = this.getRectModelsFromRectResponders(responders);\n    this.eventBus.emit('renderHoveredSeries', {\n      models: this.getGroupedRect(responders, 'hover'),\n      name: this.name,\n      eventDetectType: this.eventDetectType\n    });\n    this.activatedResponders = rectModels;\n  }\n\n  onMousemove({\n    responders\n  }) {\n    if (this.eventDetectType === 'grouped') {\n      this.onMousemoveGroupedType(responders);\n    } else {\n      this.eventBus.emit('renderHoveredSeries', {\n        models: this.getRespondersWithTheme(responders, 'hover'),\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.activatedResponders = responders;\n    }\n\n    this.eventBus.emit('seriesPointHovered', {\n      models: this.activatedResponders,\n      name: this.name\n    });\n    this.eventBus.emit('needDraw');\n  }\n\n  makeTooltipData(seriesData, renderOptions, categories) {\n    const tooltipData = [];\n    seriesData.forEach(({\n      data,\n      name,\n      color\n    }) => {\n      data.forEach((value, dataIndex) => {\n        if (!isNull(value)) {\n          const barLength = this.makeBarLength(value, renderOptions);\n\n          if (isNumber(barLength)) {\n            tooltipData.push({\n              label: name,\n              color,\n              value: this.getTooltipValue(value),\n              category: categories.length ? categories[dataIndex] : ''\n            });\n          }\n        }\n      });\n    });\n    return tooltipData;\n  }\n\n  getTooltipValue(value) {\n    return isRangeValue(value) ? `${value[0]} ~ ${value[1]}` : value;\n  }\n\n  getBasePosition({\n    labels,\n    tickCount,\n    zeroPosition\n  }) {\n    const valueLabels = this.isBar ? labels : [...labels].reverse();\n    const tickPositions = makeTickPixelPositions(this.getOffsetSize(), tickCount);\n    const seriesDirection = this.getSeriesDirection(valueLabels);\n    return zeroPosition ? zeroPosition : this.getTickPositionIfNotZero(tickPositions, seriesDirection);\n  }\n\n  getDivergingBasePosition(centerYAxis) {\n    let leftZeroPosition, rightZeroPosition;\n\n    if (centerYAxis) {\n      leftZeroPosition = centerYAxis.xAxisHalfSize;\n      rightZeroPosition = centerYAxis.secondStartX;\n    } else {\n      const divergingZeroPosition = this.getOffsetSize() / 2;\n      leftZeroPosition = rightZeroPosition = divergingZeroPosition;\n    }\n\n    return [leftZeroPosition, rightZeroPosition];\n  }\n\n  getOffsetSize() {\n    return this.rect[this.offsetSizeKey];\n  }\n\n  getValueRatio(min, max, size) {\n    return size / (max - min);\n  }\n\n  makeBarLength(value, renderOptions) {\n    if (isNull(value)) {\n      return null;\n    }\n\n    const {\n      min,\n      max,\n      ratio\n    } = renderOptions;\n    const calculatedValue = calculateBarLength(value, min, max);\n    return Math.max(this.getBarLength(calculatedValue, ratio), 2);\n  }\n\n  getBarLength(value, ratio) {\n    return value < 0 ? Math.abs(value) * ratio : value * ratio;\n  }\n\n  getStartPositionWithRangeValue(value, barLength, renderOptions) {\n    const {\n      min,\n      ratio\n    } = renderOptions;\n    let [start] = value;\n\n    if (start < min) {\n      start = min;\n    }\n\n    const startPosition = (start - min) * ratio;\n    return this.isBar ? startPosition : this.getOffsetSize() - startPosition - barLength;\n  }\n\n  getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging) {\n    const {\n      diverging,\n      seriesDirection\n    } = renderOptions;\n    let startPos;\n\n    if (isRangeValue(value)) {\n      startPos = this.getStartPositionWithRangeValue(value, barLength, renderOptions);\n    } else if (diverging) {\n      startPos = isLBSideWithDiverging ? this.getStartPosOnLeftBottomSide(barLength, diverging) : this.getStartPosOnRightTopSide(barLength, diverging);\n    } else if (seriesDirection === SeriesDirection.POSITIVE) {\n      startPos = this.getStartPosOnRightTopSide(barLength);\n    } else if (seriesDirection === SeriesDirection.NEGATIVE) {\n      startPos = this.getStartPosOnLeftBottomSide(barLength);\n    } else {\n      startPos = value < 0 ? this.getStartPosOnLeftBottomSide(barLength) : this.getStartPosOnRightTopSide(barLength);\n    }\n\n    return startPos;\n  }\n\n  getStartPosOnRightTopSide(barLength, diverging = false) {\n    let pos;\n\n    if (diverging) {\n      pos = this.isBar ? this.rightBasePosition : this.rightBasePosition - barLength;\n    } else {\n      pos = this.isBar ? this.basePosition : this.basePosition - barLength;\n    }\n\n    return pos;\n  }\n\n  getStartPosOnLeftBottomSide(barLength, diverging = false) {\n    let pos;\n\n    if (diverging) {\n      pos = this.isBar ? this.leftBasePosition - barLength : this.leftBasePosition;\n    } else {\n      pos = this.isBar ? this.basePosition - barLength : this.basePosition;\n    }\n\n    return pos;\n  }\n\n  getAdjustedRect(seriesPosition, dataPosition, barLength, columnWidth) {\n    return {\n      x: this.isBar ? dataPosition : seriesPosition,\n      y: this.isBar ? seriesPosition : dataPosition,\n      width: this.isBar ? barLength : columnWidth,\n      height: this.isBar ? columnWidth : barLength\n    };\n  }\n\n  getColumnWidth(renderOptions, seriesLength, validDiverging = false) {\n    const {\n      tickDistance,\n      defaultPadding\n    } = renderOptions;\n    seriesLength = validDiverging ? 1 : seriesLength;\n    const themeBarWidth = this.theme.barWidth;\n    return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / seriesLength;\n  }\n\n  getSeriesDirection(labels) {\n    let result = SeriesDirection.BOTH;\n\n    if (hasPositiveOnly(labels)) {\n      result = SeriesDirection.POSITIVE;\n    } else if (hasNegativeOnly(labels)) {\n      result = SeriesDirection.NEGATIVE;\n    }\n\n    return result;\n  }\n\n  getTickPositionIfNotZero(tickPositions, direction) {\n    const firstTickPosition = Number(first(tickPositions));\n    const lastTickPosition = Number(last(tickPositions));\n    let tickPos = 0;\n\n    if (direction === SeriesDirection.POSITIVE) {\n      tickPos = this.isBar ? firstTickPosition : lastTickPosition;\n    } else if (direction === SeriesDirection.NEGATIVE) {\n      tickPos = this.isBar ? lastTickPosition : firstTickPosition;\n    }\n\n    return tickPos;\n  }\n\n  makeDataLabel(rect, centerYAxis) {\n    return Object.assign(Object.assign({}, rect), {\n      direction: this.getDataLabelDirection(rect, centerYAxis),\n      plot: {\n        x: 0,\n        y: 0,\n        size: this.getOffsetSize()\n      },\n      theme: omit(this.theme.dataLabels, 'stackTotal')\n    });\n  }\n\n  makeDataLabelRangeData(rect) {\n    return rect.value.reduce((acc, value, index) => [...acc, Object.assign(Object.assign({}, rect), {\n      value,\n      direction: this.getDataLabelRangeDataDirection(index % 2 === 0),\n      plot: {\n        x: 0,\n        y: 0,\n        size: this.getOffsetSize()\n      },\n      theme: omit(this.theme.dataLabels, 'stackTotal')\n    })], []);\n  }\n\n  getDataLabelRangeDataDirection(isEven) {\n    let direction;\n\n    if (this.isBar) {\n      direction = isEven ? 'left' : 'right';\n    } else {\n      direction = isEven ? 'bottom' : 'top';\n    }\n\n    return direction;\n  }\n\n  getDataLabelDirection(rect, centerYAxis) {\n    let direction;\n\n    if (this.isBar) {\n      const basePos = centerYAxis ? this.leftBasePosition : this.basePosition;\n      direction = rect.x < basePos ? 'left' : 'right';\n    } else {\n      direction = rect.y >= this.basePosition ? 'bottom' : 'top';\n    }\n\n    return direction;\n  }\n\n  getOffsetSizeWithDiverging(centerYAxis) {\n    return centerYAxis ? centerYAxis.xAxisHalfSize : this.getOffsetSize() / 2;\n  }\n\n  onClick({\n    responders\n  }) {\n    if (this.selectable) {\n      let models;\n\n      if (this.eventDetectType === 'grouped') {\n        models = [...this.getGroupedRect(responders, 'select'), ...this.getRectModelsFromRectResponders(responders)];\n      } else {\n        models = this.getRespondersWithTheme(responders, 'select');\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models,\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    }\n  }\n\n  getRespondersWithTheme(responders, type) {\n    const {\n      color,\n      borderColor,\n      borderWidth,\n      shadowBlur,\n      shadowColor,\n      shadowOffsetX,\n      shadowOffsetY\n    } = this.theme[type];\n    return responders.map(model => Object.assign(Object.assign({}, model), {\n      color: color !== null && color !== void 0 ? color : model.color,\n      thickness: borderWidth,\n      borderColor,\n      style: [{\n        shadowBlur,\n        shadowColor,\n        shadowOffsetX,\n        shadowOffsetY\n      }]\n    }));\n  }\n\n  getSeriesColor(name, color) {\n    const {\n      select,\n      areaOpacity\n    } = this.theme;\n    const active = this.activeSeriesMap[name];\n    const selected = Object.values(this.activeSeriesMap).some(elem => !elem);\n    return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/boxSeries.js"],"names":["Component","first","includes","hasNegative","deepCopyArray","last","hasNegativeOnly","hasPositiveOnly","isNull","isNumber","calculateSizeWithPercentString","omit","makeTickPixelPositions","makeLabelsFromLimit","getRGBA","getAlpha","getDataInRange","isRangeData","isRangeValue","getLimitOnAxis","getValueAxisName","calibrateDrawingValue","getDataLabelsOptions","getActiveSeriesMap","getBoxTypeSeriesPadding","makeRectResponderModel","message","isAvailableSelectSeries","isAvailableShowTooltipInfo","SeriesDirection","BOX","BAR","COLUMN","isLeftBottomSide","seriesIndex","calculateBarLength","value","min","max","start","end","isBoxSeries","seriesName","Object","values","BoxSeries","constructor","arguments","models","series","activatedResponders","isBar","valueAxis","labelAxis","anchorSizeKey","offsetSizeKey","basePosition","leftBasePosition","rightBasePosition","offsetKey","eventDetectType","onMouseoutComponent","eventBus","emit","name","selectSeries","info","index","model","tooltipRectMap","Error","SELECT_SERIES_API_INDEX_ERROR","getRespondersWithTheme","showTooltip","getGroupedRect","responders","length","initialize","stackChart","initializeFields","on","type","initUpdate","delta","drawModels","initUpdateRangeData","initUpdateClipRect","initUpdateConnector","clipRect","target","forEach","current","targetModel","offsetSize","key","Math","connector","alpha","strokeStyle","setEventDetectType","options","_a","_b","line","getOptions","chartOptions","assign","column","render","chartState","computed","layout","axes","stackSeries","legend","theme","scale","isShow","categories","rect","plot","activeSeriesMap","selectable","getSelectableOption","seriesData","data","map","seriesDatum","viewRange","centerYAxis","tickDistance","diverging","limit","stepSize","getScaleData","labels","getBasePosition","getOffsetSize","left","right","getDivergingBasePosition","getOffsetSizeWithDiverging","renderOptions","ratio","getValueRatio","hasNegativeValue","seriesDirection","getSeriesDirection","defaultPadding","seriesModels","renderSeriesModel","tooltipData","makeTooltipData","renderClipRectAreaModel","initClipRect","visible","dataLabelData","reduce","acc","makeDataLabelRangeData","makeDataLabel","renderDataLabels","makeTooltipRectMap","getBoxSeriesResponders","hoveredSeries","renderHoveredSeriesModel","yAxis","xAxis","m","tooltipDataArr","cur","dataIndex","tooltipModel","push","x","y","width","height","seriesLength","validDiverging","columnWidth","getColumnWidth","padding","color","seriesColor","seriesPos","isLBSideWithDiverging","dataStart","barLength","makeBarLength","getSeriesColor","startPosition","getStartPosition","getAdjustedRect","seriesModel","makeHoveredSeriesModel","getRectModelsFromRectResponders","rectModels","opacity","groupedRect","onMousemoveGroupedType","onMousemove","label","getTooltipValue","category","tickCount","zeroPosition","valueLabels","reverse","tickPositions","getTickPositionIfNotZero","leftZeroPosition","rightZeroPosition","xAxisHalfSize","secondStartX","divergingZeroPosition","size","calculatedValue","getBarLength","abs","getStartPositionWithRangeValue","startPos","getStartPosOnLeftBottomSide","getStartPosOnRightTopSide","POSITIVE","NEGATIVE","pos","seriesPosition","dataPosition","themeBarWidth","barWidth","result","BOTH","direction","firstTickPosition","Number","lastTickPosition","tickPos","getDataLabelDirection","dataLabels","getDataLabelRangeDataDirection","isEven","basePos","onClick","borderColor","borderWidth","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","thickness","style","select","areaOpacity","active","selected","some","elem","restSeries"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { first, includes, hasNegative, deepCopyArray, last, hasNegativeOnly, hasPositiveOnly, isNull, isNumber, calculateSizeWithPercentString, omit, } from \"../helpers/utils\";\nimport { makeTickPixelPositions, makeLabelsFromLimit } from \"../helpers/calculator\";\nimport { getRGBA, getAlpha } from \"../helpers/color\";\nimport { getDataInRange, isRangeData, isRangeValue } from \"../helpers/range\";\nimport { getLimitOnAxis, getValueAxisName } from \"../helpers/axes\";\nimport { calibrateDrawingValue } from \"../helpers/boxSeries\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getBoxTypeSeriesPadding } from \"../helpers/style\";\nimport { makeRectResponderModel } from \"../helpers/responders\";\nimport { message } from \"../message\";\nimport { isAvailableSelectSeries, isAvailableShowTooltipInfo } from \"../helpers/validation\";\nexport var SeriesDirection;\n(function (SeriesDirection) {\n    SeriesDirection[SeriesDirection[\"POSITIVE\"] = 0] = \"POSITIVE\";\n    SeriesDirection[SeriesDirection[\"NEGATIVE\"] = 1] = \"NEGATIVE\";\n    SeriesDirection[SeriesDirection[\"BOTH\"] = 2] = \"BOTH\";\n})(SeriesDirection || (SeriesDirection = {}));\nconst BOX = {\n    BAR: 'bar',\n    COLUMN: 'column',\n};\nexport function isLeftBottomSide(seriesIndex) {\n    return !!(seriesIndex % 2);\n}\nfunction calculateBarLength(value, min, max) {\n    if (isRangeValue(value)) {\n        let [start, end] = value;\n        if (start < min) {\n            start = min;\n        }\n        if (end > max) {\n            end = max;\n        }\n        return end - start;\n    }\n    return calibrateDrawingValue(value, min, max);\n}\nexport function isBoxSeries(seriesName) {\n    return includes(Object.values(BOX), seriesName);\n}\nexport default class BoxSeries extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { series: [] };\n        this.activatedResponders = [];\n        this.isBar = true;\n        this.valueAxis = 'xAxis';\n        this.labelAxis = 'yAxis';\n        this.anchorSizeKey = 'height';\n        this.offsetSizeKey = 'width';\n        this.basePosition = 0;\n        this.leftBasePosition = 0;\n        this.rightBasePosition = 0;\n        this.isRangeData = false;\n        this.offsetKey = 'x';\n        this.eventDetectType = 'point';\n        this.onMouseoutComponent = () => {\n            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });\n            this.eventBus.emit('renderHoveredSeries', {\n                models: [],\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.selectSeries = (info) => {\n            const { index, seriesIndex } = info;\n            if (!isAvailableSelectSeries(info, 'column')) {\n                return;\n            }\n            const model = this.tooltipRectMap[seriesIndex][index];\n            if (!model) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models: this.getRespondersWithTheme([model], 'select'),\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.showTooltip = (info) => {\n            const { index, seriesIndex } = info;\n            if (!isAvailableShowTooltipInfo(info, this.eventDetectType, 'column')) {\n                return;\n            }\n            const models = this.eventDetectType === 'grouped'\n                ? this.getGroupedRect([this.responders[index]], 'hover')\n                : this.getRespondersWithTheme([this.tooltipRectMap[index][seriesIndex]], 'hover');\n            if (!models.length) {\n                return;\n            }\n            this.eventBus.emit('renderHoveredSeries', {\n                models,\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.activatedResponders =\n                this.eventDetectType === 'grouped' ? this.tooltipRectMap[index] : models;\n            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n    }\n    initialize({ name, stackChart }) {\n        this.initializeFields(name);\n        if (!stackChart) {\n            this.eventBus.on('selectSeries', this.selectSeries);\n            this.eventBus.on('showTooltip', this.showTooltip);\n            this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n        }\n    }\n    initializeFields(name) {\n        this.type = 'series';\n        this.name = name;\n        this.isBar = name === BOX.BAR;\n        this.offsetKey = this.isBar ? 'x' : 'y';\n        this.valueAxis = this.isBar ? 'xAxis' : 'yAxis';\n        this.labelAxis = this.isBar ? 'yAxis' : 'xAxis';\n        this.anchorSizeKey = this.isBar ? 'height' : 'width';\n        this.offsetSizeKey = this.isBar ? 'width' : 'height';\n    }\n    initUpdate(delta) {\n        if (!this.drawModels) {\n            return;\n        }\n        if (this.isRangeData) {\n            this.initUpdateRangeData(delta);\n            return;\n        }\n        this.initUpdateClipRect(delta);\n        this.initUpdateConnector(delta);\n    }\n    initUpdateRangeData(delta) {\n        const { series } = this.drawModels;\n        this.drawModels.clipRect = this.models.clipRect;\n        const target = this.models.series;\n        series.forEach((current, index) => {\n            const targetModel = target[index];\n            if (delta === 0) {\n                current[this.offsetSizeKey] = 0;\n            }\n            const offsetSize = current[this.offsetSizeKey] +\n                (targetModel[this.offsetSizeKey] - current[this.offsetSizeKey]) * delta;\n            current[this.offsetSizeKey] = offsetSize;\n            if (!this.isBar) {\n                current[this.offsetKey] =\n                    targetModel[this.offsetKey] + targetModel[this.offsetSizeKey] - offsetSize;\n            }\n        });\n    }\n    initUpdateClipRect(delta) {\n        const { clipRect } = this.drawModels;\n        if (!clipRect) {\n            return;\n        }\n        const current = clipRect[0];\n        const key = this.offsetSizeKey;\n        const target = this.models.clipRect[0];\n        const offsetSize = current[key] + (target[key] - current[key]) * delta;\n        current[key] = offsetSize;\n        current[this.offsetKey] = Math.max(this.basePosition - (offsetSize * this.basePosition) / target[key], 0);\n    }\n    initUpdateConnector(delta) {\n        const { connector } = this.drawModels;\n        if (!connector) {\n            return;\n        }\n        const target = this.models.connector;\n        connector.forEach((current, index) => {\n            const alpha = getAlpha(target[index].strokeStyle) * delta;\n            current.strokeStyle = getRGBA(current.strokeStyle, alpha);\n        });\n    }\n    setEventDetectType(series, options) {\n        var _a, _b;\n        if (series.line) {\n            this.eventDetectType = 'grouped';\n        }\n        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n            this.eventDetectType = options.series.eventDetectType;\n        }\n    }\n    getOptions(chartOptions) {\n        var _a;\n        const options = Object.assign({}, chartOptions);\n        if (((_a = options) === null || _a === void 0 ? void 0 : _a.series) && options.series.column) {\n            options.series = Object.assign(Object.assign({}, options.series), options.series.column);\n        }\n        return options;\n    }\n    render(chartState, computed) {\n        var _a, _b;\n        const { layout, series, axes, stackSeries, legend, theme, scale } = chartState;\n        this.isShow = !(stackSeries && stackSeries[this.name]);\n        if (!this.isShow) {\n            return;\n        }\n        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));\n        const options = this.getOptions(chartState.options);\n        this.setEventDetectType(series, options);\n        this.theme = theme.series[this.name];\n        this.rect = layout.plot;\n        this.activeSeriesMap = getActiveSeriesMap(legend);\n        this.selectable = this.getSelectableOption(options);\n        this.valueAxis = getValueAxisName(options, this.name, this.isBar ? 'xAxis' : 'yAxis');\n        const seriesData = series[this.name].data.map((seriesDatum) => (Object.assign(Object.assign({}, seriesDatum), { data: getDataInRange(seriesDatum.data, computed.viewRange) })));\n        if (axes.centerYAxis) {\n            this.valueAxis = 'centerYAxis';\n        }\n        const { tickDistance } = axes[this.labelAxis];\n        const diverging = !!((_b = options.series) === null || _b === void 0 ? void 0 : _b.diverging);\n        const { limit, stepSize } = this.getScaleData(scale);\n        const labels = makeLabelsFromLimit(limit, stepSize);\n        const { min, max } = getLimitOnAxis(labels);\n        this.basePosition = this.getBasePosition(axes[this.valueAxis]);\n        let offsetSize = this.getOffsetSize();\n        const { centerYAxis } = axes;\n        if (diverging) {\n            const [left, right] = this.getDivergingBasePosition(centerYAxis);\n            this.basePosition = this.getOffsetSize() / 2;\n            this.leftBasePosition = left;\n            this.rightBasePosition = right;\n            offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);\n        }\n        const renderOptions = {\n            min,\n            max,\n            tickDistance,\n            diverging,\n            ratio: this.getValueRatio(min, max, offsetSize),\n            hasNegativeValue: hasNegative(labels),\n            seriesDirection: this.getSeriesDirection(labels),\n            defaultPadding: getBoxTypeSeriesPadding(tickDistance),\n        };\n        const seriesModels = this.renderSeriesModel(seriesData, renderOptions);\n        const tooltipData = this.makeTooltipData(seriesData, renderOptions, categories);\n        const clipRect = this.renderClipRectAreaModel();\n        this.models = {\n            clipRect: [clipRect],\n            series: seriesModels,\n        };\n        if (!this.drawModels) {\n            this.drawModels = {\n                clipRect: [this.initClipRect(clipRect)],\n                series: deepCopyArray(seriesModels),\n            };\n        }\n        if (getDataLabelsOptions(options, this.name).visible) {\n            const dataLabelData = seriesModels.reduce((acc, data) => {\n                return isRangeValue(data.value)\n                    ? [...acc, ...this.makeDataLabelRangeData(data)]\n                    : [...acc, this.makeDataLabel(data, centerYAxis)];\n            }, []);\n            this.renderDataLabels(dataLabelData);\n        }\n        this.tooltipRectMap = this.makeTooltipRectMap(seriesModels, tooltipData);\n        this.responders = this.getBoxSeriesResponders(seriesModels, tooltipData, axes, categories);\n    }\n    getScaleData(scale) {\n        return scale[this.valueAxis === 'centerYAxis' ? 'xAxis' : this.valueAxis];\n    }\n    getBoxSeriesResponders(seriesModels, tooltipData, axes, categories) {\n        const hoveredSeries = this.renderHoveredSeriesModel(seriesModels);\n        return this.eventDetectType === 'grouped'\n            ? makeRectResponderModel(this.rect, this.isBar ? axes.yAxis : axes.xAxis, categories, !this.isBar)\n            : hoveredSeries.map((m, index) => (Object.assign(Object.assign({}, m), { data: tooltipData[index] })));\n    }\n    makeTooltipRectMap(seriesModels, tooltipDataArr) {\n        return seriesModels.reduce((acc, cur, dataIndex) => {\n            const index = cur.index;\n            const tooltipModel = Object.assign(Object.assign({}, cur), { data: tooltipDataArr[dataIndex] });\n            if (!acc[index]) {\n                acc[index] = [];\n            }\n            acc[index].push(tooltipModel);\n            return acc;\n        }, []);\n    }\n    renderClipRectAreaModel() {\n        return {\n            type: 'clipRectArea',\n            x: 0,\n            y: 0,\n            width: this.rect.width,\n            height: this.rect.height,\n        };\n    }\n    initClipRect(clipRect) {\n        return {\n            type: 'clipRectArea',\n            width: this.isBar ? 0 : clipRect.width,\n            height: this.isBar ? clipRect.height : 0,\n            x: this.isBar ? 0 : clipRect.x,\n            y: this.isBar ? clipRect.y : 0,\n        };\n    }\n    renderSeriesModel(seriesData, renderOptions) {\n        const { tickDistance, diverging } = renderOptions;\n        const seriesLength = seriesData.length;\n        const validDiverging = diverging && seriesData.length === 2;\n        const columnWidth = this.getColumnWidth(renderOptions, seriesLength, validDiverging);\n        const seriesModels = [];\n        const padding = (tickDistance - columnWidth * (validDiverging ? 1 : seriesLength)) / 2;\n        seriesData.forEach(({ data, color: seriesColor, name }, seriesIndex) => {\n            const seriesPos = (diverging ? 0 : seriesIndex) * columnWidth + padding;\n            const isLBSideWithDiverging = diverging && isLeftBottomSide(seriesIndex);\n            this.isRangeData = isRangeData(data);\n            data.forEach((value, index) => {\n                const dataStart = seriesPos + index * tickDistance;\n                const barLength = this.makeBarLength(value, renderOptions);\n                const color = this.getSeriesColor(name, seriesColor);\n                if (isNumber(barLength)) {\n                    const startPosition = this.getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging);\n                    seriesModels.push(Object.assign(Object.assign({ type: 'rect', color,\n                        value }, this.getAdjustedRect(dataStart, startPosition, barLength, columnWidth)), { name,\n                        index }));\n                }\n            });\n        });\n        return seriesModels;\n    }\n    renderHoveredSeriesModel(seriesModel) {\n        return seriesModel.map((data) => {\n            return this.makeHoveredSeriesModel(data);\n        });\n    }\n    makeHoveredSeriesModel(data) {\n        const { x, y, width, height, color, index } = data;\n        return {\n            type: 'rect',\n            color: getRGBA(color, 1),\n            x,\n            y,\n            width,\n            height,\n            index,\n        };\n    }\n    getRectModelsFromRectResponders(responders) {\n        var _a;\n        if (!responders.length) {\n            return [];\n        }\n        return _a = this.tooltipRectMap[responders[0].index], (_a !== null && _a !== void 0 ? _a : []);\n    }\n    getGroupedRect(responders, type) {\n        const rectModels = this.getRectModelsFromRectResponders(responders);\n        const { color, opacity } = this.theme[type].groupedRect;\n        return rectModels.length\n            ? responders.map((m) => (Object.assign(Object.assign({}, m), { color: getRGBA(color, opacity) })))\n            : [];\n    }\n    onMousemoveGroupedType(responders) {\n        const rectModels = this.getRectModelsFromRectResponders(responders);\n        this.eventBus.emit('renderHoveredSeries', {\n            models: this.getGroupedRect(responders, 'hover'),\n            name: this.name,\n            eventDetectType: this.eventDetectType,\n        });\n        this.activatedResponders = rectModels;\n    }\n    onMousemove({ responders }) {\n        if (this.eventDetectType === 'grouped') {\n            this.onMousemoveGroupedType(responders);\n        }\n        else {\n            this.eventBus.emit('renderHoveredSeries', {\n                models: this.getRespondersWithTheme(responders, 'hover'),\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.activatedResponders = responders;\n        }\n        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n        this.eventBus.emit('needDraw');\n    }\n    makeTooltipData(seriesData, renderOptions, categories) {\n        const tooltipData = [];\n        seriesData.forEach(({ data, name, color }) => {\n            data.forEach((value, dataIndex) => {\n                if (!isNull(value)) {\n                    const barLength = this.makeBarLength(value, renderOptions);\n                    if (isNumber(barLength)) {\n                        tooltipData.push({\n                            label: name,\n                            color,\n                            value: this.getTooltipValue(value),\n                            category: categories.length ? categories[dataIndex] : '',\n                        });\n                    }\n                }\n            });\n        });\n        return tooltipData;\n    }\n    getTooltipValue(value) {\n        return isRangeValue(value) ? `${value[0]} ~ ${value[1]}` : value;\n    }\n    getBasePosition({ labels, tickCount, zeroPosition }) {\n        const valueLabels = this.isBar ? labels : [...labels].reverse();\n        const tickPositions = makeTickPixelPositions(this.getOffsetSize(), tickCount);\n        const seriesDirection = this.getSeriesDirection(valueLabels);\n        return zeroPosition\n            ? zeroPosition\n            : this.getTickPositionIfNotZero(tickPositions, seriesDirection);\n    }\n    getDivergingBasePosition(centerYAxis) {\n        let leftZeroPosition, rightZeroPosition;\n        if (centerYAxis) {\n            leftZeroPosition = centerYAxis.xAxisHalfSize;\n            rightZeroPosition = centerYAxis.secondStartX;\n        }\n        else {\n            const divergingZeroPosition = this.getOffsetSize() / 2;\n            leftZeroPosition = rightZeroPosition = divergingZeroPosition;\n        }\n        return [leftZeroPosition, rightZeroPosition];\n    }\n    getOffsetSize() {\n        return this.rect[this.offsetSizeKey];\n    }\n    getValueRatio(min, max, size) {\n        return size / (max - min);\n    }\n    makeBarLength(value, renderOptions) {\n        if (isNull(value)) {\n            return null;\n        }\n        const { min, max, ratio } = renderOptions;\n        const calculatedValue = calculateBarLength(value, min, max);\n        return Math.max(this.getBarLength(calculatedValue, ratio), 2);\n    }\n    getBarLength(value, ratio) {\n        return value < 0 ? Math.abs(value) * ratio : value * ratio;\n    }\n    getStartPositionWithRangeValue(value, barLength, renderOptions) {\n        const { min, ratio } = renderOptions;\n        let [start] = value;\n        if (start < min) {\n            start = min;\n        }\n        const startPosition = (start - min) * ratio;\n        return this.isBar ? startPosition : this.getOffsetSize() - startPosition - barLength;\n    }\n    getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging) {\n        const { diverging, seriesDirection } = renderOptions;\n        let startPos;\n        if (isRangeValue(value)) {\n            startPos = this.getStartPositionWithRangeValue(value, barLength, renderOptions);\n        }\n        else if (diverging) {\n            startPos = isLBSideWithDiverging\n                ? this.getStartPosOnLeftBottomSide(barLength, diverging)\n                : this.getStartPosOnRightTopSide(barLength, diverging);\n        }\n        else if (seriesDirection === SeriesDirection.POSITIVE) {\n            startPos = this.getStartPosOnRightTopSide(barLength);\n        }\n        else if (seriesDirection === SeriesDirection.NEGATIVE) {\n            startPos = this.getStartPosOnLeftBottomSide(barLength);\n        }\n        else {\n            startPos =\n                value < 0\n                    ? this.getStartPosOnLeftBottomSide(barLength)\n                    : this.getStartPosOnRightTopSide(barLength);\n        }\n        return startPos;\n    }\n    getStartPosOnRightTopSide(barLength, diverging = false) {\n        let pos;\n        if (diverging) {\n            pos = this.isBar ? this.rightBasePosition : this.rightBasePosition - barLength;\n        }\n        else {\n            pos = this.isBar ? this.basePosition : this.basePosition - barLength;\n        }\n        return pos;\n    }\n    getStartPosOnLeftBottomSide(barLength, diverging = false) {\n        let pos;\n        if (diverging) {\n            pos = this.isBar ? this.leftBasePosition - barLength : this.leftBasePosition;\n        }\n        else {\n            pos = this.isBar ? this.basePosition - barLength : this.basePosition;\n        }\n        return pos;\n    }\n    getAdjustedRect(seriesPosition, dataPosition, barLength, columnWidth) {\n        return {\n            x: this.isBar ? dataPosition : seriesPosition,\n            y: this.isBar ? seriesPosition : dataPosition,\n            width: this.isBar ? barLength : columnWidth,\n            height: this.isBar ? columnWidth : barLength,\n        };\n    }\n    getColumnWidth(renderOptions, seriesLength, validDiverging = false) {\n        const { tickDistance, defaultPadding } = renderOptions;\n        seriesLength = validDiverging ? 1 : seriesLength;\n        const themeBarWidth = this.theme.barWidth;\n        return themeBarWidth\n            ? calculateSizeWithPercentString(tickDistance, themeBarWidth)\n            : (tickDistance - defaultPadding * 2) / seriesLength;\n    }\n    getSeriesDirection(labels) {\n        let result = SeriesDirection.BOTH;\n        if (hasPositiveOnly(labels)) {\n            result = SeriesDirection.POSITIVE;\n        }\n        else if (hasNegativeOnly(labels)) {\n            result = SeriesDirection.NEGATIVE;\n        }\n        return result;\n    }\n    getTickPositionIfNotZero(tickPositions, direction) {\n        const firstTickPosition = Number(first(tickPositions));\n        const lastTickPosition = Number(last(tickPositions));\n        let tickPos = 0;\n        if (direction === SeriesDirection.POSITIVE) {\n            tickPos = this.isBar ? firstTickPosition : lastTickPosition;\n        }\n        else if (direction === SeriesDirection.NEGATIVE) {\n            tickPos = this.isBar ? lastTickPosition : firstTickPosition;\n        }\n        return tickPos;\n    }\n    makeDataLabel(rect, centerYAxis) {\n        return Object.assign(Object.assign({}, rect), { direction: this.getDataLabelDirection(rect, centerYAxis), plot: { x: 0, y: 0, size: this.getOffsetSize() }, theme: omit(this.theme.dataLabels, 'stackTotal') });\n    }\n    makeDataLabelRangeData(rect) {\n        return rect.value.reduce((acc, value, index) => [\n            ...acc,\n            Object.assign(Object.assign({}, rect), { value, direction: this.getDataLabelRangeDataDirection(index % 2 === 0), plot: { x: 0, y: 0, size: this.getOffsetSize() }, theme: omit(this.theme.dataLabels, 'stackTotal') }),\n        ], []);\n    }\n    getDataLabelRangeDataDirection(isEven) {\n        let direction;\n        if (this.isBar) {\n            direction = isEven ? 'left' : 'right';\n        }\n        else {\n            direction = isEven ? 'bottom' : 'top';\n        }\n        return direction;\n    }\n    getDataLabelDirection(rect, centerYAxis) {\n        let direction;\n        if (this.isBar) {\n            const basePos = centerYAxis ? this.leftBasePosition : this.basePosition;\n            direction = rect.x < basePos ? 'left' : 'right';\n        }\n        else {\n            direction = rect.y >= this.basePosition ? 'bottom' : 'top';\n        }\n        return direction;\n    }\n    getOffsetSizeWithDiverging(centerYAxis) {\n        return centerYAxis ? centerYAxis.xAxisHalfSize : this.getOffsetSize() / 2;\n    }\n    onClick({ responders }) {\n        if (this.selectable) {\n            let models;\n            if (this.eventDetectType === 'grouped') {\n                models = [\n                    ...this.getGroupedRect(responders, 'select'),\n                    ...this.getRectModelsFromRectResponders(responders),\n                ];\n            }\n            else {\n                models = this.getRespondersWithTheme(responders, 'select');\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models,\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        }\n    }\n    getRespondersWithTheme(responders, type) {\n        const { color, borderColor, borderWidth, shadowBlur, shadowColor, shadowOffsetX, shadowOffsetY, } = this.theme[type];\n        return responders.map((model) => (Object.assign(Object.assign({}, model), { color: (color !== null && color !== void 0 ? color : model.color), thickness: borderWidth, borderColor, style: [\n                {\n                    shadowBlur,\n                    shadowColor,\n                    shadowOffsetX,\n                    shadowOffsetY,\n                },\n            ] })));\n    }\n    getSeriesColor(name, color) {\n        const { select, areaOpacity } = this.theme;\n        const active = this.activeSeriesMap[name];\n        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);\n        return selected\n            ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity)\n            : getRGBA(color, areaOpacity);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}