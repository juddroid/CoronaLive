{"ast":null,"code":"import { isUndefined } from \"./helpers/utils\";\nimport { calculateRadianToDegree, withinRadian } from \"./helpers/sector\";\nexport const responderDetectors = {\n  circle: (mousePosition, model, componentRect) => {\n    const {\n      x,\n      y\n    } = mousePosition;\n    const {\n      x: modelX,\n      y: modelY,\n      radius,\n      detectionSize\n    } = model;\n    const {\n      x: compX,\n      y: compY\n    } = componentRect;\n    const radiusAdjustment = isUndefined(detectionSize) ? 10 : detectionSize;\n    return Math.pow(x - (modelX + compX), 2) + Math.pow(y - (modelY + compY), 2) < Math.pow(radius + radiusAdjustment, 2);\n  },\n  rect: (mousePosition, model, componentRect = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }) => {\n    const {\n      x,\n      y\n    } = mousePosition;\n    const {\n      x: modelX,\n      y: modelY,\n      width,\n      height\n    } = model;\n    const {\n      x: compX,\n      y: compY\n    } = componentRect;\n    return x >= modelX + compX && x <= modelX + compX + width && y >= modelY + compY && y <= modelY + compY + height;\n  },\n  sector: (mousePosition, model, componentRect = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }) => {\n    const {\n      x,\n      y\n    } = mousePosition;\n    const {\n      x: modelX,\n      y: modelY,\n      radius: {\n        outer,\n        inner\n      },\n      degree: {\n        start,\n        end\n      },\n      drawingStartAngle,\n      clockwise\n    } = model;\n    const {\n      x: compX,\n      y: compY\n    } = componentRect;\n    const xPos = x - (modelX + compX);\n    const yPos = y - (modelY + compY);\n    const insideOuterRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) < Math.pow(outer, 2);\n    const outsideInnerRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) > Math.pow(inner, 2);\n    const withinRadius = insideOuterRadius && outsideInnerRadius;\n    const detectionDegree = calculateRadianToDegree(Math.atan2(yPos, xPos), drawingStartAngle);\n    return withinRadius && withinRadian(clockwise, start, end, detectionDegree);\n  },\n  line: (mousePosition, model, componentRect = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }) => {\n    const {\n      x,\n      y\n    } = mousePosition;\n    const {\n      x: compX,\n      y: compY\n    } = componentRect;\n    const {\n      x: modelX,\n      y: modelY,\n      x2,\n      y2,\n      detectionSize = 3\n    } = model;\n    const numerator = y2 - modelY;\n    const denominator = x2 - modelX;\n    let result = false;\n\n    if (numerator === 0) {\n      // y = a\n      const minX = Math.min(modelX, x2);\n      const maxX = Math.max(modelX, x2);\n      result = x - compX >= minX && x - compX <= maxX && y >= modelY + compY - detectionSize && y <= modelY + compY + detectionSize;\n    } else if (denominator === 0) {\n      // x = a\n      const minY = Math.min(modelY, y2);\n      const maxY = Math.max(modelY, y2);\n      result = y - compY >= minY && y - compY <= maxY && x >= modelX + compX - detectionSize && x <= modelX + compX + detectionSize;\n    } else {\n      // y = ax + b\n      const slope = numerator / denominator;\n      const xPos = x - (modelX + compX);\n      const yPos = y - (modelY + compY);\n      result = slope * xPos === yPos;\n    }\n\n    return result;\n  },\n  boxPlot: (mousePosition, model, componentRect = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }) => {\n    return ['rect', 'median', 'minimum', 'maximum', 'upperWhisker', 'lowerWhisker'].some(prop => {\n      if (!model[prop]) {\n        return false;\n      }\n\n      return prop === 'rect' ? responderDetectors.rect(mousePosition, model[prop], componentRect) : responderDetectors.line(mousePosition, model[prop], componentRect);\n    });\n  }\n};","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/responderDetectors.js"],"names":["isUndefined","calculateRadianToDegree","withinRadian","responderDetectors","circle","mousePosition","model","componentRect","x","y","modelX","modelY","radius","detectionSize","compX","compY","radiusAdjustment","Math","pow","rect","width","height","sector","outer","inner","degree","start","end","drawingStartAngle","clockwise","xPos","yPos","insideOuterRadius","outsideInnerRadius","withinRadius","detectionDegree","atan2","line","x2","y2","numerator","denominator","result","minX","min","maxX","max","minY","maxY","slope","boxPlot","some","prop"],"mappings":"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","sourcesContent":["import { isUndefined } from \"./helpers/utils\";\nimport { calculateRadianToDegree, withinRadian } from \"./helpers/sector\";\nexport const responderDetectors = {\n    circle: (mousePosition, model, componentRect) => {\n        const { x, y } = mousePosition;\n        const { x: modelX, y: modelY, radius, detectionSize } = model;\n        const { x: compX, y: compY } = componentRect;\n        const radiusAdjustment = isUndefined(detectionSize) ? 10 : detectionSize;\n        return (Math.pow((x - (modelX + compX)), 2) + Math.pow((y - (modelY + compY)), 2) < Math.pow((radius + radiusAdjustment), 2));\n    },\n    rect: (mousePosition, model, componentRect = { x: 0, y: 0, width: 0, height: 0 }) => {\n        const { x, y } = mousePosition;\n        const { x: modelX, y: modelY, width, height } = model;\n        const { x: compX, y: compY } = componentRect;\n        return (x >= modelX + compX &&\n            x <= modelX + compX + width &&\n            y >= modelY + compY &&\n            y <= modelY + compY + height);\n    },\n    sector: (mousePosition, model, componentRect = { x: 0, y: 0, width: 0, height: 0 }) => {\n        const { x, y } = mousePosition;\n        const { x: modelX, y: modelY, radius: { outer, inner }, degree: { start, end }, drawingStartAngle, clockwise, } = model;\n        const { x: compX, y: compY } = componentRect;\n        const xPos = x - (modelX + compX);\n        const yPos = y - (modelY + compY);\n        const insideOuterRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) < Math.pow(outer, 2);\n        const outsideInnerRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) > Math.pow(inner, 2);\n        const withinRadius = insideOuterRadius && outsideInnerRadius;\n        const detectionDegree = calculateRadianToDegree(Math.atan2(yPos, xPos), drawingStartAngle);\n        return withinRadius && withinRadian(clockwise, start, end, detectionDegree);\n    },\n    line: (mousePosition, model, componentRect = { x: 0, y: 0, width: 0, height: 0 }) => {\n        const { x, y } = mousePosition;\n        const { x: compX, y: compY } = componentRect;\n        const { x: modelX, y: modelY, x2, y2, detectionSize = 3 } = model;\n        const numerator = y2 - modelY;\n        const denominator = x2 - modelX;\n        let result = false;\n        if (numerator === 0) {\n            // y = a\n            const minX = Math.min(modelX, x2);\n            const maxX = Math.max(modelX, x2);\n            result =\n                x - compX >= minX &&\n                    x - compX <= maxX &&\n                    y >= modelY + compY - detectionSize &&\n                    y <= modelY + compY + detectionSize;\n        }\n        else if (denominator === 0) {\n            // x = a\n            const minY = Math.min(modelY, y2);\n            const maxY = Math.max(modelY, y2);\n            result =\n                y - compY >= minY &&\n                    y - compY <= maxY &&\n                    x >= modelX + compX - detectionSize &&\n                    x <= modelX + compX + detectionSize;\n        }\n        else {\n            // y = ax + b\n            const slope = numerator / denominator;\n            const xPos = x - (modelX + compX);\n            const yPos = y - (modelY + compY);\n            result = slope * xPos === yPos;\n        }\n        return result;\n    },\n    boxPlot: (mousePosition, model, componentRect = { x: 0, y: 0, width: 0, height: 0 }) => {\n        return ['rect', 'median', 'minimum', 'maximum', 'upperWhisker', 'lowerWhisker'].some((prop) => {\n            if (!model[prop]) {\n                return false;\n            }\n            return prop === 'rect'\n                ? responderDetectors.rect(mousePosition, model[prop], componentRect)\n                : responderDetectors.line(mousePosition, model[prop], componentRect);\n        });\n    },\n};\n"]},"metadata":{},"sourceType":"module"}