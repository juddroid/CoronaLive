{"ast":null,"code":"import { AxisType } from \"../component/axis\";\nimport { getAxisTheme, makeFormattedCategory, getViewAxisLabels, makeRotationData, getRotatableOption, hasAxesLayoutChanged, makeTitleOption, getMaxLabelSize, getLabelXMargin } from \"../helpers/axes\";\nimport { getAxisLabelAnchorPoint } from \"../helpers/calculator\";\nimport { getTitleFontString } from \"../helpers/style\";\n\nfunction getHeatmapAxisData(stateProp, axisType) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n\n  const {\n    categories,\n    axisSize,\n    options,\n    theme\n  } = stateProp;\n  const isLabelAxis = axisType === AxisType.X;\n  const axisName = isLabelAxis ? 'x' : 'y';\n  const formatter = (_c = (_b = (_a = options[axisType]) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.formatter, _c !== null && _c !== void 0 ? _c : value => value);\n  const labelsBeforeFormatting = makeFormattedCategory(categories[axisName], (_d = options[axisType]) === null || _d === void 0 ? void 0 : _d.date);\n  const labels = labelsBeforeFormatting.map((label, index) => formatter(label, {\n    index,\n    labels: labelsBeforeFormatting,\n    axisName: axisType\n  }));\n  const tickIntervalCount = labels.length;\n  const tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;\n  const labelDistance = axisSize / tickIntervalCount;\n  const pointOnColumn = true;\n  const tickCount = tickIntervalCount + 1;\n  const tickInterval = (_g = (_f = (_e = options[axisType]) === null || _e === void 0 ? void 0 : _e.tick) === null || _f === void 0 ? void 0 : _f.interval, _g !== null && _g !== void 0 ? _g : 1);\n  const labelInterval = (_k = (_j = (_h = options[axisType]) === null || _h === void 0 ? void 0 : _h.label) === null || _j === void 0 ? void 0 : _j.interval, _k !== null && _k !== void 0 ? _k : 1);\n  const viewLabels = getViewAxisLabels({\n    labels,\n    pointOnColumn,\n    tickDistance,\n    tickCount,\n    tickInterval,\n    labelInterval\n  }, axisSize);\n  const labelXMargin = getLabelXMargin(axisType, options);\n  const {\n    maxLabelWidth,\n    maxLabelHeight\n  } = getMaxLabelSize(labels, labelXMargin, getTitleFontString(theme.label));\n  const axisData = {\n    labels,\n    viewLabels,\n    pointOnColumn,\n    isLabelAxis,\n    tickCount,\n    tickDistance,\n    labelDistance,\n    tickInterval,\n    labelInterval,\n    title: makeTitleOption((_l = options.xAxis) === null || _l === void 0 ? void 0 : _l.title),\n    maxLabelWidth,\n    maxLabelHeight\n  };\n\n  if (axisType === AxisType.X) {\n    const labelMargin = (_p = (_o = (_m = options.xAxis) === null || _m === void 0 ? void 0 : _m.label) === null || _o === void 0 ? void 0 : _o.margin, _p !== null && _p !== void 0 ? _p : 0);\n    const offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;\n    const distance = axisSize / viewLabels.length;\n    const rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, getRotatableOption(options));\n    const {\n      needRotateLabel,\n      rotationHeight\n    } = rotationData;\n    const maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;\n    return Object.assign(Object.assign(Object.assign({}, axisData), rotationData), {\n      maxHeight,\n      offsetY\n    });\n  }\n\n  return axisData;\n}\n\nconst axes = {\n  name: 'axes',\n  state: () => {\n    return {\n      axes: {\n        xAxis: {},\n        yAxis: {}\n      }\n    };\n  },\n  action: {\n    setAxesData({\n      state\n    }) {\n      const {\n        layout,\n        theme\n      } = state;\n      const {\n        width,\n        height\n      } = layout.plot;\n      const categories = state.categories;\n      const options = state.options;\n      const xAxisData = getHeatmapAxisData({\n        axisSize: width,\n        categories,\n        options,\n        theme: getAxisTheme(theme, AxisType.X)\n      }, AxisType.X);\n      const yAxisData = getHeatmapAxisData({\n        axisSize: height,\n        categories,\n        options,\n        theme: getAxisTheme(theme, AxisType.X)\n      }, AxisType.Y);\n      const axesState = {\n        xAxis: xAxisData,\n        yAxis: yAxisData\n      };\n\n      if (hasAxesLayoutChanged(state.axes, axesState)) {\n        this.notify(state, 'layout');\n      }\n\n      state.axes = axesState;\n    }\n\n  },\n  computed: {},\n  observe: {\n    updateAxes() {\n      this.dispatch('setAxesData');\n    }\n\n  }\n};\nexport default axes;","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/store/heatmapAxes.js"],"names":["AxisType","getAxisTheme","makeFormattedCategory","getViewAxisLabels","makeRotationData","getRotatableOption","hasAxesLayoutChanged","makeTitleOption","getMaxLabelSize","getLabelXMargin","getAxisLabelAnchorPoint","getTitleFontString","getHeatmapAxisData","stateProp","axisType","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","categories","axisSize","options","theme","isLabelAxis","X","axisName","formatter","label","value","labelsBeforeFormatting","date","labels","map","index","tickIntervalCount","length","tickDistance","labelDistance","pointOnColumn","tickCount","tickInterval","tick","interval","labelInterval","viewLabels","labelXMargin","maxLabelWidth","maxLabelHeight","axisData","title","xAxis","labelMargin","margin","offsetY","distance","rotationData","needRotateLabel","rotationHeight","maxHeight","Object","assign","axes","name","state","yAxis","action","setAxesData","layout","width","height","plot","xAxisData","yAxisData","Y","axesState","notify","computed","observe","updateAxes","dispatch"],"mappings":"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","sourcesContent":["import { AxisType } from \"../component/axis\";\nimport { getAxisTheme, makeFormattedCategory, getViewAxisLabels, makeRotationData, getRotatableOption, hasAxesLayoutChanged, makeTitleOption, getMaxLabelSize, getLabelXMargin, } from \"../helpers/axes\";\nimport { getAxisLabelAnchorPoint } from \"../helpers/calculator\";\nimport { getTitleFontString } from \"../helpers/style\";\nfunction getHeatmapAxisData(stateProp, axisType) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n    const { categories, axisSize, options, theme } = stateProp;\n    const isLabelAxis = axisType === AxisType.X;\n    const axisName = isLabelAxis ? 'x' : 'y';\n    const formatter = (_c = (_b = (_a = options[axisType]) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.formatter, (_c !== null && _c !== void 0 ? _c : ((value) => value)));\n    const labelsBeforeFormatting = makeFormattedCategory(categories[axisName], (_d = options[axisType]) === null || _d === void 0 ? void 0 : _d.date);\n    const labels = labelsBeforeFormatting.map((label, index) => formatter(label, { index, labels: labelsBeforeFormatting, axisName: axisType }));\n    const tickIntervalCount = labels.length;\n    const tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;\n    const labelDistance = axisSize / tickIntervalCount;\n    const pointOnColumn = true;\n    const tickCount = tickIntervalCount + 1;\n    const tickInterval = (_g = (_f = (_e = options[axisType]) === null || _e === void 0 ? void 0 : _e.tick) === null || _f === void 0 ? void 0 : _f.interval, (_g !== null && _g !== void 0 ? _g : 1));\n    const labelInterval = (_k = (_j = (_h = options[axisType]) === null || _h === void 0 ? void 0 : _h.label) === null || _j === void 0 ? void 0 : _j.interval, (_k !== null && _k !== void 0 ? _k : 1));\n    const viewLabels = getViewAxisLabels({\n        labels,\n        pointOnColumn,\n        tickDistance,\n        tickCount,\n        tickInterval,\n        labelInterval,\n    }, axisSize);\n    const labelXMargin = getLabelXMargin(axisType, options);\n    const { maxLabelWidth, maxLabelHeight } = getMaxLabelSize(labels, labelXMargin, getTitleFontString(theme.label));\n    const axisData = {\n        labels,\n        viewLabels,\n        pointOnColumn,\n        isLabelAxis,\n        tickCount,\n        tickDistance,\n        labelDistance,\n        tickInterval,\n        labelInterval,\n        title: makeTitleOption((_l = options.xAxis) === null || _l === void 0 ? void 0 : _l.title),\n        maxLabelWidth,\n        maxLabelHeight,\n    };\n    if (axisType === AxisType.X) {\n        const labelMargin = (_p = (_o = (_m = options.xAxis) === null || _m === void 0 ? void 0 : _m.label) === null || _o === void 0 ? void 0 : _o.margin, (_p !== null && _p !== void 0 ? _p : 0));\n        const offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;\n        const distance = axisSize / viewLabels.length;\n        const rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, getRotatableOption(options));\n        const { needRotateLabel, rotationHeight } = rotationData;\n        const maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;\n        return Object.assign(Object.assign(Object.assign({}, axisData), rotationData), { maxHeight,\n            offsetY });\n    }\n    return axisData;\n}\nconst axes = {\n    name: 'axes',\n    state: () => {\n        return {\n            axes: {\n                xAxis: {},\n                yAxis: {},\n            },\n        };\n    },\n    action: {\n        setAxesData({ state }) {\n            const { layout, theme } = state;\n            const { width, height } = layout.plot;\n            const categories = state.categories;\n            const options = state.options;\n            const xAxisData = getHeatmapAxisData({ axisSize: width, categories, options, theme: getAxisTheme(theme, AxisType.X) }, AxisType.X);\n            const yAxisData = getHeatmapAxisData({ axisSize: height, categories, options, theme: getAxisTheme(theme, AxisType.X) }, AxisType.Y);\n            const axesState = { xAxis: xAxisData, yAxis: yAxisData };\n            if (hasAxesLayoutChanged(state.axes, axesState)) {\n                this.notify(state, 'layout');\n            }\n            state.axes = axesState;\n        },\n    },\n    computed: {},\n    observe: {\n        updateAxes() {\n            this.dispatch('setAxesData');\n        },\n    },\n};\nexport default axes;\n"]},"metadata":{},"sourceType":"module"}