{"ast":null,"code":"import Store from \"../store/store\";\nimport root from \"../store/root\";\nimport layout from \"../store/layout\";\nimport seriesData from \"../store/seriesData\";\nimport category from \"../store/category\";\nimport legend from \"../store/legend\";\nimport optionsStore from \"../store/options\";\nimport theme from \"../store/theme\";\nimport EventEmitter from \"../eventEmitter\";\nimport ComponentManager from \"../component/componentManager\";\nimport Painter from \"../painter\";\nimport Animator from \"../animator\";\nimport { debounce, isBoolean, isNumber, isUndefined, pick, isAutoValue } from \"../helpers/utils\";\nimport { responderDetectors } from \"../responderDetectors\";\nimport { message } from \"../message\";\nimport { sendHostname } from \"../helpers/googleAnalytics\";\nimport { makeObservableObjectToNormal } from \"../store/reactive\";\nexport const DEFAULT_ANIM_DURATION = 500;\n\nfunction getUsingContainerSize(eventName, usingContainerSize, width, height) {\n  const {\n    width: usingContainerWidth,\n    height: usingContainerHeight\n  } = usingContainerSize;\n  const isAutoWidth = isAutoValue(width);\n  const isAutoHeight = isAutoValue(height);\n  return eventName === 'updateOptions' ? {\n    width: !isUndefined(width) && usingContainerWidth !== isAutoWidth ? isAutoWidth : usingContainerWidth,\n    height: !isUndefined(height) && usingContainerHeight !== isAutoHeight ? isAutoHeight : usingContainerHeight\n  } : {\n    width: isAutoWidth,\n    height: isAutoHeight\n  };\n}\n/**\n * @class\n * @abstract\n * Abstract class used to implement each chart.\n */\n\n\nexport default class Chart {\n  constructor(props) {\n    var _a, _b, _c, _d;\n\n    this.___animId___ = null;\n    this.painter = new Painter(this);\n    this.eventBus = new EventEmitter();\n    this.enteredComponents = [];\n    this.animationControlFlag = {\n      resizing: false,\n      updating: false\n    };\n    this.resizeObserver = null;\n    this.debounceResizeEvent = debounce(() => {\n      const {\n        offsetWidth,\n        offsetHeight\n      } = this.containerEl;\n      this.resizeChartSize(offsetWidth, offsetHeight);\n    }, 100);\n    /**\n     * Get checked legend chart type and label, checked state.\n     * @returns {Array<{checked: boolean, chartType: string, label: string}>} Array data that whether series has checked\n     * @api\n     * @example\n     * const checkedLegend = chart.getCheckedLegend()\n     */\n\n    this.getCheckedLegend = () => {\n      const {\n        data\n      } = this.store.state.legend;\n      return data.filter(datum => datum.checked).map(datum => pick(datum, 'chartType', 'label', 'checked'));\n    };\n    /**\n     * Returns the currently applied chart options.\n     * @returns {Object} options\n     * @api\n     * @example\n     * const options = chart.getOptions();\n     */\n\n\n    this.getOptions = () => {\n      return makeObservableObjectToNormal(this.store.initStoreState.options);\n    };\n    /**\n     * Register of user custom event.\n     * @param {string} eventName - Event name. 'clickLegendLabel', 'clickLegendCheckbox', 'selectSeries', 'unselectSeries', 'hoverSeries', 'unhoverSeries', 'zoom', 'resetZoom' is available.\n     * @param {Function} handler - Event handler\n     * @api\n     */\n\n\n    this.on = (eventName, handler) => {\n      /**\n       * Register Events that occur when click legend label\n       * @event ChartBase#clickLegendLabel\n       * @param {object} info selected legend information\n       * @api\n       * @example\n       * chart.on('clickLegendLabel', (info) => {\n       *   console.log(info);\n       * });\n       */\n\n      /**\n       * Register Events that occur when click legend checkbox\n       * @event ChartBase#clickLegendCheckbox\n       * @param {object} info selected legend info\n       * @api\n       * @example\n       * chart.on('clickLegendCheckbox', (info) => {\n       *   console.log(info);\n       * });\n       */\n\n      /**\n       * Register Events that occur when select series\n       * @event ChartBase#selectSeries\n       * @param {object} info selected series info\n       * @api\n       * @example\n       * chart.on('selectSeries', (info) => {\n       *   console.log(info);\n       * });\n       */\n\n      /**\n       * Register Events that occur when unselect series\n       * @event ChartBase#unselectSeries\n       * @param {object} info unselected series info\n       * @api\n       * @example\n       * chart.on('unselectSeries', (info) => {\n       *   console.log(info);\n       * });\n       */\n\n      /**\n       * Register Events that occur when hover to series\n       * @event ChartBase#hoverSeries\n       * @param {object} info hovered series info\n       * @api\n       * @example\n       * chart.on('hoverSeries', (info) => {\n       *   console.log(info);\n       * });\n       */\n\n      /**\n       * Register Events that occur when unhover from series\n       * @event ChartBase#unhoverSeries\n       * @param {object} info unhovered series info\n       * @api\n       * @example\n       * chart.on('unhoverSeries', (info) => {\n       *  console.log(info);\n       * });\n       */\n\n      /**\n       * Register Events that occur when zooming\n       * @event ChartBase#zoom\n       * @param {string[]} dataRange - []\n       * @api\n       * @example\n       * chart.on('zoom', (dataRange) => {\n       *    console.log(dataRange);\n       * });\n       */\n\n      /**\n       * Register Events that occur when zoom is reset\n       * @event ChartBase#resetZoom\n       * @api\n       * @example\n       * chart.on('resetZoom', () => {});\n       */\n      this.eventBus.on(eventName, handler);\n    };\n    /**\n     * Destroys the instance.\n     * @api\n     * @example\n     * chart.destroy();\n     */\n\n\n    this.destroy = () => {\n      this.componentManager.clear();\n      this.clearResizeEvent();\n      this.containerEl.innerHTML = '';\n    };\n    /**\n     * Select series. It works only when the selectable option is true.\n     * @param {Object} seriesInfo - Information of the series to be selected\n     *      @param {number} [seriesInfo.seriesIndex] - Index of series\n     *      @param {number} [seriesInfo.index] - Index of data within series\n     *      @param {string} [seriesInfo.name] - Specify name for NestedPie Chart\n     *      @param {string} [seriesInfo.chartType] - Specify which chart to select when using LineArea, LineScatter, and ColumnLine charts.specifies which chart to select when using LineArea, LineScatter, and ColumnLine charts.\n     * @api\n     * @example\n     * chart.selectSeries({index: 1, seriesIndex: 2});\n     */\n\n\n    this.selectSeries = seriesInfo => {\n      if (!this.isSelectableSeries()) {\n        throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);\n      }\n\n      this.eventBus.emit('selectSeries', Object.assign(Object.assign({}, seriesInfo), {\n        state: this.store.state\n      }));\n    };\n    /**\n     * Unselect selected series. It works only when the selectable option is true.\n     * @api\n     * @example\n     * chart.unselectSeries();\n     */\n\n\n    this.unselectSeries = () => {\n      if (!this.isSelectableSeries()) {\n        throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);\n      }\n\n      this.store.dispatch('setAllLegendActiveState', true);\n      this.eventBus.emit('resetSelectedSeries');\n    };\n    /**\n     * Resize chart size.\n     * @param {Object} size Chart size\n     *   @param {number} [size.width] Width\n     *   @param {number} [size.height] Height\n     * @api\n     * @example\n     * chart.resize({height: 100, width: 200});\n     */\n\n\n    this.resize = size => {\n      this.resetSeries();\n      this.dispatchOptionsEvent('updateOptions', {\n        chart: Object.assign({}, size)\n      });\n    };\n\n    this.resetSeries = () => {\n      this.eventBus.emit('resetHoveredSeries');\n      this.eventBus.emit('resetSelectedSeries');\n    };\n\n    this.setResizeEventListeners = (eventName, options) => {\n      var _a, _b, _c, _d;\n\n      const {\n        usingContainerSize\n      } = this.store.state;\n      const {\n        width: usingContainerWidth,\n        height: usingContainerHeight\n      } = usingContainerSize;\n      const width = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.chart) === null || _b === void 0 ? void 0 : _b.width;\n      const height = (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.chart) === null || _d === void 0 ? void 0 : _d.height;\n      const isAutoWidth = isAutoValue(width);\n      const isAutoHeight = isAutoValue(height);\n      this.store.dispatch('setUsingContainerSize', getUsingContainerSize(eventName, usingContainerSize, width, height));\n\n      if ((usingContainerWidth || usingContainerHeight) && isNumber(width) && isNumber(height)) {\n        this.clearResizeEvent();\n      } else if (!(usingContainerWidth || usingContainerHeight) && (isAutoWidth || isAutoHeight)) {\n        this.setResizeEvent();\n      }\n    };\n\n    const {\n      el,\n      options,\n      series,\n      categories,\n      modules\n    } = props;\n    this.modules = modules !== null && modules !== void 0 ? modules : [];\n\n    if (isUndefined(options.usageStatistics) || options.usageStatistics) {\n      sendHostname();\n    }\n\n    this.containerEl = el;\n    this.el = this.createChartWrapper();\n    this.containerEl.appendChild(this.el);\n    this.animator = new Animator();\n    this.store = new Store({\n      series,\n      categories,\n      options\n    });\n    this.componentManager = new ComponentManager({\n      store: this.store,\n      eventBus: this.eventBus\n    });\n    this.eventBus.on('needLoop', debounce(() => {\n      var _a, _b;\n\n      let duration = this.getAnimationDuration((_a = options.chart) === null || _a === void 0 ? void 0 : _a.animation);\n\n      if (this.animationControlFlag.resizing) {\n        duration = isUndefined(options.responsive) ? this.getAnimationDuration() : this.getAnimationDuration((_b = options.responsive) === null || _b === void 0 ? void 0 : _b.animation);\n        this.animationControlFlag.resizing = false;\n      }\n\n      this.eventBus.emit('loopStart');\n      this.animator.add({\n        onCompleted: () => {\n          this.eventBus.emit('loopComplete');\n        },\n        chart: this,\n        duration,\n        requester: this\n      });\n    }, 10));\n    this.eventBus.on('needSubLoop', opts => {\n      this.animator.add(Object.assign(Object.assign({}, opts), {\n        chart: this\n      }));\n    });\n    this.eventBus.on('needDraw', debounce(() => {\n      this.draw();\n    }, 10));\n    this.initialize();\n    this.store.observe(() => {\n      this.painter.setup();\n    });\n\n    if (isAutoValue((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.chart) === null || _b === void 0 ? void 0 : _b.width) || isAutoValue((_d = (_c = options) === null || _c === void 0 ? void 0 : _c.chart) === null || _d === void 0 ? void 0 : _d.height)) {\n      this.setResizeEvent();\n    }\n  }\n\n  getAnimationDuration(animationOption) {\n    const {\n      firstRendering\n    } = this.animator;\n    const {\n      resizing,\n      updating\n    } = this.animationControlFlag;\n    let duration;\n\n    if (!firstRendering && !resizing || isUndefined(animationOption)) {\n      duration = DEFAULT_ANIM_DURATION;\n    } else if (isBoolean(animationOption)) {\n      duration = animationOption ? DEFAULT_ANIM_DURATION : 0;\n    } else if (isNumber(animationOption.duration)) {\n      duration = animationOption.duration;\n    }\n\n    if (updating) {\n      duration = 0;\n    }\n\n    this.animationControlFlag.updating = false;\n    return duration;\n  }\n\n  createChartWrapper() {\n    const el = document.createElement('div');\n    el.classList.add('toastui-chart-wrapper');\n    return el;\n  }\n\n  resizeChartSize(containerWidth, containerHeight) {\n    this.animationControlFlag.resizing = true;\n    const {\n      usingContainerSize: {\n        width: usingContainerWidth,\n        height: usingContainerHeight\n      },\n      chart: {\n        width,\n        height\n      }\n    } = this.store.state;\n\n    if (!(usingContainerWidth || usingContainerHeight) || !(containerWidth || containerHeight) || containerWidth === width && containerHeight === height) {\n      this.animationControlFlag.resizing = false;\n      return;\n    } // @TODO: For updates where the data doesn't change, it looks good to recalculate the selected series position.\n\n\n    this.resetSeries();\n    this.store.dispatch('setChartSize', {\n      width: usingContainerWidth ? containerWidth : width,\n      height: usingContainerHeight ? containerHeight : height\n    });\n    this.draw();\n  }\n\n  setResizeEvent() {\n    const {\n      usingContainerSize\n    } = this.store.state;\n\n    if (usingContainerSize.height && !this.containerEl.style.height.length || usingContainerSize.width && !this.containerEl.style.width.length) {\n      throw new Error(message.AUTO_LAYOUT_CONTAINER_SIZE_ERROR);\n    }\n\n    const isResizeObserverAPIExist = typeof ResizeObserver === 'undefined';\n\n    if (isResizeObserverAPIExist) {\n      window.addEventListener('resize', this.debounceResizeEvent);\n    } else {\n      this.resizeObserver = new ResizeObserver(entries => {\n        entries.forEach(() => {\n          this.debounceResizeEvent();\n        });\n      });\n      this.resizeObserver.observe(this.containerEl);\n    }\n  }\n\n  clearResizeEvent() {\n    if (this.resizeObserver) {\n      this.resizeObserver.unobserve(this.containerEl);\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    } else {\n      window.removeEventListener('resize', this.debounceResizeEvent);\n    }\n  }\n\n  handleEvent(event) {\n    const {\n      clientX,\n      clientY,\n      type: eventType\n    } = event;\n    const delegationMethod = `on${eventType[0].toUpperCase() + eventType.substring(1)}`;\n    const canvas = this.painter.ctx.canvas;\n    const canvasRect = canvas.getBoundingClientRect(); // Calculate scale for chart affected by a CSS transform.\n\n    const scaleX = canvasRect.width / canvas.offsetWidth;\n    const scaleY = canvasRect.height / canvas.offsetHeight;\n    const mousePosition = {\n      x: (clientX - canvasRect.left) / scaleX,\n      y: (clientY - canvasRect.top) / scaleY\n    };\n    const newEnteredComponents = [];\n\n    if (eventType === 'mousemove') {\n      this.componentManager.forEach(component => {\n        const {\n          x,\n          y,\n          height,\n          width\n        } = component.rect;\n        const exist = this.enteredComponents.some(enteredComponent => enteredComponent === component);\n        const entered = mousePosition.x >= x && mousePosition.x <= x + width && mousePosition.y >= y && mousePosition.y <= y + height;\n\n        if (entered) {\n          newEnteredComponents.push(component);\n\n          if (!exist && component.onMouseenterComponent) {\n            component.onMouseenterComponent();\n          }\n        } else if (exist && component.onMouseoutComponent) {\n          component.onMouseoutComponent();\n        }\n      });\n      this.enteredComponents = newEnteredComponents;\n    }\n\n    const allResponders = [];\n    this.componentManager.forEach(component => {\n      if (!component[delegationMethod]) {\n        return;\n      }\n\n      if (!responderDetectors.rect(mousePosition, component.rect)) {\n        return;\n      }\n\n      const detected = (component.responders || []).filter(m => {\n        return responderDetectors[m.type](mousePosition, m, component.rect);\n      });\n\n      if (detected.length) {\n        allResponders.push({\n          component,\n          detected\n        });\n      }\n\n      component[delegationMethod]({\n        mousePosition,\n        responders: detected\n      }, event);\n    });\n\n    if (this.handleEventForAllResponders) {\n      this.handleEventForAllResponders(event, allResponders, delegationMethod, mousePosition);\n    }\n  }\n\n  initStore() {\n    [root, optionsStore, theme, seriesData, legend, layout, category, ...this.modules].forEach(module => this.store.setModule(module));\n  }\n\n  initialize() {\n    this.initStore();\n    this.store.dispatch('initChartSize', this.containerEl);\n  }\n\n  draw() {\n    this.painter.beforeFrame();\n    this.componentManager.forEach(component => {\n      if (!component.isShow) {\n        return;\n      }\n\n      this.painter.beforeDraw(component.rect.x, component.rect.y);\n\n      if (component.beforeDraw) {\n        component.beforeDraw(this.painter);\n      }\n\n      component.draw(this.painter);\n      this.painter.afterDraw();\n    });\n  }\n\n  update(delta) {\n    this.componentManager.invoke('update', delta);\n  }\n\n  initUpdate(delta) {\n    this.componentManager.invoke('initUpdate', delta);\n  }\n\n  isSelectableSeries() {\n    var _a;\n\n    return (_a = this.store.initStoreState.options.series) === null || _a === void 0 ? void 0 : _a.selectable;\n  }\n  /**\n   * Set tooltip offset.\n   * @param {Object} offset - Offset size\n   *   @param {number} [offset.x] Offset value to move title horizontally\n   *   @param {number} [offset.y] Offset value to move title vertically\n   * @api\n   * @example\n   * chart.setTooltipOffset({x: 10, y: -20});\n   */\n\n\n  setTooltipOffset(offset) {\n    const {\n      x: offsetX,\n      y: offsetY\n    } = offset;\n    this.store.dispatch('updateOptions', {\n      options: {\n        tooltip: {\n          offsetX,\n          offsetY\n        }\n      }\n    });\n  }\n\n  dispatchOptionsEvent(eventName, options) {\n    this.setResizeEventListeners(eventName, options);\n    const {\n      offsetWidth,\n      offsetHeight\n    } = this.containerEl;\n    this.store.dispatch(eventName, {\n      options,\n      containerSize: {\n        width: offsetWidth,\n        height: offsetHeight\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/charts/chart.js"],"names":["Store","root","layout","seriesData","category","legend","optionsStore","theme","EventEmitter","ComponentManager","Painter","Animator","debounce","isBoolean","isNumber","isUndefined","pick","isAutoValue","responderDetectors","message","sendHostname","makeObservableObjectToNormal","DEFAULT_ANIM_DURATION","getUsingContainerSize","eventName","usingContainerSize","width","height","usingContainerWidth","usingContainerHeight","isAutoWidth","isAutoHeight","Chart","constructor","props","_a","_b","_c","_d","___animId___","painter","eventBus","enteredComponents","animationControlFlag","resizing","updating","resizeObserver","debounceResizeEvent","offsetWidth","offsetHeight","containerEl","resizeChartSize","getCheckedLegend","data","store","state","filter","datum","checked","map","getOptions","initStoreState","options","on","handler","destroy","componentManager","clear","clearResizeEvent","innerHTML","selectSeries","seriesInfo","isSelectableSeries","Error","SELECT_SERIES_API_SELECTABLE_ERROR","emit","Object","assign","unselectSeries","dispatch","resize","size","resetSeries","dispatchOptionsEvent","chart","setResizeEventListeners","setResizeEvent","el","series","categories","modules","usageStatistics","createChartWrapper","appendChild","animator","duration","getAnimationDuration","animation","responsive","add","onCompleted","requester","opts","draw","initialize","observe","setup","animationOption","firstRendering","document","createElement","classList","containerWidth","containerHeight","style","length","AUTO_LAYOUT_CONTAINER_SIZE_ERROR","isResizeObserverAPIExist","ResizeObserver","window","addEventListener","entries","forEach","unobserve","disconnect","removeEventListener","handleEvent","event","clientX","clientY","type","eventType","delegationMethod","toUpperCase","substring","canvas","ctx","canvasRect","getBoundingClientRect","scaleX","scaleY","mousePosition","x","left","y","top","newEnteredComponents","component","rect","exist","some","enteredComponent","entered","push","onMouseenterComponent","onMouseoutComponent","allResponders","detected","responders","m","handleEventForAllResponders","initStore","module","setModule","beforeFrame","isShow","beforeDraw","afterDraw","update","delta","invoke","initUpdate","selectable","setTooltipOffset","offset","offsetX","offsetY","tooltip","containerSize"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,gBAAlB;AACA,OAAOC,IAAP,MAAiB,eAAjB;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AACA,OAAOC,UAAP,MAAuB,qBAAvB;AACA,OAAOC,QAAP,MAAqB,mBAArB;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AACA,OAAOC,YAAP,MAAyB,kBAAzB;AACA,OAAOC,KAAP,MAAkB,gBAAlB;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,gBAAP,MAA6B,+BAA7B;AACA,OAAOC,OAAP,MAAoB,YAApB;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,SAASC,QAAT,EAAmBC,SAAnB,EAA8BC,QAA9B,EAAwCC,WAAxC,EAAqDC,IAArD,EAA2DC,WAA3D,QAA8E,kBAA9E;AACA,SAASC,kBAAT,QAAmC,uBAAnC;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,SAASC,YAAT,QAA6B,4BAA7B;AACA,SAASC,4BAAT,QAA6C,mBAA7C;AACA,OAAO,MAAMC,qBAAqB,GAAG,GAA9B;;AACP,SAASC,qBAAT,CAA+BC,SAA/B,EAA0CC,kBAA1C,EAA8DC,KAA9D,EAAqEC,MAArE,EAA6E;AACzE,QAAM;AAAED,IAAAA,KAAK,EAAEE,mBAAT;AAA8BD,IAAAA,MAAM,EAAEE;AAAtC,MAA+DJ,kBAArE;AACA,QAAMK,WAAW,GAAGb,WAAW,CAACS,KAAD,CAA/B;AACA,QAAMK,YAAY,GAAGd,WAAW,CAACU,MAAD,CAAhC;AACA,SAAOH,SAAS,KAAK,eAAd,GACD;AACEE,IAAAA,KAAK,EAAE,CAACX,WAAW,CAACW,KAAD,CAAZ,IAAuBE,mBAAmB,KAAKE,WAA/C,GACDA,WADC,GAEDF,mBAHR;AAIED,IAAAA,MAAM,EAAE,CAACZ,WAAW,CAACY,MAAD,CAAZ,IAAwBE,oBAAoB,KAAKE,YAAjD,GACFA,YADE,GAEFF;AANR,GADC,GASD;AACEH,IAAAA,KAAK,EAAEI,WADT;AAEEH,IAAAA,MAAM,EAAEI;AAFV,GATN;AAaH;AACD;AACA;AACA;AACA;AACA;;;AACA,eAAe,MAAMC,KAAN,CAAY;AACvBC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,QAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,OAAL,GAAe,IAAI9B,OAAJ,CAAY,IAAZ,CAAf;AACA,SAAK+B,QAAL,GAAgB,IAAIjC,YAAJ,EAAhB;AACA,SAAKkC,iBAAL,GAAyB,EAAzB;AACA,SAAKC,oBAAL,GAA4B;AACxBC,MAAAA,QAAQ,EAAE,KADc;AAExBC,MAAAA,QAAQ,EAAE;AAFc,KAA5B;AAIA,SAAKC,cAAL,GAAsB,IAAtB;AACA,SAAKC,mBAAL,GAA2BnC,QAAQ,CAAC,MAAM;AACtC,YAAM;AAAEoC,QAAAA,WAAF;AAAeC,QAAAA;AAAf,UAAgC,KAAKC,WAA3C;AACA,WAAKC,eAAL,CAAqBH,WAArB,EAAkCC,YAAlC;AACH,KAHkC,EAGhC,GAHgC,CAAnC;AAIA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKG,gBAAL,GAAwB,MAAM;AAC1B,YAAM;AAAEC,QAAAA;AAAF,UAAW,KAAKC,KAAL,CAAWC,KAAX,CAAiBlD,MAAlC;AACA,aAAOgD,IAAI,CACNG,MADE,CACMC,KAAD,IAAWA,KAAK,CAACC,OADtB,EAEFC,GAFE,CAEGF,KAAD,IAAWzC,IAAI,CAACyC,KAAD,EAAQ,WAAR,EAAqB,OAArB,EAA8B,SAA9B,CAFjB,CAAP;AAGH,KALD;AAMA;AACR;AACA;AACA;AACA;AACA;AACA;;;AACQ,SAAKG,UAAL,GAAkB,MAAM;AACpB,aAAOvC,4BAA4B,CAAC,KAAKiC,KAAL,CAAWO,cAAX,CAA0BC,OAA3B,CAAnC;AACH,KAFD;AAGA;AACR;AACA;AACA;AACA;AACA;;;AACQ,SAAKC,EAAL,GAAU,CAACvC,SAAD,EAAYwC,OAAZ,KAAwB;AAC9B;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACY;AACZ;AACA;AACA;AACA;AACA;AACA;AACY,WAAKvB,QAAL,CAAcsB,EAAd,CAAiBvC,SAAjB,EAA4BwC,OAA5B;AACH,KA/ED;AAgFA;AACR;AACA;AACA;AACA;AACA;;;AACQ,SAAKC,OAAL,GAAe,MAAM;AACjB,WAAKC,gBAAL,CAAsBC,KAAtB;AACA,WAAKC,gBAAL;AACA,WAAKlB,WAAL,CAAiBmB,SAAjB,GAA6B,EAA7B;AACH,KAJD;AAKA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,SAAKC,YAAL,GAAqBC,UAAD,IAAgB;AAChC,UAAI,CAAC,KAAKC,kBAAL,EAAL,EAAgC;AAC5B,cAAM,IAAIC,KAAJ,CAAUtD,OAAO,CAACuD,kCAAlB,CAAN;AACH;;AACD,WAAKjC,QAAL,CAAckC,IAAd,CAAmB,cAAnB,EAAmCC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,UAAlB,CAAd,EAA6C;AAAEhB,QAAAA,KAAK,EAAE,KAAKD,KAAL,CAAWC;AAApB,OAA7C,CAAnC;AACH,KALD;AAMA;AACR;AACA;AACA;AACA;AACA;;;AACQ,SAAKuB,cAAL,GAAsB,MAAM;AACxB,UAAI,CAAC,KAAKN,kBAAL,EAAL,EAAgC;AAC5B,cAAM,IAAIC,KAAJ,CAAUtD,OAAO,CAACuD,kCAAlB,CAAN;AACH;;AACD,WAAKpB,KAAL,CAAWyB,QAAX,CAAoB,yBAApB,EAA+C,IAA/C;AACA,WAAKtC,QAAL,CAAckC,IAAd,CAAmB,qBAAnB;AACH,KAND;AAOA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,SAAKK,MAAL,GAAeC,IAAD,IAAU;AACpB,WAAKC,WAAL;AACA,WAAKC,oBAAL,CAA0B,eAA1B,EAA2C;AAAEC,QAAAA,KAAK,EAAER,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBI,IAAlB;AAAT,OAA3C;AACH,KAHD;;AAIA,SAAKC,WAAL,GAAmB,MAAM;AACrB,WAAKzC,QAAL,CAAckC,IAAd,CAAmB,oBAAnB;AACA,WAAKlC,QAAL,CAAckC,IAAd,CAAmB,qBAAnB;AACH,KAHD;;AAIA,SAAKU,uBAAL,GAA+B,CAAC7D,SAAD,EAAYsC,OAAZ,KAAwB;AACnD,UAAI3B,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;;AACA,YAAM;AAAEb,QAAAA;AAAF,UAAyB,KAAK6B,KAAL,CAAWC,KAA1C;AACA,YAAM;AAAE7B,QAAAA,KAAK,EAAEE,mBAAT;AAA8BD,QAAAA,MAAM,EAAEE;AAAtC,UAA+DJ,kBAArE;AACA,YAAMC,KAAK,GAAG,CAACU,EAAE,GAAG,CAACD,EAAE,GAAG2B,OAAN,MAAmB,IAAnB,IAA2B3B,EAAE,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,EAAE,CAACiD,KAA7D,MAAwE,IAAxE,IAAgFhD,EAAE,KAAK,KAAK,CAA5F,GAAgG,KAAK,CAArG,GAAyGA,EAAE,CAACV,KAA1H;AACA,YAAMC,MAAM,GAAG,CAACW,EAAE,GAAG,CAACD,EAAE,GAAGyB,OAAN,MAAmB,IAAnB,IAA2BzB,EAAE,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,EAAE,CAAC+C,KAA7D,MAAwE,IAAxE,IAAgF9C,EAAE,KAAK,KAAK,CAA5F,GAAgG,KAAK,CAArG,GAAyGA,EAAE,CAACX,MAA3H;AACA,YAAMG,WAAW,GAAGb,WAAW,CAACS,KAAD,CAA/B;AACA,YAAMK,YAAY,GAAGd,WAAW,CAACU,MAAD,CAAhC;AACA,WAAK2B,KAAL,CAAWyB,QAAX,CAAoB,uBAApB,EAA6CxD,qBAAqB,CAACC,SAAD,EAAYC,kBAAZ,EAAgCC,KAAhC,EAAuCC,MAAvC,CAAlE;;AACA,UAAI,CAACC,mBAAmB,IAAIC,oBAAxB,KAAiDf,QAAQ,CAACY,KAAD,CAAzD,IAAoEZ,QAAQ,CAACa,MAAD,CAAhF,EAA0F;AACtF,aAAKyC,gBAAL;AACH,OAFD,MAGK,IAAI,EAAExC,mBAAmB,IAAIC,oBAAzB,MAAmDC,WAAW,IAAIC,YAAlE,CAAJ,EAAqF;AACtF,aAAKuD,cAAL;AACH;AACJ,KAfD;;AAgBA,UAAM;AAAEC,MAAAA,EAAF;AAAMzB,MAAAA,OAAN;AAAe0B,MAAAA,MAAf;AAAuBC,MAAAA,UAAvB;AAAmCC,MAAAA;AAAnC,QAA+CxD,KAArD;AACA,SAAKwD,OAAL,GAAgBA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyCA,OAAzC,GAAmD,EAAnE;;AACA,QAAI3E,WAAW,CAAC+C,OAAO,CAAC6B,eAAT,CAAX,IAAwC7B,OAAO,CAAC6B,eAApD,EAAqE;AACjEvE,MAAAA,YAAY;AACf;;AACD,SAAK8B,WAAL,GAAmBqC,EAAnB;AACA,SAAKA,EAAL,GAAU,KAAKK,kBAAL,EAAV;AACA,SAAK1C,WAAL,CAAiB2C,WAAjB,CAA6B,KAAKN,EAAlC;AACA,SAAKO,QAAL,GAAgB,IAAInF,QAAJ,EAAhB;AACA,SAAK2C,KAAL,GAAa,IAAItD,KAAJ,CAAU;AACnBwF,MAAAA,MADmB;AAEnBC,MAAAA,UAFmB;AAGnB3B,MAAAA;AAHmB,KAAV,CAAb;AAKA,SAAKI,gBAAL,GAAwB,IAAIzD,gBAAJ,CAAqB;AACzC6C,MAAAA,KAAK,EAAE,KAAKA,KAD6B;AAEzCb,MAAAA,QAAQ,EAAE,KAAKA;AAF0B,KAArB,CAAxB;AAIA,SAAKA,QAAL,CAAcsB,EAAd,CAAiB,UAAjB,EAA6BnD,QAAQ,CAAC,MAAM;AACxC,UAAIuB,EAAJ,EAAQC,EAAR;;AACA,UAAI2D,QAAQ,GAAG,KAAKC,oBAAL,CAA0B,CAAC7D,EAAE,GAAG2B,OAAO,CAACsB,KAAd,MAAyB,IAAzB,IAAiCjD,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAAC8D,SAAvF,CAAf;;AACA,UAAI,KAAKtD,oBAAL,CAA0BC,QAA9B,EAAwC;AACpCmD,QAAAA,QAAQ,GAAGhF,WAAW,CAAC+C,OAAO,CAACoC,UAAT,CAAX,GACL,KAAKF,oBAAL,EADK,GAEL,KAAKA,oBAAL,CAA0B,CAAC5D,EAAE,GAAG0B,OAAO,CAACoC,UAAd,MAA8B,IAA9B,IAAsC9D,EAAE,KAAK,KAAK,CAAlD,GAAsD,KAAK,CAA3D,GAA+DA,EAAE,CAAC6D,SAA5F,CAFN;AAGA,aAAKtD,oBAAL,CAA0BC,QAA1B,GAAqC,KAArC;AACH;;AACD,WAAKH,QAAL,CAAckC,IAAd,CAAmB,WAAnB;AACA,WAAKmB,QAAL,CAAcK,GAAd,CAAkB;AACdC,QAAAA,WAAW,EAAE,MAAM;AACf,eAAK3D,QAAL,CAAckC,IAAd,CAAmB,cAAnB;AACH,SAHa;AAIdS,QAAAA,KAAK,EAAE,IAJO;AAKdW,QAAAA,QALc;AAMdM,QAAAA,SAAS,EAAE;AANG,OAAlB;AAQH,KAlBoC,EAkBlC,EAlBkC,CAArC;AAmBA,SAAK5D,QAAL,CAAcsB,EAAd,CAAiB,aAAjB,EAAiCuC,IAAD,IAAU;AACtC,WAAKR,QAAL,CAAcK,GAAd,CAAkBvB,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkByB,IAAlB,CAAd,EAAuC;AAAElB,QAAAA,KAAK,EAAE;AAAT,OAAvC,CAAlB;AACH,KAFD;AAGA,SAAK3C,QAAL,CAAcsB,EAAd,CAAiB,UAAjB,EAA6BnD,QAAQ,CAAC,MAAM;AACxC,WAAK2F,IAAL;AACH,KAFoC,EAElC,EAFkC,CAArC;AAGA,SAAKC,UAAL;AACA,SAAKlD,KAAL,CAAWmD,OAAX,CAAmB,MAAM;AACrB,WAAKjE,OAAL,CAAakE,KAAb;AACH,KAFD;;AAGA,QAAIzF,WAAW,CAAC,CAACmB,EAAE,GAAG,CAACD,EAAE,GAAG2B,OAAN,MAAmB,IAAnB,IAA2B3B,EAAE,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,EAAE,CAACiD,KAA7D,MAAwE,IAAxE,IAAgFhD,EAAE,KAAK,KAAK,CAA5F,GAAgG,KAAK,CAArG,GAAyGA,EAAE,CAACV,KAA7G,CAAX,IAAkIT,WAAW,CAAC,CAACqB,EAAE,GAAG,CAACD,EAAE,GAAGyB,OAAN,MAAmB,IAAnB,IAA2BzB,EAAE,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,EAAE,CAAC+C,KAA7D,MAAwE,IAAxE,IAAgF9C,EAAE,KAAK,KAAK,CAA5F,GAAgG,KAAK,CAArG,GAAyGA,EAAE,CAACX,MAA7G,CAAjJ,EAAuQ;AACnQ,WAAK2D,cAAL;AACH;AACJ;;AACDU,EAAAA,oBAAoB,CAACW,eAAD,EAAkB;AAClC,UAAM;AAAEC,MAAAA;AAAF,QAAqB,KAAKd,QAAhC;AACA,UAAM;AAAElD,MAAAA,QAAF;AAAYC,MAAAA;AAAZ,QAAyB,KAAKF,oBAApC;AACA,QAAIoD,QAAJ;;AACA,QAAK,CAACa,cAAD,IAAmB,CAAChE,QAArB,IAAkC7B,WAAW,CAAC4F,eAAD,CAAjD,EAAoE;AAChEZ,MAAAA,QAAQ,GAAGzE,qBAAX;AACH,KAFD,MAGK,IAAIT,SAAS,CAAC8F,eAAD,CAAb,EAAgC;AACjCZ,MAAAA,QAAQ,GAAGY,eAAe,GAAGrF,qBAAH,GAA2B,CAArD;AACH,KAFI,MAGA,IAAIR,QAAQ,CAAC6F,eAAe,CAACZ,QAAjB,CAAZ,EAAwC;AACzCA,MAAAA,QAAQ,GAAGY,eAAe,CAACZ,QAA3B;AACH;;AACD,QAAIlD,QAAJ,EAAc;AACVkD,MAAAA,QAAQ,GAAG,CAAX;AACH;;AACD,SAAKpD,oBAAL,CAA0BE,QAA1B,GAAqC,KAArC;AACA,WAAOkD,QAAP;AACH;;AACDH,EAAAA,kBAAkB,GAAG;AACjB,UAAML,EAAE,GAAGsB,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAX;AACAvB,IAAAA,EAAE,CAACwB,SAAH,CAAaZ,GAAb,CAAiB,uBAAjB;AACA,WAAOZ,EAAP;AACH;;AACDpC,EAAAA,eAAe,CAAC6D,cAAD,EAAiBC,eAAjB,EAAkC;AAC7C,SAAKtE,oBAAL,CAA0BC,QAA1B,GAAqC,IAArC;AACA,UAAM;AAAEnB,MAAAA,kBAAkB,EAAE;AAAEC,QAAAA,KAAK,EAAEE,mBAAT;AAA8BD,QAAAA,MAAM,EAAEE;AAAtC,OAAtB;AAAoFuD,MAAAA,KAAK,EAAE;AAAE1D,QAAAA,KAAF;AAASC,QAAAA;AAAT;AAA3F,QAAkH,KAAK2B,KAAL,CAAWC,KAAnI;;AACA,QAAI,EAAE3B,mBAAmB,IAAIC,oBAAzB,KACA,EAAEmF,cAAc,IAAIC,eAApB,CADA,IAECD,cAAc,KAAKtF,KAAnB,IAA4BuF,eAAe,KAAKtF,MAFrD,EAE8D;AAC1D,WAAKgB,oBAAL,CAA0BC,QAA1B,GAAqC,KAArC;AACA;AACH,KAR4C,CAS7C;;;AACA,SAAKsC,WAAL;AACA,SAAK5B,KAAL,CAAWyB,QAAX,CAAoB,cAApB,EAAoC;AAChCrD,MAAAA,KAAK,EAAEE,mBAAmB,GAAGoF,cAAH,GAAoBtF,KADd;AAEhCC,MAAAA,MAAM,EAAEE,oBAAoB,GAAGoF,eAAH,GAAqBtF;AAFjB,KAApC;AAIA,SAAK4E,IAAL;AACH;;AACDjB,EAAAA,cAAc,GAAG;AACb,UAAM;AAAE7D,MAAAA;AAAF,QAAyB,KAAK6B,KAAL,CAAWC,KAA1C;;AACA,QAAK9B,kBAAkB,CAACE,MAAnB,IAA6B,CAAC,KAAKuB,WAAL,CAAiBgE,KAAjB,CAAuBvF,MAAvB,CAA8BwF,MAA7D,IACC1F,kBAAkB,CAACC,KAAnB,IAA4B,CAAC,KAAKwB,WAAL,CAAiBgE,KAAjB,CAAuBxF,KAAvB,CAA6ByF,MAD/D,EACwE;AACpE,YAAM,IAAI1C,KAAJ,CAAUtD,OAAO,CAACiG,gCAAlB,CAAN;AACH;;AACD,UAAMC,wBAAwB,GAAG,OAAOC,cAAP,KAA0B,WAA3D;;AACA,QAAID,wBAAJ,EAA8B;AAC1BE,MAAAA,MAAM,CAACC,gBAAP,CAAwB,QAAxB,EAAkC,KAAKzE,mBAAvC;AACH,KAFD,MAGK;AACD,WAAKD,cAAL,GAAsB,IAAIwE,cAAJ,CAAoBG,OAAD,IAAa;AAClDA,QAAAA,OAAO,CAACC,OAAR,CAAgB,MAAM;AAClB,eAAK3E,mBAAL;AACH,SAFD;AAGH,OAJqB,CAAtB;AAKA,WAAKD,cAAL,CAAoB2D,OAApB,CAA4B,KAAKvD,WAAjC;AACH;AACJ;;AACDkB,EAAAA,gBAAgB,GAAG;AACf,QAAI,KAAKtB,cAAT,EAAyB;AACrB,WAAKA,cAAL,CAAoB6E,SAApB,CAA8B,KAAKzE,WAAnC;AACA,WAAKJ,cAAL,CAAoB8E,UAApB;AACA,WAAK9E,cAAL,GAAsB,IAAtB;AACH,KAJD,MAKK;AACDyE,MAAAA,MAAM,CAACM,mBAAP,CAA2B,QAA3B,EAAqC,KAAK9E,mBAA1C;AACH;AACJ;;AACD+E,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAM;AAAEC,MAAAA,OAAF;AAAWC,MAAAA,OAAX;AAAoBC,MAAAA,IAAI,EAAEC;AAA1B,QAAwCJ,KAA9C;AACA,UAAMK,gBAAgB,GAAI,KAAID,SAAS,CAAC,CAAD,CAAT,CAAaE,WAAb,KAA6BF,SAAS,CAACG,SAAV,CAAoB,CAApB,CAAuB,EAAlF;AACA,UAAMC,MAAM,GAAG,KAAK/F,OAAL,CAAagG,GAAb,CAAiBD,MAAhC;AACA,UAAME,UAAU,GAAGF,MAAM,CAACG,qBAAP,EAAnB,CAJe,CAKf;;AACA,UAAMC,MAAM,GAAGF,UAAU,CAAC/G,KAAX,GAAmB6G,MAAM,CAACvF,WAAzC;AACA,UAAM4F,MAAM,GAAGH,UAAU,CAAC9G,MAAX,GAAoB4G,MAAM,CAACtF,YAA1C;AACA,UAAM4F,aAAa,GAAG;AAClBC,MAAAA,CAAC,EAAE,CAACd,OAAO,GAAGS,UAAU,CAACM,IAAtB,IAA8BJ,MADf;AAElBK,MAAAA,CAAC,EAAE,CAACf,OAAO,GAAGQ,UAAU,CAACQ,GAAtB,IAA6BL;AAFd,KAAtB;AAIA,UAAMM,oBAAoB,GAAG,EAA7B;;AACA,QAAIf,SAAS,KAAK,WAAlB,EAA+B;AAC3B,WAAKjE,gBAAL,CAAsBwD,OAAtB,CAA+ByB,SAAD,IAAe;AACzC,cAAM;AAAEL,UAAAA,CAAF;AAAKE,UAAAA,CAAL;AAAQrH,UAAAA,MAAR;AAAgBD,UAAAA;AAAhB,YAA0ByH,SAAS,CAACC,IAA1C;AACA,cAAMC,KAAK,GAAG,KAAK3G,iBAAL,CAAuB4G,IAAvB,CAA6BC,gBAAD,IAAsBA,gBAAgB,KAAKJ,SAAvE,CAAd;AACA,cAAMK,OAAO,GAAGX,aAAa,CAACC,CAAd,IAAmBA,CAAnB,IACZD,aAAa,CAACC,CAAd,IAAmBA,CAAC,GAAGpH,KADX,IAEZmH,aAAa,CAACG,CAAd,IAAmBA,CAFP,IAGZH,aAAa,CAACG,CAAd,IAAmBA,CAAC,GAAGrH,MAH3B;;AAIA,YAAI6H,OAAJ,EAAa;AACTN,UAAAA,oBAAoB,CAACO,IAArB,CAA0BN,SAA1B;;AACA,cAAI,CAACE,KAAD,IAAUF,SAAS,CAACO,qBAAxB,EAA+C;AAC3CP,YAAAA,SAAS,CAACO,qBAAV;AACH;AACJ,SALD,MAMK,IAAIL,KAAK,IAAIF,SAAS,CAACQ,mBAAvB,EAA4C;AAC7CR,UAAAA,SAAS,CAACQ,mBAAV;AACH;AACJ,OAhBD;AAiBA,WAAKjH,iBAAL,GAAyBwG,oBAAzB;AACH;;AACD,UAAMU,aAAa,GAAG,EAAtB;AACA,SAAK1F,gBAAL,CAAsBwD,OAAtB,CAA+ByB,SAAD,IAAe;AACzC,UAAI,CAACA,SAAS,CAACf,gBAAD,CAAd,EAAkC;AAC9B;AACH;;AACD,UAAI,CAAClH,kBAAkB,CAACkI,IAAnB,CAAwBP,aAAxB,EAAuCM,SAAS,CAACC,IAAjD,CAAL,EAA6D;AACzD;AACH;;AACD,YAAMS,QAAQ,GAAG,CAACV,SAAS,CAACW,UAAV,IAAwB,EAAzB,EAA6BtG,MAA7B,CAAqCuG,CAAD,IAAO;AACxD,eAAO7I,kBAAkB,CAAC6I,CAAC,CAAC7B,IAAH,CAAlB,CAA2BW,aAA3B,EAA0CkB,CAA1C,EAA6CZ,SAAS,CAACC,IAAvD,CAAP;AACH,OAFgB,CAAjB;;AAGA,UAAIS,QAAQ,CAAC1C,MAAb,EAAqB;AACjByC,QAAAA,aAAa,CAACH,IAAd,CAAmB;AAAEN,UAAAA,SAAF;AAAaU,UAAAA;AAAb,SAAnB;AACH;;AACDV,MAAAA,SAAS,CAACf,gBAAD,CAAT,CAA4B;AAAES,QAAAA,aAAF;AAAiBiB,QAAAA,UAAU,EAAED;AAA7B,OAA5B,EAAqE9B,KAArE;AACH,KAdD;;AAeA,QAAI,KAAKiC,2BAAT,EAAsC;AAClC,WAAKA,2BAAL,CAAiCjC,KAAjC,EAAwC6B,aAAxC,EAAuDxB,gBAAvD,EAAyES,aAAzE;AACH;AACJ;;AACDoB,EAAAA,SAAS,GAAG;AACR,KACIhK,IADJ,EAEIK,YAFJ,EAGIC,KAHJ,EAIIJ,UAJJ,EAKIE,MALJ,EAMIH,MANJ,EAOIE,QAPJ,EAQI,GAAG,KAAKsF,OARZ,EASEgC,OATF,CASWwC,MAAD,IAAY,KAAK5G,KAAL,CAAW6G,SAAX,CAAqBD,MAArB,CATtB;AAUH;;AACD1D,EAAAA,UAAU,GAAG;AACT,SAAKyD,SAAL;AACA,SAAK3G,KAAL,CAAWyB,QAAX,CAAoB,eAApB,EAAqC,KAAK7B,WAA1C;AACH;;AACDqD,EAAAA,IAAI,GAAG;AACH,SAAK/D,OAAL,CAAa4H,WAAb;AACA,SAAKlG,gBAAL,CAAsBwD,OAAtB,CAA+ByB,SAAD,IAAe;AACzC,UAAI,CAACA,SAAS,CAACkB,MAAf,EAAuB;AACnB;AACH;;AACD,WAAK7H,OAAL,CAAa8H,UAAb,CAAwBnB,SAAS,CAACC,IAAV,CAAeN,CAAvC,EAA0CK,SAAS,CAACC,IAAV,CAAeJ,CAAzD;;AACA,UAAIG,SAAS,CAACmB,UAAd,EAA0B;AACtBnB,QAAAA,SAAS,CAACmB,UAAV,CAAqB,KAAK9H,OAA1B;AACH;;AACD2G,MAAAA,SAAS,CAAC5C,IAAV,CAAe,KAAK/D,OAApB;AACA,WAAKA,OAAL,CAAa+H,SAAb;AACH,KAVD;AAWH;;AACDC,EAAAA,MAAM,CAACC,KAAD,EAAQ;AACV,SAAKvG,gBAAL,CAAsBwG,MAAtB,CAA6B,QAA7B,EAAuCD,KAAvC;AACH;;AACDE,EAAAA,UAAU,CAACF,KAAD,EAAQ;AACd,SAAKvG,gBAAL,CAAsBwG,MAAtB,CAA6B,YAA7B,EAA2CD,KAA3C;AACH;;AACDjG,EAAAA,kBAAkB,GAAG;AACjB,QAAIrC,EAAJ;;AACA,WAAO,CAACA,EAAE,GAAG,KAAKmB,KAAL,CAAWO,cAAX,CAA0BC,OAA1B,CAAkC0B,MAAxC,MAAoD,IAApD,IAA4DrD,EAAE,KAAK,KAAK,CAAxE,GAA4E,KAAK,CAAjF,GAAqFA,EAAE,CAACyI,UAA/F;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,gBAAgB,CAACC,MAAD,EAAS;AACrB,UAAM;AAAEhC,MAAAA,CAAC,EAAEiC,OAAL;AAAc/B,MAAAA,CAAC,EAAEgC;AAAjB,QAA6BF,MAAnC;AACA,SAAKxH,KAAL,CAAWyB,QAAX,CAAoB,eAApB,EAAqC;AAAEjB,MAAAA,OAAO,EAAE;AAAEmH,QAAAA,OAAO,EAAE;AAAEF,UAAAA,OAAF;AAAWC,UAAAA;AAAX;AAAX;AAAX,KAArC;AACH;;AACD7F,EAAAA,oBAAoB,CAAC3D,SAAD,EAAYsC,OAAZ,EAAqB;AACrC,SAAKuB,uBAAL,CAA6B7D,SAA7B,EAAwCsC,OAAxC;AACA,UAAM;AAAEd,MAAAA,WAAF;AAAeC,MAAAA;AAAf,QAAgC,KAAKC,WAA3C;AACA,SAAKI,KAAL,CAAWyB,QAAX,CAAoBvD,SAApB,EAA+B;AAC3BsC,MAAAA,OAD2B;AAE3BoH,MAAAA,aAAa,EAAE;AAAExJ,QAAAA,KAAK,EAAEsB,WAAT;AAAsBrB,QAAAA,MAAM,EAAEsB;AAA9B;AAFY,KAA/B;AAIH;;AAjbsB","sourcesContent":["import Store from \"../store/store\";\nimport root from \"../store/root\";\nimport layout from \"../store/layout\";\nimport seriesData from \"../store/seriesData\";\nimport category from \"../store/category\";\nimport legend from \"../store/legend\";\nimport optionsStore from \"../store/options\";\nimport theme from \"../store/theme\";\nimport EventEmitter from \"../eventEmitter\";\nimport ComponentManager from \"../component/componentManager\";\nimport Painter from \"../painter\";\nimport Animator from \"../animator\";\nimport { debounce, isBoolean, isNumber, isUndefined, pick, isAutoValue } from \"../helpers/utils\";\nimport { responderDetectors } from \"../responderDetectors\";\nimport { message } from \"../message\";\nimport { sendHostname } from \"../helpers/googleAnalytics\";\nimport { makeObservableObjectToNormal } from \"../store/reactive\";\nexport const DEFAULT_ANIM_DURATION = 500;\nfunction getUsingContainerSize(eventName, usingContainerSize, width, height) {\n    const { width: usingContainerWidth, height: usingContainerHeight } = usingContainerSize;\n    const isAutoWidth = isAutoValue(width);\n    const isAutoHeight = isAutoValue(height);\n    return eventName === 'updateOptions'\n        ? {\n            width: !isUndefined(width) && usingContainerWidth !== isAutoWidth\n                ? isAutoWidth\n                : usingContainerWidth,\n            height: !isUndefined(height) && usingContainerHeight !== isAutoHeight\n                ? isAutoHeight\n                : usingContainerHeight,\n        }\n        : {\n            width: isAutoWidth,\n            height: isAutoHeight,\n        };\n}\n/**\n * @class\n * @abstract\n * Abstract class used to implement each chart.\n */\nexport default class Chart {\n    constructor(props) {\n        var _a, _b, _c, _d;\n        this.___animId___ = null;\n        this.painter = new Painter(this);\n        this.eventBus = new EventEmitter();\n        this.enteredComponents = [];\n        this.animationControlFlag = {\n            resizing: false,\n            updating: false,\n        };\n        this.resizeObserver = null;\n        this.debounceResizeEvent = debounce(() => {\n            const { offsetWidth, offsetHeight } = this.containerEl;\n            this.resizeChartSize(offsetWidth, offsetHeight);\n        }, 100);\n        /**\n         * Get checked legend chart type and label, checked state.\n         * @returns {Array<{checked: boolean, chartType: string, label: string}>} Array data that whether series has checked\n         * @api\n         * @example\n         * const checkedLegend = chart.getCheckedLegend()\n         */\n        this.getCheckedLegend = () => {\n            const { data } = this.store.state.legend;\n            return data\n                .filter((datum) => datum.checked)\n                .map((datum) => pick(datum, 'chartType', 'label', 'checked'));\n        };\n        /**\n         * Returns the currently applied chart options.\n         * @returns {Object} options\n         * @api\n         * @example\n         * const options = chart.getOptions();\n         */\n        this.getOptions = () => {\n            return makeObservableObjectToNormal(this.store.initStoreState.options);\n        };\n        /**\n         * Register of user custom event.\n         * @param {string} eventName - Event name. 'clickLegendLabel', 'clickLegendCheckbox', 'selectSeries', 'unselectSeries', 'hoverSeries', 'unhoverSeries', 'zoom', 'resetZoom' is available.\n         * @param {Function} handler - Event handler\n         * @api\n         */\n        this.on = (eventName, handler) => {\n            /**\n             * Register Events that occur when click legend label\n             * @event ChartBase#clickLegendLabel\n             * @param {object} info selected legend information\n             * @api\n             * @example\n             * chart.on('clickLegendLabel', (info) => {\n             *   console.log(info);\n             * });\n             */\n            /**\n             * Register Events that occur when click legend checkbox\n             * @event ChartBase#clickLegendCheckbox\n             * @param {object} info selected legend info\n             * @api\n             * @example\n             * chart.on('clickLegendCheckbox', (info) => {\n             *   console.log(info);\n             * });\n             */\n            /**\n             * Register Events that occur when select series\n             * @event ChartBase#selectSeries\n             * @param {object} info selected series info\n             * @api\n             * @example\n             * chart.on('selectSeries', (info) => {\n             *   console.log(info);\n             * });\n             */\n            /**\n             * Register Events that occur when unselect series\n             * @event ChartBase#unselectSeries\n             * @param {object} info unselected series info\n             * @api\n             * @example\n             * chart.on('unselectSeries', (info) => {\n             *   console.log(info);\n             * });\n             */\n            /**\n             * Register Events that occur when hover to series\n             * @event ChartBase#hoverSeries\n             * @param {object} info hovered series info\n             * @api\n             * @example\n             * chart.on('hoverSeries', (info) => {\n             *   console.log(info);\n             * });\n             */\n            /**\n             * Register Events that occur when unhover from series\n             * @event ChartBase#unhoverSeries\n             * @param {object} info unhovered series info\n             * @api\n             * @example\n             * chart.on('unhoverSeries', (info) => {\n             *  console.log(info);\n             * });\n             */\n            /**\n             * Register Events that occur when zooming\n             * @event ChartBase#zoom\n             * @param {string[]} dataRange - []\n             * @api\n             * @example\n             * chart.on('zoom', (dataRange) => {\n             *    console.log(dataRange);\n             * });\n             */\n            /**\n             * Register Events that occur when zoom is reset\n             * @event ChartBase#resetZoom\n             * @api\n             * @example\n             * chart.on('resetZoom', () => {});\n             */\n            this.eventBus.on(eventName, handler);\n        };\n        /**\n         * Destroys the instance.\n         * @api\n         * @example\n         * chart.destroy();\n         */\n        this.destroy = () => {\n            this.componentManager.clear();\n            this.clearResizeEvent();\n            this.containerEl.innerHTML = '';\n        };\n        /**\n         * Select series. It works only when the selectable option is true.\n         * @param {Object} seriesInfo - Information of the series to be selected\n         *      @param {number} [seriesInfo.seriesIndex] - Index of series\n         *      @param {number} [seriesInfo.index] - Index of data within series\n         *      @param {string} [seriesInfo.name] - Specify name for NestedPie Chart\n         *      @param {string} [seriesInfo.chartType] - Specify which chart to select when using LineArea, LineScatter, and ColumnLine charts.specifies which chart to select when using LineArea, LineScatter, and ColumnLine charts.\n         * @api\n         * @example\n         * chart.selectSeries({index: 1, seriesIndex: 2});\n         */\n        this.selectSeries = (seriesInfo) => {\n            if (!this.isSelectableSeries()) {\n                throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);\n            }\n            this.eventBus.emit('selectSeries', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));\n        };\n        /**\n         * Unselect selected series. It works only when the selectable option is true.\n         * @api\n         * @example\n         * chart.unselectSeries();\n         */\n        this.unselectSeries = () => {\n            if (!this.isSelectableSeries()) {\n                throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);\n            }\n            this.store.dispatch('setAllLegendActiveState', true);\n            this.eventBus.emit('resetSelectedSeries');\n        };\n        /**\n         * Resize chart size.\n         * @param {Object} size Chart size\n         *   @param {number} [size.width] Width\n         *   @param {number} [size.height] Height\n         * @api\n         * @example\n         * chart.resize({height: 100, width: 200});\n         */\n        this.resize = (size) => {\n            this.resetSeries();\n            this.dispatchOptionsEvent('updateOptions', { chart: Object.assign({}, size) });\n        };\n        this.resetSeries = () => {\n            this.eventBus.emit('resetHoveredSeries');\n            this.eventBus.emit('resetSelectedSeries');\n        };\n        this.setResizeEventListeners = (eventName, options) => {\n            var _a, _b, _c, _d;\n            const { usingContainerSize } = this.store.state;\n            const { width: usingContainerWidth, height: usingContainerHeight } = usingContainerSize;\n            const width = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.chart) === null || _b === void 0 ? void 0 : _b.width;\n            const height = (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.chart) === null || _d === void 0 ? void 0 : _d.height;\n            const isAutoWidth = isAutoValue(width);\n            const isAutoHeight = isAutoValue(height);\n            this.store.dispatch('setUsingContainerSize', getUsingContainerSize(eventName, usingContainerSize, width, height));\n            if ((usingContainerWidth || usingContainerHeight) && isNumber(width) && isNumber(height)) {\n                this.clearResizeEvent();\n            }\n            else if (!(usingContainerWidth || usingContainerHeight) && (isAutoWidth || isAutoHeight)) {\n                this.setResizeEvent();\n            }\n        };\n        const { el, options, series, categories, modules } = props;\n        this.modules = (modules !== null && modules !== void 0 ? modules : []);\n        if (isUndefined(options.usageStatistics) || options.usageStatistics) {\n            sendHostname();\n        }\n        this.containerEl = el;\n        this.el = this.createChartWrapper();\n        this.containerEl.appendChild(this.el);\n        this.animator = new Animator();\n        this.store = new Store({\n            series,\n            categories,\n            options,\n        });\n        this.componentManager = new ComponentManager({\n            store: this.store,\n            eventBus: this.eventBus,\n        });\n        this.eventBus.on('needLoop', debounce(() => {\n            var _a, _b;\n            let duration = this.getAnimationDuration((_a = options.chart) === null || _a === void 0 ? void 0 : _a.animation);\n            if (this.animationControlFlag.resizing) {\n                duration = isUndefined(options.responsive)\n                    ? this.getAnimationDuration()\n                    : this.getAnimationDuration((_b = options.responsive) === null || _b === void 0 ? void 0 : _b.animation);\n                this.animationControlFlag.resizing = false;\n            }\n            this.eventBus.emit('loopStart');\n            this.animator.add({\n                onCompleted: () => {\n                    this.eventBus.emit('loopComplete');\n                },\n                chart: this,\n                duration,\n                requester: this,\n            });\n        }, 10));\n        this.eventBus.on('needSubLoop', (opts) => {\n            this.animator.add(Object.assign(Object.assign({}, opts), { chart: this }));\n        });\n        this.eventBus.on('needDraw', debounce(() => {\n            this.draw();\n        }, 10));\n        this.initialize();\n        this.store.observe(() => {\n            this.painter.setup();\n        });\n        if (isAutoValue((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.chart) === null || _b === void 0 ? void 0 : _b.width) || isAutoValue((_d = (_c = options) === null || _c === void 0 ? void 0 : _c.chart) === null || _d === void 0 ? void 0 : _d.height)) {\n            this.setResizeEvent();\n        }\n    }\n    getAnimationDuration(animationOption) {\n        const { firstRendering } = this.animator;\n        const { resizing, updating } = this.animationControlFlag;\n        let duration;\n        if ((!firstRendering && !resizing) || isUndefined(animationOption)) {\n            duration = DEFAULT_ANIM_DURATION;\n        }\n        else if (isBoolean(animationOption)) {\n            duration = animationOption ? DEFAULT_ANIM_DURATION : 0;\n        }\n        else if (isNumber(animationOption.duration)) {\n            duration = animationOption.duration;\n        }\n        if (updating) {\n            duration = 0;\n        }\n        this.animationControlFlag.updating = false;\n        return duration;\n    }\n    createChartWrapper() {\n        const el = document.createElement('div');\n        el.classList.add('toastui-chart-wrapper');\n        return el;\n    }\n    resizeChartSize(containerWidth, containerHeight) {\n        this.animationControlFlag.resizing = true;\n        const { usingContainerSize: { width: usingContainerWidth, height: usingContainerHeight }, chart: { width, height }, } = this.store.state;\n        if (!(usingContainerWidth || usingContainerHeight) ||\n            !(containerWidth || containerHeight) ||\n            (containerWidth === width && containerHeight === height)) {\n            this.animationControlFlag.resizing = false;\n            return;\n        }\n        // @TODO: For updates where the data doesn't change, it looks good to recalculate the selected series position.\n        this.resetSeries();\n        this.store.dispatch('setChartSize', {\n            width: usingContainerWidth ? containerWidth : width,\n            height: usingContainerHeight ? containerHeight : height,\n        });\n        this.draw();\n    }\n    setResizeEvent() {\n        const { usingContainerSize } = this.store.state;\n        if ((usingContainerSize.height && !this.containerEl.style.height.length) ||\n            (usingContainerSize.width && !this.containerEl.style.width.length)) {\n            throw new Error(message.AUTO_LAYOUT_CONTAINER_SIZE_ERROR);\n        }\n        const isResizeObserverAPIExist = typeof ResizeObserver === 'undefined';\n        if (isResizeObserverAPIExist) {\n            window.addEventListener('resize', this.debounceResizeEvent);\n        }\n        else {\n            this.resizeObserver = new ResizeObserver((entries) => {\n                entries.forEach(() => {\n                    this.debounceResizeEvent();\n                });\n            });\n            this.resizeObserver.observe(this.containerEl);\n        }\n    }\n    clearResizeEvent() {\n        if (this.resizeObserver) {\n            this.resizeObserver.unobserve(this.containerEl);\n            this.resizeObserver.disconnect();\n            this.resizeObserver = null;\n        }\n        else {\n            window.removeEventListener('resize', this.debounceResizeEvent);\n        }\n    }\n    handleEvent(event) {\n        const { clientX, clientY, type: eventType } = event;\n        const delegationMethod = `on${eventType[0].toUpperCase() + eventType.substring(1)}`;\n        const canvas = this.painter.ctx.canvas;\n        const canvasRect = canvas.getBoundingClientRect();\n        // Calculate scale for chart affected by a CSS transform.\n        const scaleX = canvasRect.width / canvas.offsetWidth;\n        const scaleY = canvasRect.height / canvas.offsetHeight;\n        const mousePosition = {\n            x: (clientX - canvasRect.left) / scaleX,\n            y: (clientY - canvasRect.top) / scaleY,\n        };\n        const newEnteredComponents = [];\n        if (eventType === 'mousemove') {\n            this.componentManager.forEach((component) => {\n                const { x, y, height, width } = component.rect;\n                const exist = this.enteredComponents.some((enteredComponent) => enteredComponent === component);\n                const entered = mousePosition.x >= x &&\n                    mousePosition.x <= x + width &&\n                    mousePosition.y >= y &&\n                    mousePosition.y <= y + height;\n                if (entered) {\n                    newEnteredComponents.push(component);\n                    if (!exist && component.onMouseenterComponent) {\n                        component.onMouseenterComponent();\n                    }\n                }\n                else if (exist && component.onMouseoutComponent) {\n                    component.onMouseoutComponent();\n                }\n            });\n            this.enteredComponents = newEnteredComponents;\n        }\n        const allResponders = [];\n        this.componentManager.forEach((component) => {\n            if (!component[delegationMethod]) {\n                return;\n            }\n            if (!responderDetectors.rect(mousePosition, component.rect)) {\n                return;\n            }\n            const detected = (component.responders || []).filter((m) => {\n                return responderDetectors[m.type](mousePosition, m, component.rect);\n            });\n            if (detected.length) {\n                allResponders.push({ component, detected });\n            }\n            component[delegationMethod]({ mousePosition, responders: detected }, event);\n        });\n        if (this.handleEventForAllResponders) {\n            this.handleEventForAllResponders(event, allResponders, delegationMethod, mousePosition);\n        }\n    }\n    initStore() {\n        [\n            root,\n            optionsStore,\n            theme,\n            seriesData,\n            legend,\n            layout,\n            category,\n            ...this.modules,\n        ].forEach((module) => this.store.setModule(module));\n    }\n    initialize() {\n        this.initStore();\n        this.store.dispatch('initChartSize', this.containerEl);\n    }\n    draw() {\n        this.painter.beforeFrame();\n        this.componentManager.forEach((component) => {\n            if (!component.isShow) {\n                return;\n            }\n            this.painter.beforeDraw(component.rect.x, component.rect.y);\n            if (component.beforeDraw) {\n                component.beforeDraw(this.painter);\n            }\n            component.draw(this.painter);\n            this.painter.afterDraw();\n        });\n    }\n    update(delta) {\n        this.componentManager.invoke('update', delta);\n    }\n    initUpdate(delta) {\n        this.componentManager.invoke('initUpdate', delta);\n    }\n    isSelectableSeries() {\n        var _a;\n        return (_a = this.store.initStoreState.options.series) === null || _a === void 0 ? void 0 : _a.selectable;\n    }\n    /**\n     * Set tooltip offset.\n     * @param {Object} offset - Offset size\n     *   @param {number} [offset.x] Offset value to move title horizontally\n     *   @param {number} [offset.y] Offset value to move title vertically\n     * @api\n     * @example\n     * chart.setTooltipOffset({x: 10, y: -20});\n     */\n    setTooltipOffset(offset) {\n        const { x: offsetX, y: offsetY } = offset;\n        this.store.dispatch('updateOptions', { options: { tooltip: { offsetX, offsetY } } });\n    }\n    dispatchOptionsEvent(eventName, options) {\n        this.setResizeEventListeners(eventName, options);\n        const { offsetWidth, offsetHeight } = this.containerEl;\n        this.store.dispatch(eventName, {\n            options,\n            containerSize: { width: offsetWidth, height: offsetHeight },\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}