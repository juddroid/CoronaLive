{"ast":null,"code":"import Component from \"./component\";\nimport { makeTickPixelPositions, crispPixel } from \"../helpers/calculator\";\nimport { TICK_SIZE } from \"../brushes/axis\";\nimport { includes } from \"../helpers/utils\";\nimport { getAxisTheme } from \"../helpers/axes\";\nimport { getTitleFontString } from \"../helpers/style\";\nexport var AxisType;\n\n(function (AxisType) {\n  AxisType[\"X\"] = \"xAxis\";\n  AxisType[\"Y\"] = \"yAxis\";\n  AxisType[\"SECONDARY_Y\"] = \"secondaryYAxis\";\n})(AxisType || (AxisType = {}));\n\nfunction getOffsetAndAnchorKey(hasBasedYAxis) {\n  return {\n    offsetKey: hasBasedYAxis ? 'y' : 'x',\n    anchorKey: hasBasedYAxis ? 'x' : 'y'\n  };\n}\n\nexport default class Axis extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      label: [],\n      tick: [],\n      axisLine: []\n    };\n    this.axisSize = 0;\n  }\n\n  initialize({\n    name\n  }) {\n    this.type = 'axis';\n    this.name = name;\n    this.yAxisComponent = includes([AxisType.Y, AxisType.SECONDARY_Y], name);\n  }\n\n  render({\n    layout,\n    axes,\n    theme\n  }) {\n    if (axes.centerYAxis || !axes[this.name]) {\n      return;\n    }\n\n    this.theme = getAxisTheme(theme, this.name);\n    this.rect = layout[this.name];\n    this.axisSize = this.yAxisComponent ? this.rect.height : this.rect.width;\n    const {\n      viewLabels\n    } = axes[this.name];\n    const {\n      offsetKey,\n      anchorKey\n    } = getOffsetAndAnchorKey(this.yAxisComponent);\n    const renderOptions = this.makeRenderOptions(axes[this.name]);\n    const hasOnlyAxisLine = this.hasOnlyAxisLine();\n\n    if (!hasOnlyAxisLine) {\n      this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);\n      this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);\n    }\n\n    this.models.axisLine = [this.renderAxisLineModel()];\n\n    if (!this.drawModels) {\n      this.drawModels = {\n        tick: [],\n        label: [],\n        axisLine: this.models.axisLine\n      };\n      ['tick', 'label'].forEach(type => {\n        this.drawModels[type] = this.models[type].map(m => {\n          const drawModel = Object.assign({}, m);\n\n          if (this.yAxisComponent) {\n            drawModel.y = 0;\n          } else {\n            drawModel.x = 0;\n          }\n\n          return drawModel;\n        });\n      });\n    }\n  }\n\n  renderAxisLineModel() {\n    const zeroPixel = crispPixel(0);\n    let lineModel;\n    const {\n      color: strokeStyle,\n      width: lineWidth\n    } = this.theme;\n\n    if (this.yAxisComponent) {\n      const x = this.getYAxisXPoint();\n      lineModel = {\n        type: 'line',\n        x,\n        y: zeroPixel,\n        x2: x,\n        y2: crispPixel(this.axisSize),\n        strokeStyle,\n        lineWidth\n      };\n    } else {\n      lineModel = {\n        type: 'line',\n        x: zeroPixel,\n        y: zeroPixel,\n        x2: crispPixel(this.axisSize),\n        y2: zeroPixel,\n        strokeStyle,\n        lineWidth\n      };\n    }\n\n    return lineModel;\n  }\n\n  renderTickModels(offsetKey, anchorKey, renderOptions) {\n    const tickAnchorPoint = this.yAxisComponent ? this.getYAxisXPoint() : crispPixel(0);\n    const {\n      tickInterval,\n      relativePositions\n    } = renderOptions;\n    const tickSize = includes([AxisType.SECONDARY_Y, AxisType.X], this.name) ? TICK_SIZE : -TICK_SIZE;\n    return relativePositions.reduce((positions, position, index) => {\n      return index % tickInterval ? positions : [...positions, {\n        type: 'tick',\n        isYAxis: this.yAxisComponent,\n        tickSize,\n        [offsetKey]: crispPixel(position),\n        [anchorKey]: tickAnchorPoint,\n        strokeStyle: this.theme.color,\n        lineWidth: this.theme.width\n      }];\n    }, []);\n  }\n\n  renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {\n    const {\n      needRotateLabel,\n      radian,\n      offsetY\n    } = renderOptions;\n    const labelTheme = this.theme.label;\n    const font = getTitleFontString(labelTheme);\n    const textAlign = this.getLabelTextAlign(needRotateLabel);\n    const style = ['default', {\n      textAlign,\n      font,\n      fillStyle: labelTheme.color\n    }];\n    const labelAnchorPoint = this.yAxisComponent ? this.getYAxisAnchorPoint() : offsetY;\n    return labels.map(({\n      text,\n      offsetPos\n    }) => ({\n      type: 'label',\n      text,\n      style,\n      radian,\n      [offsetKey]: crispPixel(offsetPos),\n      [anchorKey]: labelAnchorPoint\n    }));\n  }\n\n  makeRenderOptions(axisData) {\n    const {\n      tickCount,\n      tickInterval\n    } = axisData;\n    const relativePositions = makeTickPixelPositions(this.axisSize, tickCount);\n\n    if (this.yAxisComponent) {\n      return {\n        relativePositions,\n        tickInterval\n      };\n    }\n\n    const {\n      needRotateLabel,\n      radian,\n      offsetY\n    } = axisData;\n    return {\n      relativePositions,\n      tickInterval,\n      needRotateLabel,\n      radian,\n      offsetY\n    };\n  }\n\n  getYAxisAnchorPoint() {\n    return this.isRightSide() ? crispPixel(this.rect.width) : crispPixel(0);\n  }\n\n  getLabelTextAlign(needRotateLabel) {\n    const yAxisTextAlign = this.isRightSide() ? 'right' : 'left';\n    const xAxisTextAlign = needRotateLabel ? 'left' : 'center';\n    return this.yAxisComponent ? yAxisTextAlign : xAxisTextAlign;\n  }\n\n  isRightSide() {\n    return this.name === AxisType.SECONDARY_Y;\n  }\n\n  getYAxisXPoint() {\n    return this.isRightSide() ? crispPixel(0) : crispPixel(this.rect.width);\n  }\n\n  hasOnlyAxisLine() {\n    return this.yAxisComponent && !this.rect.width || this.name === AxisType.X && !this.rect.height;\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/axis.js"],"names":["Component","makeTickPixelPositions","crispPixel","TICK_SIZE","includes","getAxisTheme","getTitleFontString","AxisType","getOffsetAndAnchorKey","hasBasedYAxis","offsetKey","anchorKey","Axis","constructor","arguments","models","label","tick","axisLine","axisSize","initialize","name","type","yAxisComponent","Y","SECONDARY_Y","render","layout","axes","theme","centerYAxis","rect","height","width","viewLabels","renderOptions","makeRenderOptions","hasOnlyAxisLine","renderLabelModels","renderTickModels","renderAxisLineModel","drawModels","forEach","map","m","drawModel","Object","assign","y","x","zeroPixel","lineModel","color","strokeStyle","lineWidth","getYAxisXPoint","x2","y2","tickAnchorPoint","tickInterval","relativePositions","tickSize","X","reduce","positions","position","index","isYAxis","labels","needRotateLabel","radian","offsetY","labelTheme","font","textAlign","getLabelTextAlign","style","fillStyle","labelAnchorPoint","getYAxisAnchorPoint","text","offsetPos","axisData","tickCount","isRightSide","yAxisTextAlign","xAxisTextAlign"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { makeTickPixelPositions, crispPixel } from \"../helpers/calculator\";\nimport { TICK_SIZE } from \"../brushes/axis\";\nimport { includes } from \"../helpers/utils\";\nimport { getAxisTheme } from \"../helpers/axes\";\nimport { getTitleFontString } from \"../helpers/style\";\nexport var AxisType;\n(function (AxisType) {\n    AxisType[\"X\"] = \"xAxis\";\n    AxisType[\"Y\"] = \"yAxis\";\n    AxisType[\"SECONDARY_Y\"] = \"secondaryYAxis\";\n})(AxisType || (AxisType = {}));\nfunction getOffsetAndAnchorKey(hasBasedYAxis) {\n    return {\n        offsetKey: hasBasedYAxis ? 'y' : 'x',\n        anchorKey: hasBasedYAxis ? 'x' : 'y',\n    };\n}\nexport default class Axis extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { label: [], tick: [], axisLine: [] };\n        this.axisSize = 0;\n    }\n    initialize({ name }) {\n        this.type = 'axis';\n        this.name = name;\n        this.yAxisComponent = includes([AxisType.Y, AxisType.SECONDARY_Y], name);\n    }\n    render({ layout, axes, theme }) {\n        if (axes.centerYAxis || !axes[this.name]) {\n            return;\n        }\n        this.theme = getAxisTheme(theme, this.name);\n        this.rect = layout[this.name];\n        this.axisSize = this.yAxisComponent ? this.rect.height : this.rect.width;\n        const { viewLabels } = axes[this.name];\n        const { offsetKey, anchorKey } = getOffsetAndAnchorKey(this.yAxisComponent);\n        const renderOptions = this.makeRenderOptions(axes[this.name]);\n        const hasOnlyAxisLine = this.hasOnlyAxisLine();\n        if (!hasOnlyAxisLine) {\n            this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);\n            this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);\n        }\n        this.models.axisLine = [this.renderAxisLineModel()];\n        if (!this.drawModels) {\n            this.drawModels = {\n                tick: [],\n                label: [],\n                axisLine: this.models.axisLine,\n            };\n            ['tick', 'label'].forEach((type) => {\n                this.drawModels[type] = this.models[type].map((m) => {\n                    const drawModel = Object.assign({}, m);\n                    if (this.yAxisComponent) {\n                        drawModel.y = 0;\n                    }\n                    else {\n                        drawModel.x = 0;\n                    }\n                    return drawModel;\n                });\n            });\n        }\n    }\n    renderAxisLineModel() {\n        const zeroPixel = crispPixel(0);\n        let lineModel;\n        const { color: strokeStyle, width: lineWidth } = this.theme;\n        if (this.yAxisComponent) {\n            const x = this.getYAxisXPoint();\n            lineModel = {\n                type: 'line',\n                x,\n                y: zeroPixel,\n                x2: x,\n                y2: crispPixel(this.axisSize),\n                strokeStyle,\n                lineWidth,\n            };\n        }\n        else {\n            lineModel = {\n                type: 'line',\n                x: zeroPixel,\n                y: zeroPixel,\n                x2: crispPixel(this.axisSize),\n                y2: zeroPixel,\n                strokeStyle,\n                lineWidth,\n            };\n        }\n        return lineModel;\n    }\n    renderTickModels(offsetKey, anchorKey, renderOptions) {\n        const tickAnchorPoint = this.yAxisComponent ? this.getYAxisXPoint() : crispPixel(0);\n        const { tickInterval, relativePositions } = renderOptions;\n        const tickSize = includes([AxisType.SECONDARY_Y, AxisType.X], this.name)\n            ? TICK_SIZE\n            : -TICK_SIZE;\n        return relativePositions.reduce((positions, position, index) => {\n            return index % tickInterval\n                ? positions\n                : [\n                    ...positions,\n                    {\n                        type: 'tick',\n                        isYAxis: this.yAxisComponent,\n                        tickSize,\n                        [offsetKey]: crispPixel(position),\n                        [anchorKey]: tickAnchorPoint,\n                        strokeStyle: this.theme.color,\n                        lineWidth: this.theme.width,\n                    },\n                ];\n        }, []);\n    }\n    renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {\n        const { needRotateLabel, radian, offsetY } = renderOptions;\n        const labelTheme = this.theme.label;\n        const font = getTitleFontString(labelTheme);\n        const textAlign = this.getLabelTextAlign(needRotateLabel);\n        const style = ['default', { textAlign, font, fillStyle: labelTheme.color }];\n        const labelAnchorPoint = this.yAxisComponent ? this.getYAxisAnchorPoint() : offsetY;\n        return labels.map(({ text, offsetPos }) => ({\n            type: 'label',\n            text,\n            style,\n            radian,\n            [offsetKey]: crispPixel(offsetPos),\n            [anchorKey]: labelAnchorPoint,\n        }));\n    }\n    makeRenderOptions(axisData) {\n        const { tickCount, tickInterval } = axisData;\n        const relativePositions = makeTickPixelPositions(this.axisSize, tickCount);\n        if (this.yAxisComponent) {\n            return {\n                relativePositions,\n                tickInterval,\n            };\n        }\n        const { needRotateLabel, radian, offsetY } = axisData;\n        return {\n            relativePositions,\n            tickInterval,\n            needRotateLabel,\n            radian,\n            offsetY,\n        };\n    }\n    getYAxisAnchorPoint() {\n        return this.isRightSide() ? crispPixel(this.rect.width) : crispPixel(0);\n    }\n    getLabelTextAlign(needRotateLabel) {\n        const yAxisTextAlign = this.isRightSide() ? 'right' : 'left';\n        const xAxisTextAlign = needRotateLabel ? 'left' : 'center';\n        return this.yAxisComponent ? yAxisTextAlign : xAxisTextAlign;\n    }\n    isRightSide() {\n        return this.name === AxisType.SECONDARY_Y;\n    }\n    getYAxisXPoint() {\n        return this.isRightSide() ? crispPixel(0) : crispPixel(this.rect.width);\n    }\n    hasOnlyAxisLine() {\n        return ((this.yAxisComponent && !this.rect.width) || (this.name === AxisType.X && !this.rect.height));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}