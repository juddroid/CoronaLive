{"ast":null,"code":"import Component from \"./component\";\nimport { getValueRatio, setSplineControlPoint } from \"../helpers/calculator\";\nimport { getRGBA } from \"../helpers/color\";\nimport { deepCopy, deepMergedCopy, getFirstValidValue, isNull, isUndefined, range, sum } from \"../helpers/utils\";\nimport { isRangeData } from \"../helpers/range\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getNearestResponder, makeRectResponderModel, makeTooltipCircleMap } from \"../helpers/responders\";\nimport { getValueAxisName } from \"../helpers/axes\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { message } from \"../message\";\nimport { isAvailableSelectSeries, isAvailableShowTooltipInfo } from \"../helpers/validation\";\nconst seriesOpacity = {\n  INACTIVE: 0.06,\n  ACTIVE: 1\n};\nexport default class AreaSeries extends Component {\n  constructor() {\n    super(...arguments);\n    this.models = {\n      rect: [],\n      series: [],\n      dot: []\n    };\n    this.activatedResponders = [];\n    this.eventDetectType = 'nearest';\n    this.isStackChart = false;\n    this.isRangeChart = false;\n    this.isSplineChart = false;\n\n    this.onMouseoutComponent = () => {\n      this.eventBus.emit('seriesPointHovered', {\n        models: [],\n        name: this.name\n      });\n      this.eventBus.emit('renderHoveredSeries', {\n        models: [],\n        name: this.name,\n        eventDetectType: this.eventDetectType\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.selectSeries = info => {\n      const {\n        index,\n        seriesIndex\n      } = info;\n\n      if (!isAvailableSelectSeries(info, 'area')) {\n        return;\n      }\n\n      const category = this.getResponderCategoryByIndex(index);\n\n      if (!category) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      const model = this.tooltipCircleMap[category][seriesIndex];\n\n      if (!model) {\n        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models: [model],\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n\n    this.showTooltip = info => {\n      const {\n        index,\n        seriesIndex\n      } = info;\n\n      if (!isAvailableShowTooltipInfo(info, this.eventDetectType, 'area')) {\n        return;\n      }\n\n      const category = this.getResponderCategoryByIndex(index);\n\n      if (!category) {\n        return;\n      }\n\n      const models = this.eventDetectType === 'grouped' ? this.tooltipCircleMap[category] : [this.tooltipCircleMap[category][seriesIndex]];\n\n      if (!models.length) {\n        return;\n      }\n\n      this.onMousemoveNearType(models);\n      this.eventBus.emit('seriesPointHovered', {\n        models: this.activatedResponders,\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    };\n  }\n\n  initialize() {\n    this.type = 'series';\n    this.name = 'area';\n    this.eventBus.on('selectSeries', this.selectSeries);\n    this.eventBus.on('showTooltip', this.showTooltip);\n    this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n  }\n\n  initUpdate(delta) {\n    if (!this.drawModels) {\n      return;\n    }\n\n    this.drawModels.rect[0].width = this.models.rect[0].width * delta;\n  }\n\n  getBaseYPosition(limit) {\n    const baseValue = limit.min >= 0 ? limit.min : Math.min(limit.max, 0);\n    const intervalSize = this.rect.height / (limit.max - limit.min);\n    return (limit.max - baseValue) * intervalSize;\n  }\n\n  getStackValue(areaStackSeries, seriesIndex, index) {\n    const {\n      type\n    } = areaStackSeries.stack;\n    const {\n      values,\n      sum: sumValue\n    } = areaStackSeries.stackData[index];\n    const stackedValue = sum(values.slice(0, seriesIndex + 1));\n    return type === 'percent' ? stackedValue * 100 / sumValue : stackedValue;\n  }\n\n  setEventDetectType(series, options) {\n    var _a, _b;\n\n    if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n      this.eventDetectType = options.series.eventDetectType;\n    }\n\n    if (series.line || this.isStackChart) {\n      this.eventDetectType = 'grouped';\n    }\n  }\n\n  getAreaOptions(options) {\n    var _a;\n\n    const newOptions = Object.assign({}, options);\n\n    if ((_a = newOptions.series) === null || _a === void 0 ? void 0 : _a.area) {\n      newOptions.series = Object.assign(Object.assign({}, newOptions.series), newOptions.series.area);\n    }\n\n    return newOptions;\n  }\n\n  render(chartState, computed) {\n    var _a, _b, _c, _d, _e;\n\n    const {\n      viewRange\n    } = computed;\n    const {\n      layout,\n      series,\n      scale,\n      axes,\n      legend,\n      stackSeries,\n      theme,\n      rawCategories\n    } = chartState;\n\n    if (!series.area) {\n      throw new Error(message.noDataError(this.name));\n    }\n\n    let areaStackSeries;\n    const options = this.getAreaOptions(chartState.options);\n    const categories = chartState.categories;\n    this.theme = theme.series.area;\n    this.rect = layout.plot;\n    this.activeSeriesMap = getActiveSeriesMap(legend);\n    this.startIndex = viewRange ? viewRange[0] : 0;\n    this.selectable = this.getSelectableOption(options);\n    this.isSplineChart = (_b = (_a = options.series) === null || _a === void 0 ? void 0 : _a.spline, _b !== null && _b !== void 0 ? _b : false);\n    const {\n      limit\n    } = scale[getValueAxisName(options, this.name, 'yAxis')];\n    const {\n      tickDistance,\n      pointOnColumn,\n      tickCount\n    } = axes.xAxis;\n    const areaData = series.area.data;\n    this.baseYPosition = this.getBaseYPosition(limit);\n\n    if ((_c = stackSeries) === null || _c === void 0 ? void 0 : _c.area) {\n      this.isStackChart = true;\n      areaStackSeries = stackSeries.area;\n    } else if (isRangeData((_d = getFirstValidValue(areaData)) === null || _d === void 0 ? void 0 : _d.data)) {\n      this.isRangeChart = true;\n    }\n\n    this.setEventDetectType(series, options);\n    const renderOptions = {\n      pointOnColumn,\n      options: options.series || {},\n      tickDistance,\n      tickCount,\n      areaStackSeries\n    };\n    this.linePointsModel = this.renderLinePointsModel(areaData, limit, renderOptions);\n    const areaSeriesModel = this.renderAreaPointsModel();\n    const showDot = !!((_e = options.series) === null || _e === void 0 ? void 0 : _e.showDot);\n    const {\n      dotSeriesModel,\n      responderModel\n    } = this.renderCircleModel(showDot);\n    const tooltipDataArr = this.makeTooltipData(areaData, rawCategories);\n    this.models = deepCopy({\n      rect: [this.renderClipRectAreaModel()],\n      series: [...this.linePointsModel, ...areaSeriesModel],\n      dot: dotSeriesModel\n    });\n\n    if (!this.drawModels) {\n      this.drawModels = Object.assign(Object.assign({}, this.models), {\n        rect: [this.renderClipRectAreaModel(true)]\n      });\n    }\n\n    if (getDataLabelsOptions(options, this.name).visible) {\n      this.renderDataLabels(this.getDataLabels(areaSeriesModel));\n    }\n\n    this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);\n    this.responders = this.eventDetectType === 'near' ? this.makeNearTypeResponderModel(responderModel, tooltipDataArr) : makeRectResponderModel(this.rect, axes.xAxis, categories);\n  }\n\n  makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr) {\n    const tooltipDataLength = tooltipDataArr.length;\n    return seriesCircleModel.map((m, dataIndex) => Object.assign(Object.assign({}, m), {\n      data: tooltipDataArr[dataIndex % tooltipDataLength]\n    }));\n  }\n\n  renderClipRectAreaModel(isDrawModel) {\n    return {\n      type: 'clipRectArea',\n      x: 0,\n      y: 0,\n      width: isDrawModel ? 0 : this.rect.width,\n      height: this.rect.height\n    };\n  }\n\n  makeTooltipData(areaData, categories) {\n    return areaData.flatMap(({\n      rawData,\n      name,\n      color\n    }, seriesIndex) => {\n      const tooltipData = [];\n      rawData.forEach((datum, index) => {\n        if (!isNull(datum)) {\n          const value = this.isRangeChart ? `${datum[0]} ~ ${datum[1]}` : datum;\n          tooltipData.push({\n            label: name,\n            color,\n            value,\n            category: categories[index],\n            seriesIndex,\n            index\n          });\n        }\n      });\n      return tooltipData;\n    });\n  }\n\n  getLinePointModelValue(datum, pairModel) {\n    if (this.isRangeChart) {\n      return pairModel ? datum[0] : datum[1];\n    }\n\n    return datum;\n  }\n\n  getLinePointModel(series, seriesIndex, limit, renderOptions) {\n    const {\n      pointOnColumn,\n      tickDistance,\n      pairModel,\n      areaStackSeries\n    } = renderOptions;\n    const {\n      rawData,\n      name,\n      color: seriesColor\n    } = series;\n    const active = this.activeSeriesMap[name];\n    const points = [];\n    const color = getRGBA(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);\n    const {\n      lineWidth,\n      dashSegments\n    } = this.theme;\n    rawData.forEach((datum, idx) => {\n      if (isNull(datum)) {\n        points.push(null);\n        return;\n      }\n\n      const value = this.getLinePointModelValue(datum, pairModel);\n      const stackedValue = this.isStackChart ? this.getStackValue(areaStackSeries, seriesIndex, idx) : value;\n      const valueRatio = getValueRatio(stackedValue, limit);\n      const x = tickDistance * (idx - this.startIndex) + (pointOnColumn ? tickDistance / 2 : 0);\n      const y = (1 - valueRatio) * this.rect.height;\n      points.push({\n        x,\n        y,\n        value\n      });\n    });\n\n    if (pairModel) {\n      points.reverse(); // for range spline\n    }\n\n    if (this.isSplineChart) {\n      setSplineControlPoint(points);\n    }\n\n    return {\n      type: 'linePoints',\n      lineWidth,\n      dashSegments,\n      color,\n      points,\n      seriesIndex,\n      name\n    };\n  }\n\n  renderLinePointsModel(seriesRawData, limit, renderOptions) {\n    const linePointsModels = seriesRawData.map((series, seriesIndex) => this.getLinePointModel(series, seriesIndex, limit, renderOptions));\n\n    if (this.isRangeChart) {\n      const renderOptionsForPair = deepMergedCopy(renderOptions, {\n        pairModel: true\n      });\n      const pair = seriesRawData.map((series, seriesIndex) => this.getLinePointModel(series, seriesIndex, limit, renderOptionsForPair));\n      linePointsModels.push(...pair);\n    }\n\n    return linePointsModels;\n  }\n\n  getCombinedPoints(start, end) {\n    const startPoints = start >= 0 ? this.linePointsModel[start].points : [];\n    const reversedEndPoints = [...this.linePointsModel[end].points].reverse();\n    return [...startPoints, ...reversedEndPoints];\n  }\n\n  renderRangeAreaSeries(linePointsModel) {\n    const model = [];\n    linePointsModel.forEach(m => {\n      let areaPoints = [];\n      const {\n        points\n      } = m;\n      points.slice(0, points.length / 2 + 1).forEach((point, i) => {\n        const lastPoint = i === points.length / 2 - 1;\n        const nullPoint = isNull(point);\n\n        if (!nullPoint) {\n          areaPoints.push(point);\n        }\n\n        if (areaPoints.length && (lastPoint || nullPoint)) {\n          const pairPoints = areaPoints.map((areaPoint, idx) => {\n            const curIdx = points.length / 2 + i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);\n            return points[curIdx];\n          }).reverse();\n          model.push(Object.assign(Object.assign({}, m), {\n            type: 'areaPoints',\n            lineWidth: 0,\n            color: 'rgba(0, 0, 0, 0)',\n            fillColor: this.getAreaOpacity(m.name, m.color),\n            points: [...areaPoints, ...pairPoints]\n          }));\n          areaPoints = [];\n        }\n      });\n    });\n    return model;\n  }\n\n  renderAreaSeries(linePointsModel) {\n    const model = [];\n    const bottomYPoint = [];\n    linePointsModel.forEach(m => {\n      let areaPoints = [];\n      const curBottomYPoint = [...bottomYPoint];\n      const {\n        points\n      } = m;\n      points.forEach((point, i) => {\n        const lastPoint = i === points.length - 1;\n        const nullPoint = isNull(point);\n\n        if (!isNull(point)) {\n          areaPoints.push(point);\n        }\n\n        if (areaPoints.length && (nullPoint || lastPoint)) {\n          const pairPoints = areaPoints.map((areaPoint, idx) => {\n            const curIdx = i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);\n            const bottom = isUndefined(curBottomYPoint[curIdx]) ? this.baseYPosition : curBottomYPoint[curIdx];\n\n            if (this.isStackChart) {\n              bottomYPoint[curIdx] = areaPoint.y;\n            }\n\n            return {\n              x: areaPoint.x,\n              y: bottom\n            };\n          }).reverse();\n\n          if (this.isStackChart && this.isSplineChart) {\n            setSplineControlPoint(pairPoints); // set spline for new stack pair points\n          }\n\n          model.push(Object.assign(Object.assign({}, m), {\n            type: 'areaPoints',\n            lineWidth: 0,\n            color: 'rgba(0, 0, 0, 0)',\n            fillColor: this.getAreaOpacity(m.name, m.color),\n            points: [...areaPoints, ...pairPoints]\n          }));\n          areaPoints = [];\n        }\n      });\n    });\n    return model;\n  }\n\n  getCombinedLinePointsModel() {\n    if (!this.isRangeChart) {\n      return this.linePointsModel;\n    }\n\n    const len = this.linePointsModel.length / 2;\n    return range(0, len).reduce((acc, i) => {\n      const start = i;\n      const end = len + i;\n      const points = this.getCombinedPoints(start, end);\n      return [...acc, Object.assign(Object.assign({}, this.linePointsModel[i]), {\n        points\n      })];\n    }, []);\n  }\n\n  getAreaOpacity(name, color) {\n    const {\n      select,\n      areaOpacity\n    } = this.theme;\n    const active = this.activeSeriesMap[name];\n    const selected = Object.values(this.activeSeriesMap).some(elem => !elem);\n    return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);\n  }\n\n  renderAreaPointsModel() {\n    const combinedLinePointsModel = this.getCombinedLinePointsModel();\n    return this.isRangeChart ? this.renderRangeAreaSeries(combinedLinePointsModel) : this.renderAreaSeries(combinedLinePointsModel);\n  }\n\n  renderCircleModel(showDot) {\n    const dotSeriesModel = [];\n    const responderModel = [];\n    const {\n      hover,\n      dot: dotTheme\n    } = this.theme;\n    const hoverDotTheme = hover.dot;\n    this.linePointsModel.forEach(({\n      points,\n      color,\n      seriesIndex,\n      name\n    }, modelIndex) => {\n      const isPairLinePointsModel = this.isRangeChart && modelIndex >= this.linePointsModel.length / 2;\n      const active = this.activeSeriesMap[name];\n      points.forEach((point, index) => {\n        var _a, _b, _c;\n\n        if (isNull(point)) {\n          return;\n        }\n\n        const model = Object.assign(Object.assign({\n          type: 'circle'\n        }, point), {\n          seriesIndex,\n          name,\n          index: isPairLinePointsModel ? points.length - index - 1 : index\n        });\n\n        if (showDot) {\n          dotSeriesModel.push(Object.assign(Object.assign({}, model), {\n            radius: dotTheme.radius,\n            color: getRGBA(color, active ? 1 : 0.3),\n            style: [{\n              lineWidth: dotTheme.borderWidth,\n              strokeStyle: (_a = dotTheme.borderColor, _a !== null && _a !== void 0 ? _a : color)\n            }]\n          }));\n        }\n\n        const modelColor = (_b = hoverDotTheme.color, _b !== null && _b !== void 0 ? _b : getRGBA(color, 1));\n        responderModel.push(Object.assign(Object.assign({}, model), {\n          radius: hoverDotTheme.radius,\n          color: modelColor,\n          style: [{\n            lineWidth: hoverDotTheme.borderWidth,\n            strokeStyle: (_c = hoverDotTheme.borderColor, _c !== null && _c !== void 0 ? _c : getRGBA(modelColor, 0.5))\n          }]\n        }));\n      });\n    });\n    return {\n      dotSeriesModel,\n      responderModel\n    };\n  }\n\n  getPairCircleModel(circleModels) {\n    const pairCircleModels = [];\n    circleModels.forEach(circle => {\n      const {\n        seriesIndex,\n        y,\n        data\n      } = circle;\n      const {\n        category\n      } = data;\n      const pairCircleModel = this.tooltipCircleMap[category].find(model => model.seriesIndex === seriesIndex && model.y !== y);\n      pairCircleModels.push(pairCircleModel);\n    });\n    return pairCircleModels;\n  }\n\n  getCircleModelsFromRectResponders(responders, mousePositions) {\n    var _a;\n\n    if (!responders.length || !responders[0].label) {\n      return [];\n    }\n\n    const models = (_a = this.tooltipCircleMap[responders[0].label], _a !== null && _a !== void 0 ? _a : []);\n    return this.eventDetectType === 'grouped' ? models : getNearestResponder(models, mousePositions, this.rect);\n  }\n\n  onMousemoveGroupedType(responders) {\n    const circleModels = this.getCircleModelsFromRectResponders(responders);\n    this.eventBus.emit('renderHoveredSeries', {\n      models: circleModels,\n      name: this.name,\n      eventDetectType: this.eventDetectType\n    });\n    this.activatedResponders = this.isRangeChart ? circleModels.slice(0, circleModels.length / 2) // for rendering unique tooltip data\n    : circleModels;\n  }\n\n  onMousemoveNearestType(responders, mousePositions) {\n    const circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);\n    this.onMousemoveNearType(circleModels);\n  }\n\n  onMousemoveNearType(responders) {\n    let pairCircleModels = [];\n\n    if (this.isRangeChart) {\n      pairCircleModels = this.getPairCircleModel(responders);\n    }\n\n    const hoveredSeries = [...responders, ...pairCircleModels];\n    this.eventBus.emit('renderHoveredSeries', {\n      models: hoveredSeries,\n      name: this.name,\n      eventDetectType: this.eventDetectType\n    });\n    this.activatedResponders = responders;\n  }\n\n  onMousemove({\n    responders,\n    mousePosition\n  }) {\n    if (this.eventDetectType === 'nearest') {\n      this.onMousemoveNearestType(responders, mousePosition);\n    } else if (this.eventDetectType === 'near') {\n      this.onMousemoveNearType(responders);\n    } else {\n      this.onMousemoveGroupedType(responders);\n    }\n\n    this.eventBus.emit('seriesPointHovered', {\n      models: this.activatedResponders,\n      name: this.name\n    });\n    this.eventBus.emit('needDraw');\n  }\n\n  getDataLabels(seriesModels) {\n    const dataLabelTheme = this.theme.dataLabels;\n    return seriesModels.flatMap(({\n      points,\n      name,\n      fillColor\n    }) => points.map(point => isNull(point) ? {} : Object.assign(Object.assign({\n      type: 'point'\n    }, point), {\n      name,\n      theme: Object.assign(Object.assign({}, dataLabelTheme), {\n        color: dataLabelTheme.useSeriesColor ? getRGBA(fillColor, 1) : dataLabelTheme.color\n      })\n    })));\n  }\n\n  getSelectedSeriesWithTheme(models) {\n    const {\n      radius,\n      color,\n      borderWidth,\n      borderColor\n    } = this.theme.select.dot;\n    return models.map(model => {\n      const modelColor = color !== null && color !== void 0 ? color : model.color;\n      return Object.assign(Object.assign({}, model), {\n        radius,\n        color: modelColor,\n        style: [{\n          lineWidth: borderWidth,\n          strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)\n        }]\n      });\n    });\n  }\n\n  onClick({\n    responders,\n    mousePosition\n  }) {\n    if (this.selectable) {\n      let models;\n\n      if (this.eventDetectType === 'near') {\n        models = responders;\n      } else {\n        models = this.getCircleModelsFromRectResponders(responders, mousePosition);\n      }\n\n      this.eventBus.emit('renderSelectedSeries', {\n        models: this.getSelectedSeriesWithTheme(models),\n        name: this.name\n      });\n      this.eventBus.emit('needDraw');\n    }\n  }\n\n  getResponderCategoryByIndex(index) {\n    var _a, _b;\n\n    const responder = Object.values(this.tooltipCircleMap).flatMap(val => val).find(model => model.index === index);\n    return (_b = (_a = responder) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.category;\n  }\n\n}","map":{"version":3,"sources":["/Users/raccoon/Desktop/fe-w6-free-style/node_modules/@toast-ui/chart/dist/esm/component/areaSeries.js"],"names":["Component","getValueRatio","setSplineControlPoint","getRGBA","deepCopy","deepMergedCopy","getFirstValidValue","isNull","isUndefined","range","sum","isRangeData","getActiveSeriesMap","getNearestResponder","makeRectResponderModel","makeTooltipCircleMap","getValueAxisName","getDataLabelsOptions","message","isAvailableSelectSeries","isAvailableShowTooltipInfo","seriesOpacity","INACTIVE","ACTIVE","AreaSeries","constructor","arguments","models","rect","series","dot","activatedResponders","eventDetectType","isStackChart","isRangeChart","isSplineChart","onMouseoutComponent","eventBus","emit","name","selectSeries","info","index","seriesIndex","category","getResponderCategoryByIndex","Error","SELECT_SERIES_API_INDEX_ERROR","model","tooltipCircleMap","showTooltip","length","onMousemoveNearType","initialize","type","on","initUpdate","delta","drawModels","width","getBaseYPosition","limit","baseValue","min","Math","max","intervalSize","height","getStackValue","areaStackSeries","stack","values","sumValue","stackData","stackedValue","slice","setEventDetectType","options","_a","_b","line","getAreaOptions","newOptions","Object","assign","area","render","chartState","computed","_c","_d","_e","viewRange","layout","scale","axes","legend","stackSeries","theme","rawCategories","noDataError","categories","plot","activeSeriesMap","startIndex","selectable","getSelectableOption","spline","tickDistance","pointOnColumn","tickCount","xAxis","areaData","data","baseYPosition","renderOptions","linePointsModel","renderLinePointsModel","areaSeriesModel","renderAreaPointsModel","showDot","dotSeriesModel","responderModel","renderCircleModel","tooltipDataArr","makeTooltipData","renderClipRectAreaModel","visible","renderDataLabels","getDataLabels","responders","makeNearTypeResponderModel","seriesCircleModel","tooltipDataLength","map","m","dataIndex","isDrawModel","x","y","flatMap","rawData","color","tooltipData","forEach","datum","value","push","label","getLinePointModelValue","pairModel","getLinePointModel","seriesColor","active","points","lineWidth","dashSegments","idx","valueRatio","reverse","seriesRawData","linePointsModels","renderOptionsForPair","pair","getCombinedPoints","start","end","startPoints","reversedEndPoints","renderRangeAreaSeries","areaPoints","point","i","lastPoint","nullPoint","pairPoints","areaPoint","curIdx","fillColor","getAreaOpacity","renderAreaSeries","bottomYPoint","curBottomYPoint","bottom","getCombinedLinePointsModel","len","reduce","acc","select","areaOpacity","selected","some","elem","restSeries","combinedLinePointsModel","hover","dotTheme","hoverDotTheme","modelIndex","isPairLinePointsModel","radius","style","borderWidth","strokeStyle","borderColor","modelColor","getPairCircleModel","circleModels","pairCircleModels","circle","pairCircleModel","find","getCircleModelsFromRectResponders","mousePositions","onMousemoveGroupedType","onMousemoveNearestType","hoveredSeries","onMousemove","mousePosition","seriesModels","dataLabelTheme","dataLabels","useSeriesColor","getSelectedSeriesWithTheme","onClick","responder","val"],"mappings":"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","sourcesContent":["import Component from \"./component\";\nimport { getValueRatio, setSplineControlPoint } from \"../helpers/calculator\";\nimport { getRGBA } from \"../helpers/color\";\nimport { deepCopy, deepMergedCopy, getFirstValidValue, isNull, isUndefined, range, sum, } from \"../helpers/utils\";\nimport { isRangeData } from \"../helpers/range\";\nimport { getActiveSeriesMap } from \"../helpers/legend\";\nimport { getNearestResponder, makeRectResponderModel, makeTooltipCircleMap, } from \"../helpers/responders\";\nimport { getValueAxisName } from \"../helpers/axes\";\nimport { getDataLabelsOptions } from \"../helpers/dataLabels\";\nimport { message } from \"../message\";\nimport { isAvailableSelectSeries, isAvailableShowTooltipInfo } from \"../helpers/validation\";\nconst seriesOpacity = {\n    INACTIVE: 0.06,\n    ACTIVE: 1,\n};\nexport default class AreaSeries extends Component {\n    constructor() {\n        super(...arguments);\n        this.models = { rect: [], series: [], dot: [] };\n        this.activatedResponders = [];\n        this.eventDetectType = 'nearest';\n        this.isStackChart = false;\n        this.isRangeChart = false;\n        this.isSplineChart = false;\n        this.onMouseoutComponent = () => {\n            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });\n            this.eventBus.emit('renderHoveredSeries', {\n                models: [],\n                name: this.name,\n                eventDetectType: this.eventDetectType,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.selectSeries = (info) => {\n            const { index, seriesIndex } = info;\n            if (!isAvailableSelectSeries(info, 'area')) {\n                return;\n            }\n            const category = this.getResponderCategoryByIndex(index);\n            if (!category) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            const model = this.tooltipCircleMap[category][seriesIndex];\n            if (!model) {\n                throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models: [model],\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        };\n        this.showTooltip = (info) => {\n            const { index, seriesIndex } = info;\n            if (!isAvailableShowTooltipInfo(info, this.eventDetectType, 'area')) {\n                return;\n            }\n            const category = this.getResponderCategoryByIndex(index);\n            if (!category) {\n                return;\n            }\n            const models = this.eventDetectType === 'grouped'\n                ? this.tooltipCircleMap[category]\n                : [this.tooltipCircleMap[category][seriesIndex]];\n            if (!models.length) {\n                return;\n            }\n            this.onMousemoveNearType(models);\n            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n            this.eventBus.emit('needDraw');\n        };\n    }\n    initialize() {\n        this.type = 'series';\n        this.name = 'area';\n        this.eventBus.on('selectSeries', this.selectSeries);\n        this.eventBus.on('showTooltip', this.showTooltip);\n        this.eventBus.on('hideTooltip', this.onMouseoutComponent);\n    }\n    initUpdate(delta) {\n        if (!this.drawModels) {\n            return;\n        }\n        this.drawModels.rect[0].width = this.models.rect[0].width * delta;\n    }\n    getBaseYPosition(limit) {\n        const baseValue = limit.min >= 0 ? limit.min : Math.min(limit.max, 0);\n        const intervalSize = this.rect.height / (limit.max - limit.min);\n        return (limit.max - baseValue) * intervalSize;\n    }\n    getStackValue(areaStackSeries, seriesIndex, index) {\n        const { type } = areaStackSeries.stack;\n        const { values, sum: sumValue } = areaStackSeries.stackData[index];\n        const stackedValue = sum(values.slice(0, seriesIndex + 1));\n        return type === 'percent' ? (stackedValue * 100) / sumValue : stackedValue;\n    }\n    setEventDetectType(series, options) {\n        var _a, _b;\n        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {\n            this.eventDetectType = options.series.eventDetectType;\n        }\n        if (series.line || this.isStackChart) {\n            this.eventDetectType = 'grouped';\n        }\n    }\n    getAreaOptions(options) {\n        var _a;\n        const newOptions = Object.assign({}, options);\n        if ((_a = newOptions.series) === null || _a === void 0 ? void 0 : _a.area) {\n            newOptions.series = Object.assign(Object.assign({}, newOptions.series), newOptions.series.area);\n        }\n        return newOptions;\n    }\n    render(chartState, computed) {\n        var _a, _b, _c, _d, _e;\n        const { viewRange } = computed;\n        const { layout, series, scale, axes, legend, stackSeries, theme, rawCategories } = chartState;\n        if (!series.area) {\n            throw new Error(message.noDataError(this.name));\n        }\n        let areaStackSeries;\n        const options = this.getAreaOptions(chartState.options);\n        const categories = chartState.categories;\n        this.theme = theme.series.area;\n        this.rect = layout.plot;\n        this.activeSeriesMap = getActiveSeriesMap(legend);\n        this.startIndex = viewRange ? viewRange[0] : 0;\n        this.selectable = this.getSelectableOption(options);\n        this.isSplineChart = (_b = (_a = options.series) === null || _a === void 0 ? void 0 : _a.spline, (_b !== null && _b !== void 0 ? _b : false));\n        const { limit } = scale[getValueAxisName(options, this.name, 'yAxis')];\n        const { tickDistance, pointOnColumn, tickCount } = axes.xAxis;\n        const areaData = series.area.data;\n        this.baseYPosition = this.getBaseYPosition(limit);\n        if ((_c = stackSeries) === null || _c === void 0 ? void 0 : _c.area) {\n            this.isStackChart = true;\n            areaStackSeries = stackSeries.area;\n        }\n        else if (isRangeData((_d = getFirstValidValue(areaData)) === null || _d === void 0 ? void 0 : _d.data)) {\n            this.isRangeChart = true;\n        }\n        this.setEventDetectType(series, options);\n        const renderOptions = {\n            pointOnColumn,\n            options: options.series || {},\n            tickDistance,\n            tickCount,\n            areaStackSeries,\n        };\n        this.linePointsModel = this.renderLinePointsModel(areaData, limit, renderOptions);\n        const areaSeriesModel = this.renderAreaPointsModel();\n        const showDot = !!((_e = options.series) === null || _e === void 0 ? void 0 : _e.showDot);\n        const { dotSeriesModel, responderModel } = this.renderCircleModel(showDot);\n        const tooltipDataArr = this.makeTooltipData(areaData, rawCategories);\n        this.models = deepCopy({\n            rect: [this.renderClipRectAreaModel()],\n            series: [...this.linePointsModel, ...areaSeriesModel],\n            dot: dotSeriesModel,\n        });\n        if (!this.drawModels) {\n            this.drawModels = Object.assign(Object.assign({}, this.models), { rect: [this.renderClipRectAreaModel(true)] });\n        }\n        if (getDataLabelsOptions(options, this.name).visible) {\n            this.renderDataLabels(this.getDataLabels(areaSeriesModel));\n        }\n        this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);\n        this.responders =\n            this.eventDetectType === 'near'\n                ? this.makeNearTypeResponderModel(responderModel, tooltipDataArr)\n                : makeRectResponderModel(this.rect, axes.xAxis, categories);\n    }\n    makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr) {\n        const tooltipDataLength = tooltipDataArr.length;\n        return seriesCircleModel.map((m, dataIndex) => (Object.assign(Object.assign({}, m), { data: tooltipDataArr[dataIndex % tooltipDataLength] })));\n    }\n    renderClipRectAreaModel(isDrawModel) {\n        return {\n            type: 'clipRectArea',\n            x: 0,\n            y: 0,\n            width: isDrawModel ? 0 : this.rect.width,\n            height: this.rect.height,\n        };\n    }\n    makeTooltipData(areaData, categories) {\n        return areaData.flatMap(({ rawData, name, color }, seriesIndex) => {\n            const tooltipData = [];\n            rawData.forEach((datum, index) => {\n                if (!isNull(datum)) {\n                    const value = this.isRangeChart ? `${datum[0]} ~ ${datum[1]}` : datum;\n                    tooltipData.push({\n                        label: name,\n                        color,\n                        value,\n                        category: categories[index],\n                        seriesIndex,\n                        index,\n                    });\n                }\n            });\n            return tooltipData;\n        });\n    }\n    getLinePointModelValue(datum, pairModel) {\n        if (this.isRangeChart) {\n            return pairModel ? datum[0] : datum[1];\n        }\n        return datum;\n    }\n    getLinePointModel(series, seriesIndex, limit, renderOptions) {\n        const { pointOnColumn, tickDistance, pairModel, areaStackSeries } = renderOptions;\n        const { rawData, name, color: seriesColor } = series;\n        const active = this.activeSeriesMap[name];\n        const points = [];\n        const color = getRGBA(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);\n        const { lineWidth, dashSegments } = this.theme;\n        rawData.forEach((datum, idx) => {\n            if (isNull(datum)) {\n                points.push(null);\n                return;\n            }\n            const value = this.getLinePointModelValue(datum, pairModel);\n            const stackedValue = this.isStackChart\n                ? this.getStackValue(areaStackSeries, seriesIndex, idx)\n                : value;\n            const valueRatio = getValueRatio(stackedValue, limit);\n            const x = tickDistance * (idx - this.startIndex) + (pointOnColumn ? tickDistance / 2 : 0);\n            const y = (1 - valueRatio) * this.rect.height;\n            points.push({ x, y, value });\n        });\n        if (pairModel) {\n            points.reverse(); // for range spline\n        }\n        if (this.isSplineChart) {\n            setSplineControlPoint(points);\n        }\n        return {\n            type: 'linePoints',\n            lineWidth,\n            dashSegments,\n            color,\n            points,\n            seriesIndex,\n            name,\n        };\n    }\n    renderLinePointsModel(seriesRawData, limit, renderOptions) {\n        const linePointsModels = seriesRawData.map((series, seriesIndex) => this.getLinePointModel(series, seriesIndex, limit, renderOptions));\n        if (this.isRangeChart) {\n            const renderOptionsForPair = deepMergedCopy(renderOptions, { pairModel: true });\n            const pair = seriesRawData.map((series, seriesIndex) => this.getLinePointModel(series, seriesIndex, limit, renderOptionsForPair));\n            linePointsModels.push(...pair);\n        }\n        return linePointsModels;\n    }\n    getCombinedPoints(start, end) {\n        const startPoints = start >= 0 ? this.linePointsModel[start].points : [];\n        const reversedEndPoints = [...this.linePointsModel[end].points].reverse();\n        return [...startPoints, ...reversedEndPoints];\n    }\n    renderRangeAreaSeries(linePointsModel) {\n        const model = [];\n        linePointsModel.forEach((m) => {\n            let areaPoints = [];\n            const { points } = m;\n            points.slice(0, points.length / 2 + 1).forEach((point, i) => {\n                const lastPoint = i === points.length / 2 - 1;\n                const nullPoint = isNull(point);\n                if (!nullPoint) {\n                    areaPoints.push(point);\n                }\n                if (areaPoints.length && (lastPoint || nullPoint)) {\n                    const pairPoints = areaPoints\n                        .map((areaPoint, idx) => {\n                        const curIdx = points.length / 2 + i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);\n                        return points[curIdx];\n                    })\n                        .reverse();\n                    model.push(Object.assign(Object.assign({}, m), { type: 'areaPoints', lineWidth: 0, color: 'rgba(0, 0, 0, 0)', fillColor: this.getAreaOpacity(m.name, m.color), points: [...areaPoints, ...pairPoints] }));\n                    areaPoints = [];\n                }\n            });\n        });\n        return model;\n    }\n    renderAreaSeries(linePointsModel) {\n        const model = [];\n        const bottomYPoint = [];\n        linePointsModel.forEach((m) => {\n            let areaPoints = [];\n            const curBottomYPoint = [...bottomYPoint];\n            const { points } = m;\n            points.forEach((point, i) => {\n                const lastPoint = i === points.length - 1;\n                const nullPoint = isNull(point);\n                if (!isNull(point)) {\n                    areaPoints.push(point);\n                }\n                if (areaPoints.length && (nullPoint || lastPoint)) {\n                    const pairPoints = areaPoints\n                        .map((areaPoint, idx) => {\n                        const curIdx = i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);\n                        const bottom = isUndefined(curBottomYPoint[curIdx])\n                            ? this.baseYPosition\n                            : curBottomYPoint[curIdx];\n                        if (this.isStackChart) {\n                            bottomYPoint[curIdx] = areaPoint.y;\n                        }\n                        return { x: areaPoint.x, y: bottom };\n                    })\n                        .reverse();\n                    if (this.isStackChart && this.isSplineChart) {\n                        setSplineControlPoint(pairPoints); // set spline for new stack pair points\n                    }\n                    model.push(Object.assign(Object.assign({}, m), { type: 'areaPoints', lineWidth: 0, color: 'rgba(0, 0, 0, 0)', fillColor: this.getAreaOpacity(m.name, m.color), points: [...areaPoints, ...pairPoints] }));\n                    areaPoints = [];\n                }\n            });\n        });\n        return model;\n    }\n    getCombinedLinePointsModel() {\n        if (!this.isRangeChart) {\n            return this.linePointsModel;\n        }\n        const len = this.linePointsModel.length / 2;\n        return range(0, len).reduce((acc, i) => {\n            const start = i;\n            const end = len + i;\n            const points = this.getCombinedPoints(start, end);\n            return [...acc, Object.assign(Object.assign({}, this.linePointsModel[i]), { points })];\n        }, []);\n    }\n    getAreaOpacity(name, color) {\n        const { select, areaOpacity } = this.theme;\n        const active = this.activeSeriesMap[name];\n        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);\n        return selected\n            ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity)\n            : getRGBA(color, areaOpacity);\n    }\n    renderAreaPointsModel() {\n        const combinedLinePointsModel = this.getCombinedLinePointsModel();\n        return this.isRangeChart\n            ? this.renderRangeAreaSeries(combinedLinePointsModel)\n            : this.renderAreaSeries(combinedLinePointsModel);\n    }\n    renderCircleModel(showDot) {\n        const dotSeriesModel = [];\n        const responderModel = [];\n        const { hover, dot: dotTheme } = this.theme;\n        const hoverDotTheme = hover.dot;\n        this.linePointsModel.forEach(({ points, color, seriesIndex, name }, modelIndex) => {\n            const isPairLinePointsModel = this.isRangeChart && modelIndex >= this.linePointsModel.length / 2;\n            const active = this.activeSeriesMap[name];\n            points.forEach((point, index) => {\n                var _a, _b, _c;\n                if (isNull(point)) {\n                    return;\n                }\n                const model = Object.assign(Object.assign({ type: 'circle' }, point), { seriesIndex,\n                    name, index: isPairLinePointsModel ? points.length - index - 1 : index });\n                if (showDot) {\n                    dotSeriesModel.push(Object.assign(Object.assign({}, model), { radius: dotTheme.radius, color: getRGBA(color, active ? 1 : 0.3), style: [\n                            { lineWidth: dotTheme.borderWidth, strokeStyle: (_a = dotTheme.borderColor, (_a !== null && _a !== void 0 ? _a : color)) },\n                        ] }));\n                }\n                const modelColor = (_b = hoverDotTheme.color, (_b !== null && _b !== void 0 ? _b : getRGBA(color, 1)));\n                responderModel.push(Object.assign(Object.assign({}, model), { radius: hoverDotTheme.radius, color: modelColor, style: [\n                        {\n                            lineWidth: hoverDotTheme.borderWidth,\n                            strokeStyle: (_c = hoverDotTheme.borderColor, (_c !== null && _c !== void 0 ? _c : getRGBA(modelColor, 0.5))),\n                        },\n                    ] }));\n            });\n        });\n        return { dotSeriesModel, responderModel };\n    }\n    getPairCircleModel(circleModels) {\n        const pairCircleModels = [];\n        circleModels.forEach((circle) => {\n            const { seriesIndex, y, data } = circle;\n            const { category } = data;\n            const pairCircleModel = this.tooltipCircleMap[category].find((model) => model.seriesIndex === seriesIndex && model.y !== y);\n            pairCircleModels.push(pairCircleModel);\n        });\n        return pairCircleModels;\n    }\n    getCircleModelsFromRectResponders(responders, mousePositions) {\n        var _a;\n        if (!responders.length || !responders[0].label) {\n            return [];\n        }\n        const models = (_a = this.tooltipCircleMap[responders[0].label], (_a !== null && _a !== void 0 ? _a : []));\n        return this.eventDetectType === 'grouped'\n            ? models\n            : getNearestResponder(models, mousePositions, this.rect);\n    }\n    onMousemoveGroupedType(responders) {\n        const circleModels = this.getCircleModelsFromRectResponders(responders);\n        this.eventBus.emit('renderHoveredSeries', {\n            models: circleModels,\n            name: this.name,\n            eventDetectType: this.eventDetectType,\n        });\n        this.activatedResponders = this.isRangeChart\n            ? circleModels.slice(0, circleModels.length / 2) // for rendering unique tooltip data\n            : circleModels;\n    }\n    onMousemoveNearestType(responders, mousePositions) {\n        const circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);\n        this.onMousemoveNearType(circleModels);\n    }\n    onMousemoveNearType(responders) {\n        let pairCircleModels = [];\n        if (this.isRangeChart) {\n            pairCircleModels = this.getPairCircleModel(responders);\n        }\n        const hoveredSeries = [...responders, ...pairCircleModels];\n        this.eventBus.emit('renderHoveredSeries', {\n            models: hoveredSeries,\n            name: this.name,\n            eventDetectType: this.eventDetectType,\n        });\n        this.activatedResponders = responders;\n    }\n    onMousemove({ responders, mousePosition }) {\n        if (this.eventDetectType === 'nearest') {\n            this.onMousemoveNearestType(responders, mousePosition);\n        }\n        else if (this.eventDetectType === 'near') {\n            this.onMousemoveNearType(responders);\n        }\n        else {\n            this.onMousemoveGroupedType(responders);\n        }\n        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });\n        this.eventBus.emit('needDraw');\n    }\n    getDataLabels(seriesModels) {\n        const dataLabelTheme = this.theme.dataLabels;\n        return seriesModels.flatMap(({ points, name, fillColor }) => points.map((point) => isNull(point)\n            ? {}\n            : Object.assign(Object.assign({ type: 'point' }, point), { name, theme: Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? getRGBA(fillColor, 1) : dataLabelTheme.color }) })));\n    }\n    getSelectedSeriesWithTheme(models) {\n        const { radius, color, borderWidth, borderColor } = this.theme.select.dot;\n        return models.map((model) => {\n            const modelColor = (color !== null && color !== void 0 ? color : model.color);\n            return Object.assign(Object.assign({}, model), { radius, color: modelColor, style: [{ lineWidth: borderWidth, strokeStyle: (borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)) }] });\n        });\n    }\n    onClick({ responders, mousePosition }) {\n        if (this.selectable) {\n            let models;\n            if (this.eventDetectType === 'near') {\n                models = responders;\n            }\n            else {\n                models = this.getCircleModelsFromRectResponders(responders, mousePosition);\n            }\n            this.eventBus.emit('renderSelectedSeries', {\n                models: this.getSelectedSeriesWithTheme(models),\n                name: this.name,\n            });\n            this.eventBus.emit('needDraw');\n        }\n    }\n    getResponderCategoryByIndex(index) {\n        var _a, _b;\n        const responder = Object.values(this.tooltipCircleMap)\n            .flatMap((val) => val)\n            .find((model) => model.index === index);\n        return (_b = (_a = responder) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.category;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}